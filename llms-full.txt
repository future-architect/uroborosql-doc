---
url: /uroborosql-doc/background.md
---

# 2WaySQL

**uroboroSQL**の基本操作について説明する前に**uroboroSQL**を利用する上で必要になる項目について説明します。

## 2WaySQLとは

2WaySQLは普通のSQL文をファイルに保存したものです。そのままSQLクライアントツールで実行することもできますし、**uroboroSQL**で読み込んで実行することも出来ます。\
（２つの実行方法があることから**2Way**SQLと呼ばれます）

## バインドパラメータ (`/* */`)

SQLにバインドするパラメータを `/*parameterName*/`の形式で指定することができます。\
`parameterName` はBeanのフィールドとの親和性を考慮し、キャメルケースで記述することが慣例となっています。

```sql
select
  *
from
  department
where
  dept_no    =  /*deptNo*/10
AND  dept_name  =  /*deptName*/'Sales'
```

上の例では、`/*deptNo*/`, `/*deptName*/` がバインドパラメータで、**uroboroSQL**から実行される際はこの部分が`?`に置き換わり、後ろの`10`や`'Sales'`が削除されます。

```sql
select
  *
from
  department
where
  dept_no    =  ?/*deptNo*/
and  dept_name  =  ?/*deptName*/
```

### IN句の利用方法

List型の値をIN句のバインドパラメータとして指定することもできます。
::: warning
IN句にバインドパラメータを指定する場合、バインドパラメータの後ろに`()`を記述する必要があります。
:::

```sql
select
  *
from
  employee  emp
where
/*IF genderList != null*/
and  emp.gender  in  /*genderList*/('M')
/*END*/
```

上の例に`genderList`として{"M", "F"}を指定すると以下のように変換されます。

```sql
select
  *
from
  employee  emp
where
/*IF genderList != null*/
and  emp.gender  in  (?, ?)/*genderList*/
/*END*/
```

### LIKE句の利用方法

LIKE句に対してバインドパラメータを使用する場合は、以下のように[SqlFunction](./el.md#SqlFunction-sf)を使って記述してください。

```sql
select
  *
from
  employee  emp
where
/*IF firstName != null*/
and  emp.first_name like /*SF.contains(firstName)*/'' escape /*#ESC_CHAR*/'$'
/*END*/
/*IF lastName != null*/
and  emp.last_name  like /*SF.startsWith(lastName)*/'' escape /*#ESC_CHAR*/'$'
/*END*/
```

上の例で、バインドパラメータ `firstName`に`a`, `lastName`に`D`を指定した場合は以下のようになります。

```sql
select
  *
from
  employee  emp
where
    emp.first_name like '%a%' escape '$'
and emp.last_name  like 'D%' escape '$'
/*END*/
```

上の例で、ワイルドカードを含む例としてバインドパラメータ `firstName`に`a%`, `lastName`に`D_`を指定した場合は以下のようになります。

```sql
select
  *
from
  employee  emp
where
    emp.first_name like '%a$%%' escape '$' -- %がエスケープされる
and emp.last_name  like 'D$_%' escape '$'  -- _がエスケープされる
/*END*/
```

::: tip
ワイルドカード（`%`や`_`）を含む文字列がバインドパラメータに指定された場合でも、[SqlFunction](./el.md#SqlFunction-sf)を利用することで文字列のエスケープ処理が適切に行われます。
:::

::: warning
エスケープキャラクタ（上記の例では`$`）はDB毎の設定（[Dialect](../configuration/dialect.md#dialect)）によって変わります。\
現在の設定では、Oracleの場合は`\`, その他のDBでは`$`となります。\
`\`や`$`のかわりに`/*#ESC_CHAR*/`と記載することでDB毎の設定を気にせずにエスケープ文字を指定することができます。
:::

## バインド出来るパラメータの型

バインドパラメータに指定できるJava型は以下になります。

* プリミティブ型とそのラッパー型（ただし char と java.lang.Character は除く）
* java.math.BigDecimal
* java.math.BigInteger
* java.lang.String
* byte\[]
* java.sql.Date
* java.sql.Time
* java.sql.Timestamp
* java.sql.Array
* java.sql.Ref
* java.sql.Blob
* java.sql.Clob
* java.sql.SQLXML
* java.sql.Struct
* 列挙型(enum)
* java.util.Date
* java.util.Optional
* java.util.OptionalInt
* java.util.OptionalLong
* java.util.OptionalDouble
* java.time.LocalDateTime
* java.time.OffsetDateTime
* java.time.ZonedDateTime
* java.time.LocalDate
* java.time.LocalTime
* java.time.OffsetTime
* java.time.Year
* java.time.YearMonth
* java.time.MonthDay
* java.time.Month
* java.time.DayOfWeek

## 置換文字列 (`/*$ */` , `/*# */`)

置換文字列を使うとSQLを動的に変更することができます。

置換文字列は `/*$parameterName*/` もしくは `/*#parameterName*/`と記述します。\
`/*#parameterName*/` と記述した場合は、置換文字列の前後を`'`(シングルクォート)で囲みます。

```sql
select
  *
from    /*$tableName*/
where
  gender  =  /*#gender*/
```

上の例では、`tableName`や`gender`に設定した値でSQLが置換されます。

* `tableName`に`employee`, `gender`に`M`を設定した場合

```sql
select
  *
from  employee
where
  gender  =  'M'
```

という風に置換されたSQLが実行されることになります。

::: danger 注意
置換文字列はSQLインジェクションなど脆弱性の原因となる可能性があります。十分に注意を払ったうえで利用してください
:::

::: tip
置換文字列はSQLインジェクションを防ぐため、変換の際にシングルクォート`'`を`''`にエスケープします
:::

::: warning
置換文字列はバインドパラメータとしてではなく実行されるSQLを構築する時点で置換される点に注意してください。\
データベースによってはSQL文が動的に変わることで解析結果のキャッシュが適用されず、\
解析処理が都度実行されることでCPUに負荷をかける可能性があります。
:::

## 条件分岐 ( `/*IF*/`, `/*ELIF*/`, `/*ELSE*/`, `/*END*/` )

`/*IF*/`, `/*ELIF*/`, `/*ELSE*/`, `/*END*/` を使用してSQLを動的に変更することができます。

### 記述方法

```sql
/*IF [評価式]*/
-- IFの評価式が真の場合に適用されるSQL
/*ELIF [評価式]*/
-- ELIFの評価式が真の場合に適用されるSQL
/*ELSE*/
-- IF,ELIFの評価式が偽の場合に適用されるSQL
/*END*/
```

`/*IF*/`, `/*ELIF*/`の評価式として式言語を利用します。
（ 式言語の説明は[こちら](./el.md#式言語) )\
また、標準でSF関数(*S*tring *F*unction)を使うことができます。

```sql
select
  *
from
  employee  emp
where
/*IF SF.isNotEmpty(birthDateFrom) and SF.isNotEmpty(birthDateTo)*/
and  emp.birth_date  between  /*birthDateFrom*/'1990-01-01'  and  /*birthDateTo*/'1999-12-31'
/*ELIF SF.isNotEmpty(birthDateFrom)*/
and  emp.birth_date  >=    /*birthDateFrom*/'1990-01-01'
/*ELIF SF.isNotEmpty(birthDateTo)*/
and  emp.birth_date  <    /*birthDateTo*/'1999-12-31'
/*ELSE*/
/*END*/
```

上の例ではIFの評価式として`SF.isNotEmpty()`を使用してバインドパラメータが`null`または`""`でないことを評価しています。

::: tip 評価式に渡されるバインドパラメータの型
[バインド出来るパラメータの型](#バインド出来るパラメータの型) にもあるようにバインドパラメータには色々なJava型のオブジェクトを設定することができます。\
評価式の中ではバインドパラメータをオブジェクトとして扱うことができます。\
例えば、バインドパラメータ `now_date` に LocalDate型のオブジェクト `java.time.LocalDate.now()` をバインドした場合、評価式の中では\
`/*IF now_date != null and now_date.getMonth().getValue() == 3 */ -- 現在の月が3月だったら`\
のようなLocalDate型のインスタンスメソッドを呼び出した結果で評価を行うことが出来ます。\
上記の場合、式言語のプロパティアクセスを利用して\
`/*IF now_date != null and now_date.month.value == 3 */ -- 現在の月が3月だったら`\
という書き方も出来ます。
:::

バインドパラメータとして`birthDateFrom`に`2000-01-01`, `birthDateTo`に`2010-12-31`を指定した場合、生成されるSQLは以下のようになります。

```sql
select
  *
from
  employee  emp
where
  emp.birth_date  between  ?/*birthDateFrom*/  and  ?/*birthDateTo*/
```

最後にバインドパラメータが評価され、実行されるSQLが以下になります。

```sql
select
  *
from
  employee  emp
where
  emp.birth_date  between  '2000-01-01'/*birthDateFrom*/  and  '2010-12-31'/*birthDateTo*/
```

ここで`emp.birth_date`の前にあった`and`が消えていることに注目してください。
::: tip
**uroboroSQL**では動的SQLを生成する際、WHERE句の後ろに`and`や`or`が来る場合はそれを削除してSQL文として正しい状態にします
:::

ただし、上の加工前SQLのようにSQL文として不正な状態になってしまうのでSQLクライアントツールからは実行できないという欠点もあります。\
このようにSQL文として不正になることを防ぐために、WHERE句のあとに他に影響を与えない評価を入れる方法があります。

```sql
select
  *
from
  employee  emp
where
  1        =    1  // <-- 必ずtrueとなる評価を入れる
/*IF SF.isNotEmpty(birthDateFrom) and SF.isNotEmpty(birthDateTo)*/
and  emp.birth_date  between  /*birthDateFrom*/'1990-01-01'  and  /*birthDateTo*/'1999-12-31'
/*ELIF SF.isNotEmpty(birthDateFrom)*/
and  emp.birth_date  >=    /*birthDateFrom*/'1990-01-01'
/*ELIF SF.isNotEmpty(birthDateTo)*/
and  emp.birth_date  <    /*birthDateTo*/'1999-12-31'
/*ELSE*/
/*END*/
```

## 範囲の有効化 ( `/*BEGIN*/`, `/*END*/` )

`/*BEGIN*/`, `/*END*/` で囲まれた範囲は、その中の`/*IF*/`, `/*ELIF*/`のうち、どれか1つでも真(true)になった場合に出力されます。\
範囲内の全ての評価式が偽（false）の場合、`/*BEGIN*/`, `/*END*/` で囲まれた範囲は出力されません。

```sql
select
  *
from
  employee  emp
/*BEGIN*/
where
/*IF SF.isNotEmpty(firstName)*/
and  emp.first_name  =  /*firstName*/'Bob'
/*END*/
/*IF SF.isNotEmpty(lastName)*/
and  emp.last_name  =  /*lastName*/'Smith'
/*END*/
/*END*/
```

上の例で、バインドパラメータ `firstName`に`Willson`, `lastName`に`null`を指定した場合は以下のようになります。

```sql
select
  *
from
  employee  emp
where
  emp.first_name  =  ?/*firstName*/
```

バインドパラメータ `firstName`, `lastName`ともに`null`を指定した場合は以下のようになります。

```sql
select
  *
from
  employee  emp
```

`/*BEGIN*/`,`/*END*/`で囲まれた`where`が出力されていないことがわかります。

## SQL\_ID

発行するSQLに `/* _SQL_ID_ */` という記述があると、そのSQLを発行する際に `_SQL_ID_` の部分をSQL名やEntityを特定するための文字列に置換します。\
これにより、ログに出力されるSQLやDBに記録されるSQL発行結果を確認することで、どのSQLが発行されたのかを追跡しやすくなります。

* employee/select\_employee.sql

```sql
select /* _SQL_ID_ */
  emp.emp_no        as  emp_no
, emp.first_name    as  first_name
, emp.last_name     as  last_name
, emp.birth_date    as  birth_date
, emp.gender        as  gender
, emp.lock_version  as  lock_version
from
  employee  emp
（以下略）
```

というSQLがあるとき、実際に発行されたSQLは以下のようになります。

```sql
select /* employee/select_employee */  -- _SQL_ID_ が SQL名に置換されている
  emp.emp_no        as  emp_no
, emp.first_name    as  first_name
, emp.last_name     as  last_name
, emp.birth_date    as  birth_date
, emp.gender        as  gender
, emp.lock_version  as  lock_version
from
  employee  emp
（以下略）
```

::: tip `SQL_ID`の置換文字列指定
`SQL_ID` の置換文字列のデフォルト設定は`_SQL_ID_`ですが、これは SqlAgentProviderの設定で変更することができます。\
設定方法については [SQL\_IDの置換文字列設定](../configuration/sql-agent-provider.html#sql-id%E3%81%AE%E7%BD%AE%E6%8F%9B%E6%96%87%E5%AD%97%E5%88%97%E8%A8%AD%E5%AE%9A-sqlagentprovider-setsqlidkeyname) を参照してください。
:::

::: tip `SQL_ID`の記述場所
`SQL_ID` はSQL中のどこに記述しても問題ありません。\
ただし、ログやSQL発行結果で確認することが目的であるため、SQLの最初の予約語の後に記述することが慣例となっています。\
（文の先頭に記述した場合、DBの種類によっては不要なコメントとして除去されることがあるため、予約語の後ろに記述します）\
具体的には `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `WITH` の後ろに記述します。

```sql
with /* _SQL_ID_ */
    cte_name as (
      ...
    )
select
    *
from cte_name;
```

:::

エンティティクラスを指定したSQL発行では、エンティティクラス名がSQL名として使用されます。

## 不要なカンマの除去

IF分岐を使って動的なSQLを構築する場合、カンマの有無が問題になる場合があります。
以下のSQLを例として説明します。

```sql
select
/*IF detail*/
,  first_name
,  last_name
,  birth_date
,  gender
/*END*/
,  emp_no
from
  employee  emp
order by
/*IF detail*/
,  birth_date
/*END*/
,  emp_no
```

ここでバインドパラメータ`detail`に`true`を指定した場合、生成されるSQLは以下になります。

```sql
select
,  first_name
,  last_name
,  birth_date
,  gender
,  emp_no
from
  employee  emp
order by
,  birth_date
,  emp_no
```

このSQLでは`select`の直後や`order by`の直後にカンマが出現しておりSQL文として不正であるため、SQLの実行に失敗します。\
これを避けるため**uroboroSQL**では、生成後のSQLに含まれる不要なカンマを除去するようになっています。

実際に生成されるSQLは以下になります。

```sql
select
  first_name     -- 先頭のカンマが除去される
,  last_name
,  birth_date
,  gender
,  emp_no
from
  employee  emp
order by
  birth_date     -- 先頭のカンマが除去される
,  emp_no
```

カンマが除去されるのは、以下の予約語の直後にカンマが出現した場合です（大文字小文字の区別無し）。

* SELECT
* ORDER BY
* GROUP BY
* (
* SET

---

---
url: /uroborosql-doc/configuration/connection-supplier.md
---

# ConnectionSupplier

DB接続を行う際のコネクションを提供するクラスです。
標準で以下のクラスが提供されているので用途に応じて使い分けてください。

| クラス名                         | 説明                                                                     |
| :------------------------------- | :----------------------------------------------------------------------- |
| DefaultConnectionSupplierImpl    | コンストラクタで受け取ったコネクションを返すだけのコネクション供給クラス |
| JdbcConnectionSupplierImpl       | JDBCドライバーマネージャを使用したコネクション提供クラス                 |
| DataSourceConnectionSupplierImpl | データソースを使用したコネクション提供クラス                             |

また、[ConnectionSupplier](https://github.com/future-architect/uroborosql/blob/main/src/main/java/jp/co/future/uroborosql/connection/ConnectionSupplier.java)インタフェースを実装した独自のJDBCコネクション提供クラスを利用することもできます。

## ConnectionSupplierインタフェースの設定メソッド

ConnectionSupplierインタフェースには以下の設定用メソッドが定義されています。\
これらの設定メソッドを使用することで、ConnectionSupplierが提供するConnectionオブジェクトの挙動を変更することができます。

| メソッド名                                     | 説明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :--------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| setDefaultCacheSchema  | デフォルトのDB接続情報にスキーマ名のキャッシュオプションを指定します。true を指定した場合、getConnection() で取得するConnectionオブジェクトは最初にConnection#getSchema() で取得したスキーマ名をキャッシュします。2回目以降の呼び出しではキャッシュしたスキーマ名を返却することでConnection#getSchema() の中で呼び出されるDBアクセスを抑止することができます。ConnectionSupplierから返却されるConnectionインスタンスの具象型はMetadataCachedConnectionWrapperとなります。Postgresqlなど、Connection#getSchema() で毎回DBアクセスを行うJDBCドライバー実装で、スキーマの変更が頻繁に発生しない場合にこのオプションの指定を検討してください。 |
| setDefaultFixSchema    | デフォルトのDB接続情報にスキーマ名の固定オプションを指定します。true を指定した場合、getConnection() で取得するConnectionオブジェクトはスキーマ名が固定されます。スキーマ名を固定することでConnection#getSchema() の中ではDBアクセスが行われなくなりますが、制限としてConnection#setSchema()を使ったスキーマの変更ができなくなります。ConnectionSupplierから返却されるConnectionインスタンスの具象型はSchemaFixedConnectionWrapperとなります。スキーマ名の変更が不要な場合にこのオプションの指定を検討してください。                                                                                                                       |

## ConnectionContext&#x20;

動的に`SqlAgent`の接続先を切り替える場合は、`SqlConfig#agent(ConnectionContext)`メソッドを使用します。

`ConnectionContext`は、`ConnectionContextBuilder`の下記メソッドを利用して、インスタンスを生成します。

| 戻り値                      | メソッド名                                                    | 説明                                    |
| :-------------------------- | :------------------------------------------------------------ | :-------------------------------------- |
| DataSourceConnectionContext | dataSource()                                                  | DataSourceConnectionContext を生成する. |
| DataSourceConnectionContext | dataSource(String dataSourceName)                             | DataSourceConnectionContext を生成する. |
| JdbcConnectionContext       | jdbc(String url)                                              | JdbcConnectionContext を生成する.       |
| JdbcConnectionContext       | jdbc(String url, String user, String password)                | JdbcConnectionContext を生成する.       |
| JdbcConnectionContext       | jdbc(String url, String user, String password, String schema) | JdbcConnectionContext を生成する.       |

### 実装例

```java
SqlConfig config = UroboroSQL
    .builder()
    .setConnectionSupplier(new JdbcConnectionSupplier("jdbc:h2:mem:mainConnection", "sa", "sa"))
    .build();

try (SqlAgent agent = config.agent()) {
  // using jdbc:h2:mem:mainConnection
  agent.required(() -> {
    ....
  });
}

//-------------------------------------------------------

try (SqlAgent agent = config.agent(ConnectionContextBuilder
				.jdbc("jdbc:h2:mem:subConnection", "sa", "sa"))) {
  // usingjdbc:h2:mem:subConnection
  agent.required(() -> {
    ....
  });
}
```

---

---
url: /uroborosql-doc/basics/entity-api.md
---

# DAOインタフェース

**uroboroSQL**はDAO(Data Access Object)を用いた単一テーブルへのCRUDに対応しています。

下記のテーブルとそれに対応するエンティティクラスを例として説明します。

```sql
-- MySQLの場合
create table employee (
  emp_no number(6) not null auto_increment
  , first_name varchar(20) not null
  , last_name varchar(20) not null
  , birth_date date not null
  , gender char(1) not null
  , email varchar(100) null
  , lock_version number(10) not null
  , constraint employee_PKC primary key (emp_no)
)

-- Postgresqlの場合
create table employee (
  emp_no serial not null
  , first_name varchar(20) not null
  , last_name varchar(20) not null
  , birth_date date not null
  , gender char(1) not null
  , email varchar(100) null
  , lock_version number(10) not null
  , constraint employee_PKC primary key (emp_no)
) ;
```

```java
public class Employee {
  private long empNo;
  private String firstName;
  private String lastName;
  private LocalDate birthDate;
  private Gender gender;
  private Optional<String> email = Optional.empty();
  private long lockVersion = 0;

  // 中略 getter/setter
}
```

## エンティティクラスの検索

### キーを指定した１件取得(`SqlAgent#find`)

| メソッド名                               | 戻り値の型        |
| :--------------------------------------- | :---------------- |
| SqlAgent#find(Class\<E>, Object...) | Optional\<E> |

主キーを指定してエンティティを取得します。PKカラムの数と引数に指定するキーの数は合わせる必要があります。

```java
// emp_no = 1 のレコードをエンティティとして取得
Optional<Employee> employee = agent.find(Employee.class, 1);
```

### 条件指定検索(`SqlAgent#query`)&#x20;

| メソッド名                     | 戻り値の型              |
| :----------------------------- | :---------------------- |
| SqlAgent#query(Class\<E>) | SqlEntityQuery\<E> |

エンティティクラスを利用した検索を行うためのオブジェクト（`SqlEntityQuery`)を取得します。\
`SqlEntityQuery`に対して抽出条件の指定を行い、抽出条件に該当するエンティティを取得します。

***

### 抽出条件の指定(`SqlEntityQuery#equal` /`#notEqual` /`#greaterThan` /`#lessThan` /`#greaterEqual` /`#lessEqual` /`#in` /`#notIn` /`#like` /`#startsWith` /`#endsWith` /`#contains` /`#notLike` /`#notStartsWith` /`#notEndsWith` /`#notContains` /`#between` /`#notBetween` /`#betweenColumns` /`#notBetweenColumns` /`#isNull` /`#isNotNull` /`#where`)

| 抽出条件指定メソッド記述例                                                  | 生成されるwhere句の条件式                | 補足説明                                                       |
| :-------------------------------------------------------------------------- | :--------------------------------------- | :------------------------------------------------------------- |
| equal("col", "value")                                                       | col = 'value'                            |                                                                |
| notEqual("col", "value")                                                    | col != 'value'                           |                                                                |
| greaterThan("col", 1)                                                       | col > 1                                  |                                                                |
| lessThan("col", 1)                                                          | col < 1                                  |                                                                |
| greaterEqual("col", 1)                                                      | col >= 1                                 |                                                                |
| lessEqual("col", 1)                                                         | col <= 1                                 |                                                                |
| in("col", "val1", "val2")                                                   | col in ('val1', 'val2')                  |                                                                |
| in("col", List.of("val1", "val2"))                                          | col in ('val1', 'val2')                  |                                                                |
| notIn("col", "val1", "val2")                                                | col not in ('val1', 'val2')              |                                                                |
| notIn("col", List.of("val1", "val2"))                                       | col not in ('val1', 'val2')              |                                                                |
| like("col", "%val%")                                                        | like '%val%'                             | `val`はエスケープされない                                      |
| startsWith("col", "val")                                                    | like 'val%'                              | `val`はエスケープされる                                        |
| endsWith("col", "val")                                                      | like '%val'                              | `val`はエスケープされる                                        |
| contains("col", "val")                                                      | like '%val%'                             | `val`はエスケープされる                                        |
| notLike("col", "%val%")                                                     | not like '%val%'                         | `val`はエスケープされない                                      |
| notStartsWith("col", "val")                                                 | not like 'val%'                          | `val`はエスケープされる                                        |
| notEndsWith("col", "val")                                                   | not like '%val'                          | `val`はエスケープされる                                        |
| notContains("col", "val")                                                   | not like '%val%'                         | `val`はエスケープされる                                        |
| between("col", 1, 2)                                                        | col between 1 and 2                      |                                                                |
| notBetween("col", 1, 2)                              | col not between 1 and 2                  |                                                                |
| betweenColumns(2, "col1", "col2")                    | 2 between col1 and col2                  |                                                                |
| notBetweenColumns(2, "col1", "col2")                 | 2 not between col1 and col2              |                                                                |
| isNull("col")                                                               | col is null                              |                                                                |
| isNotNull("col")                                                            | col is not null                          |                                                                |
| where("col = 1 or col = 2")                                                 | (col = 1 or col = 2)                     | もし複数回`where()`が呼び出された場合は条件を `AND` で結合する |
| where("col = /\*col1\*/", "col1", 1)                                        | (col = 1/\*col1\*/)                      | パラメータの指定（1件）付き                                    |
| where("col = /\*col1\*/ or col = /\*col2\*/", Map.of("col1", 1, "col2", 2)) | (col = 1/\*col1\*/ or col = 2/\*col2\*/) | パラメータの指定（複数件）付き                                 |

```java
// emp_no = 1 のレコードをList<Employee>で取得
agent.query(Employee.class)
    .equal("empNo", 1)
    .collect();

// emp_no = 10 又は 20 のレコードをList<Employee>で取得
agent.query(Employee.class)
    .in("empNo", 10, 20)
    .collect();

// first_name like '%Bob%' のレコードをList<Employee>で取得
agent.query(Employee.class)
    .contains("firstName", "Bob")
    .collect();

// where句を直接記述(first_name = 'Bob' and last_name = 'Smith')した結果をList<Employee>で取得
agent.query(Employee.class)
    .where("first_name =''/*firstName*/", "firstName", "Bob")
    .where("last_name = ''/*lastName*/", "lastName", "Smith")
    .collect();
```

::: warning 注意
同じカラムに対して `where` 以外の抽出条件指定メソッドを複数指定した場合、最後に指定した抽出条件が有効になります。

```java
agent.query(Employee.class)
    .greaterThan("empNo", 20)
    .lessEqual("empNo", 10)
    .collect();
```

上記の場合、 `lessEqual` メソッドの指定が有効になり、以下のSQLが発行されます。\
（`greaterThan` メソッドの指定は無視されます）

```sql
select
  emp_no      as emp_no
, first_name  as first_name
, last_name   as last_name
...
from employee
where
  emp_no <= 10
```

:::

### ソート順(`SqlEntityQuery#asc` /`#desc`)や取得データの件数(`#limit`)、開始位置(`#offset`)、悲観ロック(`#forUpdate` /`#forUpdateNoWait` /`#forUpdateWait`)の指定&#x20;

`SqlEntityQuery`では抽出条件に加えて検索結果のソート順や取得件数の制限、開始位置の指定、明示的なロック指定が行えます。

| 条件指定メソッド記述例                                     | 生成されるSQL                  | 補足説明                                                                                            |
| :--------------------------------------------------------- | :----------------------------- | :-------------------------------------------------------------------------------------------------- |
| asc("col1", "col2")                                        | order by col1 asc, col2 asc    | `NULLS`が有効な場合は`NULLS LAST`が出力される                                                       |
| asc("col1", Nulls.FIRST)                                   | order by col1 asc NULLS FIRST  | 複数回`asc()`が呼び出された場合は呼び出し順に並べる                                                 |
| desc("col1", "col2")                                       | order by col1 desc, col2 desc  | `NULLS`が有効な場合は`NULLS LAST`が出力される                                                       |
| desc("col1", Nulls.FIRST)                                  | order by col1 desc NULLS FIRST | 複数回`asc()`が呼び出された場合は呼び出し順に並べる                                                 |
| limit(10)                                                  | LIMIT 10                       | 接続しているDBで`limit`句が使用できない場合は`UroborosqlRuntimeException`がスローされる             |
| offset(10)                                                 | OFFSET 10                      | 接続しているDBで`offset`句が使用できない場合は`UroborosqlRuntimeException`がスローされる            |
| forUpdate()       | FOR UPDATE                     | 接続しているDBで`FOR UPDATE`句が使用できない場合は`UroborosqlRuntimeException`がスローされる        |
| forUpdateNoWait() | FOR UPDATE NOWAIT              | 接続しているDBで`FOR UPDATE NOWAIT`句が使用できない場合は`UroborosqlRuntimeException`がスローされる |
| forUpdateWait()   | FOR UPDATE WAIT 10             | 接続しているDBで`FOR UPDATE WAIT`句が使用できない場合は`UroborosqlRuntimeException`がスローされる   |
| forUpdateWait(30) | FOR UPDATE WAIT 30             | 接続しているDBで`FOR UPDATE WAIT`句が使用できない場合は`UroborosqlRuntimeException`がスローされる   |

```java
// birth_dateの降順、first_nameの昇順でソートした結果を List<Employee>で取得
agent.query(Employee.class)
    .desc("birthDate")
    .asc("firstName")
    .collect();

// emp_no の昇順でソートした結果の3行目から5件取得
agent.query(Employee.class)
    .asc("empNo")
    .offset(3)
    .limit(5)
    .collect();

// 明示的な行ロックを行う
agent.query(Employee.class)
    .forUpdate()
    .collect();
```

### オプティマイザーヒントの指定(`SqlEntityQuery#hint`)&#x20;

`SqlEntityQuery#hint()`を使用することで、SQLに対してオプティマイザーヒントを指定することができます。

```java
SqlAgent agent = ...
agent.query(User.class)
    .hint("ORDERED")
    .lessThan("age", 30)
    .collect();
```

出力されるSQL(Oracleの場合)

```sql
select /*+ ORDERED */ id, name, age, ... from user where age < 30
```

::: warning 注意
オプティマイザーヒントの指定は、利用するDBがオプティマイザーヒントをサポートしている場合に有効になります。\
また、指定可能なヒント句は利用するDBに依存します。
:::

### 検索結果の取得(`SqlEntityQuery#collect` /`#first` /`#one` /`#select` /`#stream`)

`SqlEntityQuery`から抽出条件に該当するエンティティを取得します。

| メソッド                                                                        | 説明                                                                                    |
| :------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------- |
| collect()                                                                       | 検索結果をエンティティのリストとして取得する                                            |
| first()                                                                         | 検索結果の先頭行を取得する                                                              |
| one()                                                                           | 検索結果の先頭行を取得する。検索結果が2件以上の場合`DataNonUniqueException`をスローする |
| Stream\<C> select(String col, Class\<C> type)  | 検索結果の指定したカラムの値を`java.util.stream.Stream`として取得する。                 |
| stream()                                                                        | 検索結果を`java.util.stream.Stream`として取得する                                       |

```java
// List<Employee>で取得
List<Employee> employees = agent.query(Employee.class)
    .collect();

// 検索結果の先頭行を取得
Optional<Employee> employee = agent.query(Employee.class)
    .first();

// 検索結果（カラム値）の取得
String employeeName = agent.query(Employee.class)
    .equal("employeeId", 1)
    .select("employeeName", String.class)
    .findFirst()
    .orElseThrow();
```

### 取得するカラム/除外するカラムの指定(`#includeColumns` / `#excludeColumns`)&#x20;

[検索結果の取得](#検索結果の取得-sqlentityquery-collect-first-one-select-stream) を呼び出す前に検索結果に含めるカラムを指定することで
利用しないカラムに対する不要なアクセスを減らすことができます。

| メソッド                       | 説明                                                 |
| :----------------------------- | :--------------------------------------------------- |
| includeColumns(String... cols) | 検索結果に含めるカラム名を指定する（複数指定可）     |
| excludeColumns(String... cols) | 検索結果から除外するカラム名を指定する（複数指定可） |

```java
// List<Employee>を取得 (取得したEmployeeインスタンスにはemployeeIdのみ設定されている)
List<Employee> employees = agent.query(Employee.class)
                              .includeColumns("employeeId")
                              .collect();

// List<Employee>を取得 (取得したEmployeeインスタンスにはemployeeName以外が設定されている)
List<Employee> employees = agent.query(Employee.class)
                              .excludeColumns("employeeName")
                              .collect();
```

### 集約関数(`SqlEntityQuery#count` /`#sum` /`#sum` /`#min` /`#max` /`#exists` /`#notExists`)&#x20;

`SqlEntityQuery`ではエンティティを取得する他に結果の集計を行うこともできます。

| メソッド                     | 説明                                                               |
| :--------------------------- | :----------------------------------------------------------------- |
| count()                      | 検索結果の件数を取得する                                           |
| count(String col)            | 検索結果のうち、引数で指定したカラムがNULLでない行の件数を取得する |
| sum(String col)              | 検索結果のうち、引数で指定したカラムの合計値を取得する             |
| min(String col)              | 検索結果のうち、引数で指定したカラムの最小値を取得する             |
| max(String col)              | 検索結果のうち、引数で指定したカラムの最大値を取得する             |
| exists(Runnable runnable)    | 検索結果が1件以上ある場合に引数で渡した関数を実行する              |
| notExists(Runnable runnable) | 検索結果が0件の場合に引数で渡した関数を実行する                    |

```java
// 検索結果の件数を取得
long count = agent.query(Employee.class)
    .count();

// 検索結果が1件以上の場合にログを出力する
agent.query(Employee.class)
    .greaterThan("empNo", 10)
    .exists(() -> {
      log.info("Employee(emp_no > 10) exists.");
    });
```

::: tip
集約関数を使用すると、検索結果からEntityオブジェクトを生成しないためメモリ効率が良くなります。
以下２つの処理結果は同じですが、countメソッドのほうがEmployeeインスタンスを生成しない分メモリ効率が良いです。

```java
// collect()を使用すると、検索結果がエンティティに変換されるためメモリを使用する
long count = agent.query(Employee.class)
    .collect().size();

// count()を使用すると件数のみ取得できる（エンティティは生成されない）
long count = agent.query(Employee.class)
    .count();
```

:::

## エンティティの挿入

### 1件の挿入(`SqlAgent#insert`/`#insertAndReturn`)

| メソッド名                                                    | 戻り値の型 |
| :------------------------------------------------------------ | :--------- |
| \<E> SqlAgent#insert(E)                                  | int        |
| \<E> SqlAgent#insertAndReturn(E)  | E          |

エンティティクラスのインスタンスを使って１レコードの挿入を行います。

* [@Id](#id-generatedvalue-sequencegenerator)アノテーションの指定があるフィールド
* 対するカラムが自動採番となっているフィールド

上記の型がprimitive型の場合、もしくはフィールドの値が`null`の場合、カラムの値は挿入時に自動採番されます。\
また、挿入により採番された値がエンティティの該当フィールドにも設定されます。\
フィールドに値を指定した場合は自動採番カラムであっても指定した値が挿入されます。

デフォルト値の指定があるカラムに対するフィールドが `null` の場合、カラムの値にデフォルト値が設定されます。

NULL可であるカラムに対するフィールドの値が `null` の場合、そのカラムに値は設定されず、結果として `NULL` になるか、またはデフォルト値が設定されます。\
NULL可であるカラムに対するフィールドの型が `Optional`型の場合、`Optional.empty()` が設定されていればそのカラムには `NULL` が設定されます。`Optional.empty()` 以外の値が設定されていれば、Optionalが内包する値が設定されます。

`AndReturn`が付くメソッドでは、挿入したエンティティオブジェクトを戻り値として取得できるため、
エンティティの挿入に続けて処理を行う場合に便利です。

```java
Employee employee = new Employee();
employee.setFirstName("Susan");
employee.setLastName("Davis");
employee.setBirthDate(LocalDate.of(1969, 2, 10));
employee.setEmail(Optional.of("susan.davis@sample.com")); // email カラムには susan.davis@sample.com が設定される
employee.setGender(Gender.FEMALE); // MALE("M"), FEMALE("F"), OTHER("O")

// 1件の挿入
agent.insert(employee);
System.out.println(employee.getEmpNo()); // 自動採番された値が出力される
```

### 複数件の挿入(`SqlAgent#inserts` /`#insertsAndReturn`)&#x20;

| メソッド名                                                                                                                   | 戻り値の型      |
| :--------------------------------------------------------------------------------------------------------------------------- | :-------------- |
| SqlAgent#inserts(Stream\<E>)                                                                                            | int             |
| SqlAgent#inserts(Stream\<E>, InsertsType)                                                                               | int             |
| SqlAgent#inserts(Stream\<E>, InsertsCondition\<? super E>)                                                               | int             |
| SqlAgent#inserts(Stream\<E>, InsertsCondition\<? super E>, InsertsType)                                                  | int             |
| SqlAgent#insertsAndReturn(Stream\<E>)                                                            | Stream\<E> |
| SqlAgent#insertsAndReturn(Stream\<E>, InsertsType)                                               | Stream\<E> |
| SqlAgent#insertsAndReturn(Stream\<E>, InsertsCondition\<? super E>)                               | Stream\<E> |
| SqlAgent#insertsAndReturn(Stream\<E>, InsertsCondition\<? super E>, InsertsType)                  | Stream\<E> |
| SqlAgent#inserts(Class\<E>, Stream\<E>)                                                                            | int             |
| SqlAgent#inserts(Class\<E>, Stream\<E>, InsertsType)                                                               | int             |
| SqlAgent#inserts(Class\<E>, Stream\<E>, InsertsCondition\<? super E>)                                               | int             |
| SqlAgent#inserts(Class\<E>, Stream\<E>, InsertsCondition\<? super E>, InsertsType)                                  | int             |
| SqlAgent#insertsAndReturn(Class\<E>, Stream\<E>)                                            | Stream\<E> |
| SqlAgent#insertsAndReturn(Class\<E>, Stream\<E>, InsertsType)                               | Stream\<E> |
| SqlAgent#insertsAndReturn(Class\<E>, Stream\<E>, InsertsCondition\<? super E>)               | Stream\<E> |
| SqlAgent#insertsAndReturn(Class\<E>, Stream\<E>, InsertsCondition\<? super E>, InsertsType)  | Stream\<E> |

`java.util.stream.Stream`経由で渡される複数のエンティティインスタンスを挿入します。

* [@Id](#id-generatedvalue-sequencegenerator)アノテーションの指定があるフィールド
* 対するカラムが自動採番となっているフィールド

の型がprimitive型の場合、もしくはフィールドの値が`null`の場合、カラムの値は挿入時に自動採番されます。\
また、挿入により採番された値がエンティティの該当フィールドにも設定されます。\
フィールドに値を指定した場合は自動採番カラムであっても指定した値が挿入されます。

::: warning 注意
複数件の挿入で生成されるSQLでは、行毎のフィールドの値の有無を変更することができません。\
最初に挿入するエンティティで`@Id`の指定があるフィールドや自動採番カラムに対するフィールドに値を設定する場合は、
2件目以降のエンティティにも必ず値を設定するようにしてください。\
また、最初に挿入するエンティティで`@Id`の指定があるフィールドや自動採番カラムに対するフィールドの値に`null`を設定する場合は、
2件目以降のエンティティで値を設定していても無視されて自動採番されます。\
:::

`AndReturn`が付くメソッドでは、挿入したエンティティオブジェクトの`java.util.stream.Stream`を戻り値として取得できるため、
エンティティの挿入に続けて処理を行う場合に便利です。

::: warning 注意
`AndReturn`の戻り値となる`Stream<E>`を生成する際、挿入したエンティティを全件メモリ上に保持します。
大量データの挿入を行うとOOMEが発生する場合があるので、`insertsAndReturn`を使用する場合は挿入する
データの件数に気をつけてください。件数が多い場合は一度`inserts`で挿入した後に、再度検索するといった方法を検討してください。
:::

::: danger 制限事項&#x20;
2025/11 現在、SQLServerのJDBCドライバーではバッチインサート時の自動生成列（IDENTITY列）の結果取得に対応していない（[issue](https://github.com/microsoft/mssql-jdbc/issues/245)）ため、SQLServerに対して `insertsAndReturn` を行った場合、戻り値のStreamに含まれるエンティティには自動採番列（IDENTITY列）の値が設定されません。
:::

```java
// 1件の挿入
Department dept = new Department();
dept.setDeptName("sales");
agent.insert(dept);

// 複数件の挿入(EmployeeとDeptEmpの挿入)
agent.inserts(agent.insertsAndReturn(agent.query(Employee.class).stream())
  .map(e -> {
    DepEmp deptEmp = new DeptEmp();
    deptEmp.setEmpNo(e.getEmpNo());
    deptEmp.setDepNo(dept.getDepNo());
    return deptEmp;
  })
);
```

### 挿入方法（InsertsType）の指定

`InsertsType`を指定することで実行される挿入用のSQLを変更することが出来ます。

| InsertsType | 説明                                                                                                                                                                                                                   |
| :---------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| BATCH       | `java.sql.PreparedStatement#executeBatch()`を使用したバッチSQL実行                                                                                                                                                     |
| BULK        | `insert into ... values ( ... ), ( ... )`という風にvaluesに複数行の値を出力し一度に複数レコードを挿入する。DBがこの記法をサポートしている場合に指定可能。DBが未サポートの場合、指定しても`BATCH`として実行される。 |

```java
Stream<Employee> employees = agent.query(Employee.class)
  .stream()
  .map(e -> e.setEmpNo(e.getEmpNo() + 1000));

// 複数件の挿入(バッチ実行)
agent.inserts(employees, InsertsType.BATCH);
}
```

::: tip
`InsertsType`は、[初期値設定](../configuration/sql-agent-provider.md#複数件挿入時の挿入方法の初期値設定)が可能です。\
:::

::: warning BATCH と BULK の選択について
一般的に少ないレコード数を挿入する場合は `BULK` を指定する方が早くなります。（DBの種類やJDBCドライバーの実装、割り当てられたメモリにより差異はあります）\
これは、 `BULK` の動作が以下のように2段階の動作であるのに対し、

1. SQLをpreparedStatementに変換
2. SQL発行

`BATCH` の動作が以下のような動作になっているためです。

1. SQLをpreparedStatementに変換
2. [挿入条件](#挿入条件-insertscondition-の指定)で指定した条件になるまで蓄積したデータをDBに送信
3. SQL発行
4. 挿入するデータが無くなるまで2～3の繰り返し

しかし`BULK` で発行するSQLは挿入する件数に比例して肥大化し、それに伴い 1. の preparedStatement への変換に時間がかかるようになります。\
それに比べて `BATCH` では挿入する件数が増えても `BULK` に比べて処理時間の増加が緩やかなので、挿入する件数が増えると `BATCH` のほうが高速になります。\
`BULK` を指定する場合は実際に挿入にかかる時間を計測し、`BATCH` より早いことを確認してください。

:::

### 挿入条件（InsertsCondition）の指定

挿入用SQLの実行条件を指定します。\
`InsertsCondition<E>#test(ExecutionContext ctx, int count, E entity)`の戻り値が`true`の場合に挿入用SQLを実行します。\
`InsertsCondition`はFunctionalInterfaceのためlambda式が利用できます。

```java
Stream<Employee> employees = agent.query(Employee.class)
  .stream()
  .map(e -> e.setEmpNo(e.getEmpNo() + 1000));

// 複数件の挿入（10件毎に挿入）
agent.inserts(employees, (ctx, count, entity) -> count == 10);
```

## エンティティの更新

### 1件の更新(`SqlAgent#update` /`#updateAndReturn`)

| メソッド名                                                    | 戻り値の型 |
| :------------------------------------------------------------ | :--------- |
| \<E> SqlAgent#update(E)                                  | int        |
| \<E> SqlAgent#updateAndReturn(E)  | E          |

エンティティクラスのインスタンスを使って１レコードの更新を行います。

レコード更新時、[@Version](#version)アノテーションの指定があるフィールドに対するカラムはカウントアップされます。\
また、更新された値がエンティティの該当フィールドにも設定されます。

NULL可であるカラムに対するフィールドの値が `null` の場合、そのカラムは **更新されません**。\
NULL可であるカラムに対するフィールドの型が `Optional`型の場合、`Optional.empty()` が設定されていればそのカラムは `NULL` で更新されます。
`Optional.empty()` 以外の値が設定されていれば、Optionalが内包する値で更新されます。

::: warning 補足
エンティティクラスのインスタンスを使った１レコードの更新では、`@Id`を指定したフィールドに対するカラムや自動採番カラムは更新できません。\
`@Id`を指定したフィールドに対するカラムや自動採番カラムを更新する場合は、後述する[条件指定による複数件の更新](#条件指定による複数件の更新-sqlagent-update)を使用してください。
:::

`AndReturn`が付くメソッドでは、更新したエンティティオブジェクトを戻り値として取得できるため、
エンティティの更新に続けて処理を行う場合に便利です。

```java
agent.find(Employee.class, 1).ifPresent(employee -> {
  employee.setLastName("Wilson");
  employee.setEmail(Optional.empty()); // email を null に更新
  System.out.println(employee.getLockVersion()); // 1

  // エンティティの更新
  agent.update(employee);
  System.out.println(employee.getLockVersion()); // 2
});
```

### 条件指定による複数件の更新(`SqlAgent#update`)&#x20;

| メソッド名                          | 戻り値の型               |
| :---------------------------------- | :----------------------- |
| SqlAgent#update(Class\<? extends E>) | SqlEntityUpdate\<E> |

更新対象のレコードを抽出する条件を指定して更新を行います。\
抽出条件の指定方法は [抽出条件の指定](#抽出条件の指定) を参照してください。\
また、`set()`メソッドで更新対象のフィールドと値を指定することができます。

```java
// first_name に 'Bob' を含むエンティティの性別を更新
agent.update(Employee.class)
  .contains("firstName", "Bob")
  .set("gender", Gender.MALE)
  .count();
```

### 複数件の更新(`SqlAgent#updates` /`#updatesAndReturn`)&#x20;

| メソッド名                                                                              | 戻り値の型      |
| :-------------------------------------------------------------------------------------- | :-------------- |
| SqlAgent#updates(Stream\<E>)                                                       | int             |
| SqlAgent#updates(Stream\<E>, UpdatesCondition\<? super E>)                          | int             |
| SqlAgent#updatesAndReturn(Stream\<E>)                                              | Stream\<E> |
| SqlAgent#updatesAndReturn(Stream\<E>, UpdatesCondition\<? super E>)                 | Stream\<E> |
| SqlAgent#updates(Class\<E>, Stream\<E>)                                       | int             |
| SqlAgent#updates(Class\<E>, Stream\<E>, UpdatesCondition\<? super E>)          | int             |
| SqlAgent#updatesAndReturn(Class\<E>, Stream\<E>)                              | Stream\<E> |
| SqlAgent#updatesAndReturn(Class\<E>, Stream\<E>, UpdatesCondition\<? super E>) | Stream\<E> |

`java.util.stream.Stream`経由で渡される複数のエンティティインスタンスを使って更新します。

::: tip
`inserts`と違い必ずバッチSQL実行になります。
:::

レコード更新時、[@Version](#version)アノテーションの指定があるフィールドに対するカラムはカウントアップされます。\
また、更新された値がエンティティの該当フィールドにも設定されます。

`AndReturn`が付くメソッドでは、更新したエンティティオブジェクトの`java.util.stream.Stream`を戻り値として取得できるため、
エンティティの更新に続けて処理を行う場合に便利です。

::: warning
`AndReturn`の戻り値となる`Stream<E>`を生成する際、更新したエンティティを全件メモリ上に保持します。
大量データの更新を行うとOOMEが発生する場合があるので、`updatesAndReturn`を使用する場合は更新する
データの件数に気をつけてください。件数が多い場合は一度`updates`で更新した後に、再度検索するといった方法を検討してください。
:::

```java
// 複数件の更新
agent.updates(agent.query(Employee.class)
  .stream()
  .map(e -> {
    e.setFirstName(e.getFirstName() + "_new");
    return e;
  })
);
```

### 更新条件（UpdatesCondition）の指定

更新用SQLの実行条件を指定します。\
`UpdatesCondition<E>#test(ExecutionContext ctx, int count, E entity)`の戻り値が`true`の場合に更新用SQLを実行します。\
`UpdatesCondition`はFunctionalInterfaceのためlambda式が利用できます。

```java
Stream<Employee> employees = agent.query(Employee.class)
  .stream()
  .map(e -> {
    e.setFirstName(e.getFirstName() + "_new");
    return e;
  });

// 複数件の更新（10件毎に挿入）
agent.updates(employees, (ctx, count, entity) -> count == 10);
```

## エンティティのマージ&#x20;

### 1件のマージ(`SqlAgent#merge` /`#mergeAndReturn`)

| メソッド名                                      | 戻り値の型 |
| :---------------------------------------------- | :--------- |
| \<E> SqlAgent#merge(E)                     | int        |
| \<E> SqlAgent#mergeAndReturn(E)            | E          |
| \<E> SqlAgent#mergeWithLocking(E)          | int        |
| \<E> SqlAgent#mergeWithLockingAndReturn(E) | E          |

エンティティクラスのインスタンスを使ってPKによるレコードの検索を行い、レコードがある場合は更新を行います。\
レコードがない場合、もしくは引数で指定したインスタンスのPKに該当するフィールドに値の指定が無い場合は挿入を行います。\
（これは通常、`UPSERT` や `MERGE` と呼ばれる動作です）

`AndReturn` が付くメソッドでは、更新、または挿入したエンティティオブジェクトを戻り値として取得できるため、 エンティティの更新や挿入に続けて処理を行う場合に便利です。

`WithLocking` が付くメソッドでは、PKによるレコードの検索時、レコードの悲観ロックも合わせて行います。

::: warning
接続しているDBが `SELECT FOR UPDATE` もしくは `SELECT FOR UPDATE NOWAIT` をサポートしていない場合、`WithLocking` が付くメソッドを呼び出すと `UroborosqlRuntimeException` がスローされます。
:::

#### mergeメソッドを使用しない場合

```java
agent.find(Employee.class, 1)
    .ifPresentOrElse(employee -> {
      employee.setLastName("Wilson");

      // エンティティの更新
      agent.update(employee);
}, () -> {
  Employee employee = new Employee();
  employee.setFirstName("Susan");
  employee.setLastName("Wilson");
  employee.setBirthDate(LocalDate.of(1969, 2, 10));
  employee.setGender(Gender.FEMALE); // MALE("M"), FEMALE("F"), OTHER("O")

  // エンティティの挿入
  agent.insert(employee);
});
```

#### mergeメソッドを利用する場合（更新）

```java
Employee employee = ...;  // find or create instance.
// employee.setId(1); // id(PK) is 1
employee.setLastName("Wilson");
agent.merge(employee);
```

#### mergeメソッドを利用する場合（挿入）

```java
Employee employee = new Employee();
employee.setFirstName("Susan");
employee.setLastName("Wilson");
employee.setBirthDate(LocalDate.of(1969, 2, 10));
employee.setGender(Gender.FEMALE); // MALE("M"), FEMALE("F"), OTHER("O")
agent.merge(employee);
```

## エンティティの削除

### 1件の削除(`SqlAgent#delete` /`#deleteAndReturn`)

| メソッド名                                                    | 戻り値の型 |
| :------------------------------------------------------------ | :--------- |
| \<E> SqlAgent#delete(E)                                  | int        |
| \<E> SqlAgent#deleteAndReturn(E)  | E          |

エンティティクラスのインスタンスを使って１レコードの削除を行います。

`AndReturn`が付くメソッドでは、削除したエンティティオブジェクトを戻り値として取得できるため、
エンティティの削除に続けて処理を行う場合に便利です。

```java
agent.find(Employee.class, 1).ifPresent(employee -> {
  // エンティティの削除
  agent.delete(employee);
});
```

### PKを指定した複数件の削除(`SqlAgent#delete`)&#x20;

| メソッド名                                     | 戻り値の型 |
| :--------------------------------------------- | :--------- |
| SqlAgent#delete(Class\<? extends E>, Object...) | int        |

```java
// PK(emp_no) = 1 or 2 のエンティティの削除
agent.delete(Employee.class, 1, 2);
```

### 条件指定による複数件の削除(`SqlAgent#delete`)&#x20;

| メソッド名                          | 戻り値の型               |
| :---------------------------------- | :----------------------- |
| SqlAgent#delete(Class\<? extends E>) | SqlEntityDelete\<E> |

削除対象のレコードを抽出する条件を指定して削除を行います。\
抽出条件の指定方法は [抽出条件の指定](#抽出条件の指定) を参照してください。

```java
// first_name = 'Bob' に該当するエンティティの削除
agent.delete(Employee.class).contains("firstName", "Bob").count();
```

### 全ての行を削除（`SqlAgent#truncate`）&#x20;

| メソッド名                            | 戻り値の型 |
| :------------------------------------ | :--------- |
| SqlAgent#truncate(Class\<? extends E>) | SqlAgent   |

エンティティクラスとマッピングされているテーブルの全てのレコードを`TRUNCATE`文により削除します。
一般的に大量レコードの削除は、`TRUNCATE`文による削除のほうが性能上有利ですが、DBMSによってはロールバックできませんので、注意してください。

:::tip
PostgreSQLは、`TRUNCATE`文のロールバック可能です。
:::

`SqlAgent#truncate`は、`SqlAgent`を戻り値として返すため、`SqlAgent#truncate`に続けて、`SqlAgent#inserts`をつなげることにより、
テーブルの洗い替えを実装することが可能です。

```java
// 全てのレコードを削除
agent.truncate(Employee.class);

// テーブルの洗い替え
agent.truncate(Employee.class)
     .inserts(employees.stream());
```

:::tip DAOインタフェースで生成されるSQL
DAOインタフェースを使ってテーブルにアクセスする場合、生成されるSQLは以下のようにスキーマ名で修飾したテーブル名が出力されます。

```java
agent.find(Employee.class, 1);
```

出力されるSQL

```sql
SELECT
  emp_no        AS emp_no
, first_name    AS first_name
, last_name     AS last_name
, birth_date    AS birth_date
, gender        AS gender
, email         AS email
, lock_version  AS lock_version
FROM PUBLIC.employee  -- 接続しているスキーマが PUBLIC の場合
WHERE emp_no = /*empNo*/1
```

postgresqlで複数のスキーマにまたがるテーブル群にアクセスする為に`search_path`オプションでスキーマを複数指定するようなケースでは、修飾されたスキーマ名が期待するスキーマと一致せずテーブルにアクセスできない場合があります。\
このようなケースでは、システムプロパティ `uroborosql.use.qualified.table.name` を指定することで出力されるSQLからスキーマ名を除くことができます。

```java
// uroborosql.use.qualified.table.name システムプロパティに false を指定
System.setProperty("uroborosql.use.qualified.table.name", "false");
SqlConfig config = UroboroSQL.builder("jdbc:h2:mem:uroborosql", "sa", "").build();
try (SqlAgent agent = config.agent()) {
  agent.find(Employee.class, 1);
}
```

出力されるSQL

```sql
SELECT
  emp_no        AS emp_no
, first_name    AS first_name
, last_name     AS last_name
, birth_date    AS birth_date
, gender        AS gender
, email         AS email
, lock_version  AS lock_version
FROM employee  -- テーブル名のみの出力となる
WHERE emp_no = /*empNo*/1
```

uroborosql で指定できるシステムプロパティについては [システムプロパティ](../advanced/#システムプロパティ) を参照してください
:::

## リトライ(`SqlFluent#retry`)

SQLを実行した際、タイミングによって発生する例外（テーブルロックエラーなど）の場合はリトライを行い、できるだけ正常に処理を終了させたい場合があります。\
uroboroSQLでは、`retry` メソッドにより簡潔で確実なリトライ処理が行えるよう工夫されています。

```java
try (SqlAgent agent = config.agent()) {
  // リトライ対象エラーコードの場合、5回のリトライを20ms間隔で行う
  agent.query(Employee.class)
    .equal("empNo", 1)
    .retry(5, 20)
    .collect();
}
```

## Entityアノテーション

DAOインタフェースで利用するエンティティクラスではテーブルとのマッピングやカラムの属性を指定するためにアノテーションを利用することができます。

### `@Table`

エンティティクラスに紐づけるテーブル名を指定します。\
テーブル名と名前が一致しないエンティティクラスにマッピングしたい場合に利用します。

| 属性名 | 型     | 必須 | 説明                                                                                             | 初期値 |
| :----- | :----- | :--: | :----------------------------------------------------------------------------------------------- | :----- |
| name   | String |  -   | マッピングするテーブル名。指定しない場合はクラス名をスネークケースにしたテーブルとマッピングする | なし   |
| schema | String |  -   | マッピングするテーブルの所属するスキーマ名                                                       | なし   |

```java
import jp.co.future.uroborosql.mapping.annotations.Table;

// name指定なし (departmentテーブルにマッピング)
@Table
public class Department {
  // 以下略
}

// name指定あり
@Table(name = "employee")
public class CustomEmployee {
  // 以下略
}
```

### `@Column`

フィールドに紐づけるカラム名を指定します。\
カラム名と名前が一致しないフィールドにマッピングしたい場合に利用します。

| 属性名 | 型     | 必須 | 説明                   | 初期値 |
| :----- | :----- | :--: | :--------------------- | :----- |
| name   | String |  〇  | マッピングするカラム名 | なし   |

```java
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Column;

@Table(name = "employee")
public class Employee {
  @Column(name = "emp_no")
  private long employeeNo;

  private String firstName;

  // 以下略
}
```

### `@Domain`

独自に作成した型(ドメインクラス)やEnumのフィールドにカラムをマッピングする場合に指定します。

| 属性名        | 型       | 必須 | 説明                                                                                                   | 初期値     |
| :------------ | :------- | :--: | :----------------------------------------------------------------------------------------------------- | :--------- |
| valueType     | Class\<?> |  〇  | ドメインクラスを生成するのに必要な値の型                                                               | なし       |
| factoryMethod | String   |  -   | ドメインクラスを生成・取得するメソッド名。指定しない場合は値を引数としたコンストラクタが呼び出される。 | ""         |
| toJdbcMethod  | String   |  -   | JDBCが受け付けられる値に変換するメソッド名                                                             | "getValue" |
| nullable      | boolean  |  -   | null可かどうかの指定                                                                                   | false      |

例

```java
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Domain;

@Domain(valueType = String.class, factoryMethod = "of", toJdbcMethod = "getName", nullable = true)
public static class NameDomain {
  private String name;

  private NameDomain(String name) {
    this.name = name;
  }

  public static NameDomain of(String name) {
    return new NameDomain(name);
  }

  public String getName() {
    return name;
  }
}

@Table
public class Employee {
  private long empNo;
  private NameDomain firstName;

  // 以下略
}
```

### `@Transient`

フィールドとカラムのマッピング対象から除外します。

:::tip
例えば、エンタープライズシステムの設計でしばしば利用される最終登録日時や最終更新日時など、
INSERT/UPDATEの対象から除外したいケースで利用します。
:::

| 属性名 | 型      | 必須 | 説明                                                                           | 初期値 |
| :----- | :------ | :--: | :----------------------------------------------------------------------------- | :----- |
| insert | boolean |  -   | `agent#insert()`実行時にフィールドを無視するかどうか。`true`の場合は無視する。 | true   |
| update | boolean |  -   | `agent#update()`実行時にフィールドを無視するかどうか。`true`の場合は無視する。 | true   |

例

```java
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Transient;

@Table
public class Employee {

  // 途中略

  @Transient
  private String memo; // 常に無視

  @Transient(insert = false, update = true)
  private LocalDate creationDate; // insert時は対象、update時は無視

  @Transient(insert = true, update = false)
  private LocalDate updateDate;  // insert時は無視、update時は対象

  // 以下略
}
```

### `@Version`

このアノテーションが付与されたフィールドは楽観ロック用のバージョン情報を保持するフィールドになります。\
デフォルト(`LockVersionOptimisticLockSupplier`)ではUPDATE時にはSET句で+1され、WHERE句の検索条件に追加されてSQLを実行し更新件数が0の場合には`OptimisticLockException`をスローします。

::: warning
`@Version`を付与するフィールドにマッピングされるDBカラムの型は数値型でなければなりません。
:::

| 属性名                          | 型                     | 必須 | 説明                 | 初期値                            |
| :------------------------------ | :--------------------- | :--: | :------------------- | :-------------------------------- |
| supplier | OptimisticLockSupplier |  -   | バージョン情報カラム | LockVersionOptimisticLockSupplier |

#### サプライヤの種類

| サプライヤ型                            | 概要                       | 説明                                                                                          |
| --------------------------------------- | -------------------------- | --------------------------------------------------------------------------------------------- |
| LockVersionOptimisticLockSupplier       | ロックバージョン           | UPDATEのSET句で`+1`がセットされます。                                                         |
| CyclicLockVersionOptimisticLockSupplier | 循環式ロックバージョン     | UPDATEのSET句で`バージョン情報カラム名 % 数値カラムの最大値 + 1`がセットされます。            |
| TimestampOptimisticLockSupplier         | タイムスタンプ             | UPDATEのSET句でタイムスタンプ(`System.currentTimeMillis()`)がセットされます。                 |
| FieldIncrementOptimisticLockSupplier    | フィールド値インクリメント | UPDATEのSET句で2WaySQLのバインド変数を利用して、`バージョン情報カラム名＋1`がセットされます。 |

例

```java
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Version;
import jp.co.future.uroborosql.mapping.TimestampOptimisticLockSupplier;

@Table
public class Employee {
  private long empNo;
  private String firstName;
  private String lastName;

　　// 途中略

  @Version(supplier = TimestampOptimisticLockSupplier.class)
  private long lockVersion = 0;

  // 以下略
}
```

#### カスタムサプライヤの追加

独自のバージョン管理ロジックが必要な場合は、`OptimisticLockSupplier`インターフェースを実装したカスタムサプライヤを作成して利用することができます。

カスタムサプライヤを作成するには以下の手順を実施します。

1. `jp.co.future.uroborosql.mapping.OptimisticLockSupplier`クラスを継承したクラスを作成
2. ServiceLoader用の設定ファイル `META-INF/services/jp.co.future.uroborosql.mapping.OptimisticLockSupplier` を作成し、実装クラスの完全修飾名を記述
3. エンティティクラスの`@Version`アノテーションのsupplier属性に作成したカスタムサプライヤを指定

#### 実装例（UUIDを使用した楽観ロックのサプライヤ）

1. `UuidOptimisticLockSupplier`クラスを作成

```java
package com.example.custom;

import java.util.UUID;
import jp.co.future.uroborosql.mapping.OptimisticLockSupplier;
import jp.co.future.uroborosql.mapping.TableMetadata;

/**
 * カスタム楽観ロックサプライヤ（UUIDベース）
 */
public class UuidOptimisticLockSupplier extends OptimisticLockSupplier {

  @Override
	public String getPart(TableMetadata.Column versionColumn, SqlConfig sqlConfig) {
    // バージョンカラムの設定を行うためのSQLパーツを作成して返却する
    // UUID文字列を生成して設定
		return versionColumn.getColumnIdentifier() + " = '" + UUID.randomUUID().toString() + "'";
	}
}
```

2. ServiceLoader用設定ファイル `src/main/resources/META-INF/services/jp.co.future.uroborosql.mapping.OptimisticLockSupplier` の作成

```
com.example.custom.UuidOptimisticLockSupplier
```

3. エンティティクラスでの使用例

```java
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Version;
import com.example.custom.UuidOptimisticLockSupplier;

@Table
public class Employee {
  private long empNo;
  private String firstName;
  private String lastName;

  // カスタムサプライヤを使用したバージョン管理
  @Version(supplier = UuidOptimisticLockSupplier.class)
  private String lockUuid;

  // 以下略
}
```

この実装により、UPDATE実行時には以下のようなSQLが生成されます:

```sql
UPDATE employee
SET
  first_name = /*firstName*/'John',
  last_name = /*lastName*/'Doe',
  lock_uuid = 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'  -- UUIDが自動生成される
WHERE
  emp_no = /*empNo*/1
  AND lock_uuid = /*lockUuid*/'previous-uuid-value'  -- 前回のUUID値で検証
```

### `@Id` /`@GeneratedValue` /`@SequenceGenerator`&#x20;

これらのアノテーションが付与されたフィールドは自動採番フィールドになります。\
`@Id`と`@GeneratedValue`は必ずセットでフィールドに付与する必要があります。\
`@GeneratedValue`のstrategy属性が`GenerationType.SEQUENCE`の場合に`@SequenceGenerator`を付与してシーケンスの生成方法を指定する必要があります。\
１つのエンティティに属する複数のフィールドを自動採番フィールドとして指定することも可能です。

| アノテーション     | 説明                                                     |
| :----------------- | :------------------------------------------------------- |
| @Id                | エンティティの自動採番フィールドを識別するアノテーション |
| @GeneratedValue    | 自動採番フィールドの値の生成戦略を指定するアノテーション |
| @SequenceGenerator | ID生成に使用するSEQUENCEの情報を設定するアノテーション   |

| アノテーション     | 属性名   | 型             | 必須 | 説明                                                                                 | 初期値                  |
| :----------------- | :------- | :------------- | :--: | :----------------------------------------------------------------------------------- | :---------------------- |
| @Id                | なし     | -              |  -   | -                                                                                    | -                       |
| @GeneratedValue    | strategy | GenerationType |  -   | ID生成戦略の型。`GenerationType.IDENTITY`, `GenerationType.SEQUENCE`のいずれかを指定 | GenerationType.IDENTITY |
| @SequenceGenerator | sequence | String         |  〇  | シーケンス名                                                                         | なし                    |
| @SequenceGenerator | catalog  | String         |  -   | シーケンスが所属するカタログ名                                                       | ""                      |
| @SequenceGenerator | schema   | String         |  -   | シーケンスが所属するスキーマ名                                                       | ""                      |

```java
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Id;
import jp.co.future.uroborosql.mapping.annotations.GeneratedValue;
import jp.co.future.uroborosql.mapping.annotations.SequenceGenerator;

@Table
public class Employee {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private long empId;

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE)
  @SequenceGenerator(sequence = 'employee_emp_detail_id_seq')
  private long empDetailId;

  private String firstName;

  // 以下略
}
```

---

---
url: /uroborosql-doc/developer_tools.md
---

# Developer Tools

![uroboroSQL formatter](/assets/uroboroSQLformatter_logo.BOWr-z4X.png)

* CLI
  * <https://github.com/future-architect/uroborosql-fmt>
* Visual Studio Code
  * <https://marketplace.visualstudio.com/items?itemName=Future.uroborosql-fmt>
* Sublime Text 3 Plugin
  * <https://github.com/future-architect/Sublime-uroboroSQL-formatter>
* IntelliJ IDEA Platform Plugin
  * <https://github.com/future-architect/idea-uroborosql-formatter>
* Eclipse Plugin
  * <https://github.com/future-architect/eclipse-uroborosql-formatter>
* CLI&#x20;
  * <https://github.com/future-architect/uroboroSQL-formatter>

---

---
url: /uroborosql-doc/configuration/dialect.md
---

# Dialect

複数のDBを対象とするアプリケーションを作成する場合、DB毎のSQL文法の差異を吸収するため
アプリケーションで対象DBを判定し実行するSQLファイルを切り替える、といった対応が必要になります。
**uroboroSQL**では、こういったDB毎のSQL文法の差異に対応するため、`Dialect`という仕組みを提供しています。

::: tip Dialectの自動判別
`Dialect`は接続したDBから取得できる情報を元に自動で判別される為、通常は変更する必要はありません。
:::

現在、標準で以下のDBに対するDialectが提供されています。

| DB名                 | Dialect                                                                                                                                              |
| :------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| H2 DB                | [H2Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/H2Dialect.java)                 |
| Microsoft SQL Server | [MsSqlDialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/MsSqlDialect.java)           |
| MySQL                | [MySqlDialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/MySqlDialect.java)           |
| MariaDB 5            | [MariaDb5Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/MariaDb5Dialect.java)     |
| MariaDB 10           | [MariaDb10Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/MariaDb10Dialect.java)   |
| Oracle10g以下        | [Oracle10Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle10Dialect.java)     |
| Oracle11g            | [Oracle11Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle11Dialect.java)     |
| Oracle12c〜17c       | [Oracle12Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle12Dialect.java)     |
| Oracle18c            | [Oracle18Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle18Dialect.java)     |
| Oracle19c            | [Oracle19Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle19Dialect.java)     |
| Oracle21c            | [Oracle21Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle21Dialect.java)     |
| Oracle23ai以上       | [Oracle23Dialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/Oracle23Dialect.java)     |
| Postgresql           | [PostgresqlDialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/PostgresqlDialect.java) |
| その他               | [DefaultDialect](https://github.com/future-architect/uroborosql/blob/master/src/main/java/jp/co/future/uroborosql/dialect/DefaultDialect.java)       |

::: warning
該当するDBが見つからない場合は`DefaultDialect`が適用されます
:::

## カスタムDialectの登録

標準でサポートしている上記のDB以外に接続し、`DefaultDialect`と違う動作をさせたい場合は、対象のDBに対する`Dialect`クラスを作成して**uroboroSQL**に登録する必要があります。

`Dialect`の登録には、Javaの [java.util.ServiceLoader](https://docs.oracle.com/javase/jp/8/docs/api/java/util/ServiceLoader.html)を利用します。

最初に対象のDB（ここではSQLiteとする）に対する`Dialect`クラスを作成します。

```java
package foo.bar.dialect;

public class SqliteDialect extends AbstractDialect {
  /**
   * コンストラクタ
   */
  public SqliteDialect() {
    super();
  }

  @Override
  public String getDatabaseName() {
    return "SQLite";  // 対象DBの製品名を特定するための文字列を返す
  }

  // supportsXXXメソッド、isXXXメソッド、getXXXメソッドを必要に応じて実装
}
```

`Dialect`インタフェースで提供すべきメソッドは以下になります。

| メソッド名                                                                             | 戻り値        | 説明                                                                                         |
| :------------------------------------------------------------------------------------- | :------------ | :------------------------------------------------------------------------------------------- |
| supportsBulkInsert()                                                                   | boolean       | `BULK INSERT`をサポートするかどうか                                                          |
| supportsEntityBulkUpdateOptimisticLock()                                               | boolean       | Entityバルクアップデートでの楽観ロックチェックをサポートしているか                           |
| supportsUpdateChained()                                          | boolean       | 複数SQLを指定された順で1つにつなげて更新処理を実行できるかどうか                             |
| supportsLimitClause()                                                                  | boolean       | `LIMIT`句をサポートするかどうか                                                              |
| supportsOptimizerHints()                                        | boolean       | オプティマイザーヒントをサポートするかどうか                                                 |
| supportsNullValuesOrdering()                                                           | boolean       | `SELECT`句の`ORDER BY`でNULL値の順序を指定できるか（NULLS FIRST/LAST）                       |
| supportsIdentity()                                                                     | boolean       | データベースのIDカラムを使用したID自動採番をサポートしているか                               |
| supportsSequence()                                                                     | boolean       | データベースのシーケンスを使用したID自動採番をサポートしているか                             |
| supportsForUpdate()                                                                    | boolean       | 明示的な行ロックをサポートしているか                                                         |
| supportsForUpdateNoWait()                                                              | boolean       | 明示的な行ロック（待機なし）をサポートしているか                                             |
| supportsForUpdateWait()                                                                | boolean       | 明示的な行ロック（待機あり）をサポートしているか                                             |
| supportsBatchGeneratedKeys()                                     | boolean       | バッチ処理での自動生成キーの取得をサポートしているか                                         |
| needsStrictSqlTypeForNullSetting()                               | boolean       | カラムにNULLを設定する際、カラムの厳密なSQLTypeを指定する必要があるか                        |
| isRemoveTerminator()                                                                   | boolean       | 実行するSQLに記述されている終端文字(`;`)を削除するかどうか                                   |
| isRollbackToSavepointBeforeRetry()                                                     | boolean       | リトライする前に設定したSavepointまでロールバックするかどうか                                |
| getSequenceNextValSql(String sequenceName)                                             | String        | シーケンスを取得するためのSQL文を取得する                                                    |
| getLimitClause(long limit, long offset)                                                | String        | `LIMIT`句（と`OFFSET`句）を取得する                                                          |
| escapeLikePattern(CharSequence pattern)                                                | String        | `LIKE`演算子のパターン文字列をエスケープする                                                 |
| getJavaType(JDBCType jdbcType, String jdbcTypeName)                                    | JavaType      | 引数で渡ってきたJavaTypeを変換したJavaTypeを取得する。（DB固有のJava型変換を行う場合に実装） |
| getJavaType(int jdbcType, String jdbcTypeName)                                         | JavaType      | 引数で渡ってきたJavaTypeを変換したJavaTypeを取得する。（DB固有のJava型変換を行う場合に実装） |
| getDatabaseName()                                                                      | String        | データベースを判別するための文字列を取得する                                                 |
| getDatabaseType()                                                                      | String        | データベースの種別を表す名前を取得する                                                       |
| getEscapeChar()                                                                        | char          | `LIKE`句で指定するエスケープキャラクタを取得する                                             |
| addForUpdateClause(StringBuilder sql, ForUpdateType forUpdateType, int waitSeconds)    | StringBuilder | `FOR UPDATE`句の文字列をSQLに追加する                                                        |
| addOptimizerHints(StringBuilder sql, List\<String> hints)  | StringBuilder | 引数で渡したSQLにオプティマイザーヒントを付与する                                            |
| getModLiteral(final String dividend, final String divisor)      | StringBuilder | 乗除を行うためのSQL文字列を取得する                                                          |
| getPessimisticLockingErrorCodes()                               | Set\<String> | 悲観ロックのErrorCode もしくは SqlStateを取得する                                            |

`Dialect`インタフェースのデフォルト実装や`AbstractDialect`クラスを参考に、上記のメソッドのうち変更が必要なメソッドの実装を行ってください。

次に**uroboroSQL**を利用するアプリケーションのクラスパス上に以下のファイル名のファイルを作成します。

```txt
META-INF
  └─services
      └─jp.co.future.uroborosql.dialect.Dialect
```

最後に作成した`jp.co.future.uroborosql.dialect.Dialect`ファイルの中に作成した`Dialect`のクラス名（FQDN名）を記述します。

```md
foo.bar.dialect.SqliteDialect
```

アプリケーションで`jp.co.future.uroborosql.dialect.Dialect`が`ServiceLoader`経由で読み込まれれば登録した`SqliteDialect`が利用可能になります。

---

---
url: /uroborosql-doc/configuration/event-listener-holder.md
---

# EventListenerHolder と EventSubscriber

## 概要

**uroboroSQL**では、SQL実行時のイベントをリスニングするための仕組みとして、`EventListenerHolder`と`EventSubscriber`を提供しています。これらを利用することで、SQL実行前後の処理をフックし、ロギングやメトリクス収集などのクロスカッティングな処理を実装できます。

## EventListenerHolder

`EventListenerHolder`は、複数の`EventSubscriber`を管理するコンテナクラスです。SQL実行時のイベントを登録されたすべてのサブスクライバーに通知します。

### 主な機能

* イベントサブスクライバーの登録・削除、イベントサブスクライバー一覧の取得
* 登録されたすべてのサブスクライバーへのイベント通知
* イベント処理の順序制御

## EventSubscriber

`EventSubscriber`は、SQL実行時の各種イベントを受け取るためのインターフェースです。以下のようなイベントをハンドリングできます。

### 対応イベント

#### SQL実行関連

| イベント                            | 説明                     |
| ----------------------------------- | ------------------------ |
| **AfterInitializeExecutionContext** | ExecutionContext初期化後 |
| **BeforeSetParameter**              | パラメータ設定前         |
| **BeforeTransformSql**              | SQL変換前                |
| **BeforeParseSql**                  | SQLパース前              |
| **AfterCreatePreparedStatement**    | PreparedStatement生成後  |
| **AfterCreateCallableStatement**    | CallableStatement生成後  |
| **AfterSqlQuery**                   | SQLQuery実行後           |
| **AfterSqlUpdate**                  | SQLUpdate実行後          |
| **AfterSqlBatch**                   | SQLBatch実行後           |
| **AfterProcedure**                  | Procedure実行後          |
| **AfterGetOutParameter**            | 出力パラメータ取得後     |

* SqlAgent#query/update/batch 実行時イベントの発生順序は以下になります。

```mermaid
flowchart TB
AfterInitializeExecutionContext("AfterInitializeExecutionContext<br>（ExecutionContext初期化後）")
BeforeSetParameter("BeforeSetParameter<br>（パラメータ設定前）")
BeforeTransformSql("BeforeTransformSql<br>（SQL変換前）")
BeforeParseSql("BeforeParseSql<br>（SQLパース前）")
AfterCreatePreparedStatement("AfterCreatePreparedStatement<br>（PreparedStatement生成後）")
AfterSqlQuery("AfterSqlQuery<br>（SQLQuery実行後）")
AfterSqlUpdate("AfterSqlUpdate<br>（SQLUpdate実行後）")
AfterSqlBatch("AfterSqlBatch<br>（SQLBatch実行後）")

AfterInitializeExecutionContext --> BeforeSetParameter
BeforeSetParameter --> BeforeTransformSql
BeforeTransformSql --> BeforeParseSql
BeforeParseSql --> AfterCreatePreparedStatement
AfterCreatePreparedStatement --> AfterSqlQuery
AfterCreatePreparedStatement --> AfterSqlUpdate
AfterCreatePreparedStatement --> AfterSqlBatch

```

* SqlAgent#procedure 実行時イベントの発生順序は以下になります。

```mermaid
flowchart TB
AfterInitializeExecutionContext("AfterInitializeExecutionContext<br>（ExecutionContext初期化後）")
BeforeSetParameter("BeforeSetParameter<br>（パラメータ設定前）")
BeforeTransformSql("BeforeTransformSql<br>（SQL変換前）")
BeforeParseSql("BeforeParseSql<br>（SQLパース前）")
AfterCreateCallableStatement("AfterCreateCallableStatement<br>（CallableStatement生成後）")
AfterProcedure("AfterProcedure<br>（Procedure実行後）")
AfterGetOutParameter("AfterGetOutParameter<br>（出力パラメータ取得後）")

AfterInitializeExecutionContext --> BeforeSetParameter
BeforeSetParameter --> BeforeTransformSql
BeforeTransformSql --> BeforeParseSql
BeforeParseSql --> AfterCreateCallableStatement
AfterCreateCallableStatement --> AfterProcedure
AfterProcedure --> AfterGetOutParameter
```

#### Entity操作関連

| イベント                    | 説明                    |
| --------------------------- | ----------------------- |
| **BeforeEntityQuery**       | EntityQuery実行前       |
| **AfterEntityQuery**        | EntityQuery実行後       |
| **BeforeEntityInsert**      | EntityInsert実行前      |
| **AfterEntityInsert**       | EntityInsert実行後      |
| **BeforeEntityUpdate**      | EntityUpdate実行前      |
| **AfterEntityUpdate**       | EntityUpdate実行後      |
| **BeforeEntityDelete**      | EntityDelete実行前      |
| **AfterEntityDelete**       | EntityDelete実行後      |
| **BeforeEntityBatchInsert** | EntityBatchInsert実行前 |
| **AfterEntityBatchInsert**  | EntityBatchInsert実行後 |
| **BeforeEntityBatchUpdate** | EntityBatchUpdate実行前 |
| **AfterEntityBatchUpdate**  | EntityBatchUpdate実行後 |
| **BeforeEntityBulkInsert**  | EntityBulkInsert実行前  |
| **AfterEntityBulkInsert**   | EntityBulkInsert実行後  |

#### トランザクション関連

| イベント                  | 説明                   |
| ------------------------- | ---------------------- |
| **AfterBeginTransaction** | トランザクション開始後 |
| **BeforeEndTransaction**  | トランザクション終了前 |
| **BeforeCommit**          | コミット前             |
| **AfterCommit**           | コミット後             |
| **BeforeRollback**        | ロールバック前         |
| **AfterRollback**         | ロールバック後         |

## **uroboroSQL**で提供されているサブスクライバー

**uroboroSQL**では、以下の`EventSubscriber`実装が標準で提供されています。

| サブスクライバ                                                      | 説明                                                    |
| ------------------------------------------------------------------- | ------------------------------------------------------- |
| [**SecretColumnEventSubscriber**](#secretcolumneventsubscriber)     | 指定したカラムの値を自動的に暗号化/復号化します         |
| [**WrapContextEventSubscriber**](#wrapcontexteventsubscriber)       | ExecutionContextをラップして機能を拡張します            |
| [**AuditLogEventSubscriber**](#auditlogeventsubscriber)             | SQL実行の監査ログを出力します                           |
| [**DebugEventSubscriber**](#debugeventsubscriber)                   | SQL実行のデバッグログを出力します                       |
| [**DumpResultEventSubscriber**](#dumpresulteventsubscriber)         | クエリ結果をダンプ形式で出力します                      |
| [**ReplCommandLogEventSubscriber**](#replcommandlogeventsubscriber) | REPL(対話型SQL実行環境)でのコマンド実行ログを出力します |

### SecretColumnEventSubscriber

DBアクセス時に機密カラムの値を暗号化/復号化するサブスクライバーです。\
このサブスクライバーを使用することで、DBの暗号化の仕組みを利用せずにカラム単位での値の暗号化・復号化ができます。

#### **主な機能:**

* [Javaの暗号化の仕組み](https://docs.oracle.com/javase/jp/11/docs/api/java.base/javax/crypto/package-summary.html) を使用して、指定カラムの暗号化・復号化を行います。
  * INSERT/UPDATE実行時に指定カラムの値を暗号化
  * SELECT実行時に指定カラムの値を復号化

#### パラメータ:

| パラメータ名           | 型             | 必須 | デフォルト値         | 説明                                                                                                                                                                                                                                 |
| ---------------------- | -------------- | ---- | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **keyStoreFilePath**   | String         | ○    | -                    | 秘密鍵を格納したKeyStoreファイルのパスKeyStoreはJCEKSタイプであること                                                                                                                                                           |
| **alias**              | String         | ○    | -                    | KeyStore内で秘密鍵が格納されている場所を示すエイリアス名                                                                                                                                                                             |
| **storePassword**      | String         | ○    | -                    | KeyStoreにアクセスするためのストアパスワードBase64エンコードした値を指定する                                                                                                                                                    |
| **cryptColumnNames**   | List\<String> | ○    | -                    | 暗号化、復号化を行うカラム名のリストカラム名はスネークケース（大文字）で指定するcryptColumnNames で指定したカラム名はcryptParamKeysにも追加される                                                                          |
| **cryptParamKeys**     | List\<String> | ○    | -                    | 暗号化、復号化を行うパラメータ名のリストパラメータ名はキャメルケースで指定する                                                                                                                                                  |
| **charset**            | String         |      | UTF-8                | 暗号化/復号化時に使用するキャラクタセット                                                                                                                                                                                            |
| **transformationType** | String         |      | AES/ECB/PKCS5Padding | 変換の名前（例: AES/GCM/NoPadding）。標準の変換名については、[Java暗号化アーキテクチャー標準アルゴリズム名](https://docs.oracle.com/javase/jp/11/docs/specs/security/standard-names.html#cipher-algorithm-names)のドキュメントを参照 |
| **skip**               | boolean        |      | false                | イベント処理をスキップするかどうか                                                                                                                                                                                                   |

::: warning 機密カラムの命名
SecretColumnEventSubscriber では機密情報を格納するカラムをカラム名で特定します。\
そのためカラム名が同一で、暗号化するカラムと暗号化しないカラムが混在している場合は対応できません。\
機密情報を格納するカラムの名前は一意に識別できるような命名を行ってください。
:::

### WrapContextEventSubscriber

発行するSQL文字列の前後をラップするサブスクライバーです。

#### **主な機能:**

* SQL発行をフックし、発行されるSQLの前後に文字列を付与します。主に検索SQLをページングに対応するために一律limit句やoffset句を追加するような用途を想定しています。
* SQL変換前にSQLの加工を行うため、バインドパラメータや置換文字列も利用できます。

#### パラメータ:

| パラメータ名             | 型     | 必須 | デフォルト値 | 説明                                                                                               |
| ------------------------ | ------ | ---- | ------------ | -------------------------------------------------------------------------------------------------- |
| **wrappedSqlBeginParts** | String |      | -            | SQL文の前に追加する文字列例: `SELECT * FROM (`                                                |
| **wrappedSqlEndParts**   | String |      | -            | SQL文の後に追加する文字列例: `) LIMIT /*pageSize*/100 OFFSET /*pageSize * (pageCount - 1)*/0` |
| **wrapIgnorePattern**    | String |      | -            | Wrapを無視するSQLのパターン（正規表現）このパターンにマッチするSQLはWrap処理をスキップする    |

### AuditLogEventSubscriber

SQL実行の監査ログを記録するためのサブスクライバーです。SQL実行前後の情報を構造化されたログとして出力します。\
AuditLogは ログ名 : `jp.co.future.uroborosql.event.auditlog` に debugレベルで出力されます。

#### **主な機能:**

* SQL実行時刻、実行時間の記録
* 実行されたSQL文とバインドパラメータの記録
* 実行結果(件数、エラー情報など)の記録

#### パラメータ:

| パラメータ名    | 型     | 必須 | デフォルト値 | 説明                                                                                      |
| --------------- | ------ | ---- | ------------ | ----------------------------------------------------------------------------------------- |
| **funcIdKey**   | String |      | \_funcId     | バインドパラメータから機能IDを取得する際のキー名ログに記録する機能IDの取得に使用     |
| **userNameKey** | String |      | \_userName   | バインドパラメータからユーザ名を取得する際のキー名ログに記録するユーザ名の取得に使用 |

::: warning 注意事項
AuditLogEventSubscriber で件数を取得するためにはResultSetの種類が `ResultSet#TYPE_SCROLL_INSENSITIVE` または `ResultSet#TYPE_SCROLL_SENSITIVE` である必要があります。\
`ResultSet#TYPE_FORWARD_ONLY` の場合は 件数は常に -1 となります。
:::

### DebugEventSubscriber

開発時のデバッグ用ログを出力するサブスクライバーです。SQL実行の詳細な情報をコンソールに出力します。\
デバッグ用ログは ログ名 : `jp.co.future.uroborosql.event.debug` に debugレベルとtraceレベルで出力されます。

#### **主な機能:**

* トランザクション開始・終了の表示（debug）
* バインドパラメータの詳細表示（debug）
* 発行したSQL名の表示（debug）
* 発行したSQL文の表示（trace）

### DumpResultEventSubscriber

クエリ結果をダンプ形式で出力するサブスクライバーです。SELECT文の実行結果を表形式で見やすく表示します。\
クエリ結果ダンプ結果ログは ログ名 : `jp.co.future.uroborosql.event.dumpresult` に debugレベルで出力されます。

#### **主な機能:**

* クエリ結果の表形式表示

::: warning 注意事項
DumpResultEventSubscriber によるクエリ結果の取得にはResultSetの種類が `ResultSet#TYPE_SCROLL_INSENSITIVE` または `ResultSet#TYPE_SCROLL_SENSITIVE` である必要があります。\
`ResultSet#TYPE_FORWARD_ONLY` の場合もクエリ結果は出力されますが、このサブスクライバーが結果セットを先頭から最後まで読み進めるため、
処理後にはカーソルが末尾に到達し、アプリケーション側で同じ `ResultSet` を使った後続の検索・取得処理は行えなくなります（結果セットが消費されます）
:::

### ReplCommandLogEventSubscriber

REPL(対話型SQL実行環境)でのコマンド実行ログを記録するサブスクライバーです。\
コマンド実行ログは ログ名 : `jp.co.future.uroborosql.event.replcommand` に debugレベルで出力されます。

#### **主な機能:**

* REPLコマンドの実行履歴記録

## カスタムEventSubscriberの作成

**uroboroSQL**では、`EventSubscriber`インターフェースを実装することで、独自のイベント処理を追加できます。\
ここでは、カスタムサブスクライバーを作成する方法を解説します。

### 基本的な実装手順

#### 1. EventSubscriberインターフェースの実装

`EventSubscriber`を継承し、必要なイベントメソッドをオーバーライドします。

```java
public class CustomEventSubscriber extends EventSubscriber {
    private static final Logger LOG = LoggerFactory.getLogger(CustomEventSubscriber.class);

    @Override
    public void initialize() {
        // EventSubscriberが提供する各イベントのリスナー登録用メソッドにリスナーを登録
		    afterSqlQueryListener(this::afterSqlQuery);
        // 初期化処理
        LOG.info("CustomEventSubscriber initialized");
    }

    void afterSqlQuery(final AfterSqlQueryEvent evt) {
        LOG.debug("Execute Query - sqlName:{} executed.", evt.getExecutionContext().getSqlName());
    }
}
```

#### 2. SqlConfigへの登録

作成したサブスクライバーを`SqlConfig`に登録します。

```java
SqlConfig config = UroboroSQL.builder("jdbc:h2:mem:test", "sa", "")
    .build();

config.getEventListenerHolder()
    .addEventSubscriber(new CustomEventSubscriber());
```

### EventSubscriber実装例（共通項目自動パラメータバインド）

アプリケーションで使用する各テーブルに共通項目（登録日時、更新日時など）が定義されている場合、
INSERT文やUPDATE文を実行する際には、毎回これらの共通項目に対するパラメータを指定する必要があります。

このような共通項目へのパラメータ設定を個別に行うと、実装が煩雑になるだけでなく、
実装漏れや記述ミスにより正しく値が設定されないといった問題が発生しやすくなります。

このような共通項目へのパラメータ設定は、`EventSubscriber` を利用することで自動化できます。
`EventSubscriber` のイベントはSQL実行のたびに呼び出されるため、イベント内で共通項目のパラメータを設定することで、
すべてのSQL実行時に自動的にパラメータがバインドされます。

* 共通項目自動パラメータバインドイベントサブスクライバー実装例

```java
/**
 * 共通項目自動パラメータバインドイベントサブスクライバー
 **/
public class AutoParameterBindEventSubscriber extends EventSubscriber {
    @Override
    public void initialize() {
      // SQL API 用
      beforeParseSqlListener(this::onBeforeParseSql);

      // DAO API 用
      beforeEntityInsertListener(event -> bindInsertParams(event.getEntity()));
      beforeEntityBulkInsertListener(event -> bindInsertParams(event.getEntity()));
      beforeEntityBatchInsertListener(event -> bindInsertParams(event.getEntity()));
      beforeEntityUpdateListener(event -> bindUpdateParams(event.getEntity()));
      beforeEntityBatchUpdateListener(event -> bindUpdateParams(event.getEntity()));
    }

    /**
     * SQLパース前のイベントを処理する.
     *
     * @param event イベント
     */
    protected void onBeforeParseSql(final BeforeParseSqlEvent event) {
      switch (event.getExecutionContext().getSqlKind()) {
        case INSERT,
             MERGE,
             UPDATE,
             BATCH_INSERT,
             BATCH_UPDATE,
             BULK_INSERT,
             ENTITY_BATCH_INSERT,
             ENTITY_BULK_INSERT,
             ENTITY_INSERT,
             ENTITY_UPDATE -> {
                ExecutionContext ctx = event.getExecutionContext();
                LocalDateTime now = LocalDateTime.now();
                ctx.paramIfAbsent("createDatetime", now);
                ctx.paramIfAbsent("updateDatetime", now);
             };
        default -> {}
      }
    }

    /**
     * 登録用のパラメータをバインドする.
     *
     * @param entity エンティティ
     */
    protected void bindInsertParams(final Object entity) {
        // DAOクラスがEntityModel抽象クラスを継承し、EntityModelクラスに共通項目のフィールドが定義されている、とします。
      if (!(entity instanceof EntityModel model)) {
        return;
      }

      LocalDateTime now = LocalDateTime.now();
      model.setCreateDatetime(now);
      model.setUpdateDatetime(now);
    }

    /**
     * 更新用のパラメータをバインドする.
     *
     * @param entity エンティティ
     */
    protected void bindUpdateParams(final Object entity) {
        // DAOクラスがEntityModel抽象クラスを継承し、EntityModelクラスに共通項目のフィールドが定義されている、とします。
      if (!(entity instanceof EntityModel model)) {
        return;
      }

      model.setUpdateDatetime(LocalDateTime.now());
    }
}
```

---

---
url: /uroborosql-doc/configuration/execution-context-provider.md
---

# ExecutionContextProvider

SQL構造を表現するクラスである`ExecutionContext`を生成するプロバイダクラスです。生成されるSQLの挙動を変更するための設定が行えます。

::: tip クラス名の変更
uroborosql v1.x で SqlContextFactory から ExecutionContextProviderにクラス名が変更されました。
:::

設定例

```java
// create SqlConfig
SqlConfig config = UroboroSQL
  .builder(...)
  // ExecutionContextProviderの設定
  .setExecutionContextProvider(new ExecutionContextProviderImpl()
    // 定数クラス設定の追加
    .setConstantClassNames(Arrays.asList(TypeConstants.class.getName()))
    // 列挙型パッケージ設定の追加
    .setEnumConstantPackageNames(Arrays.asList(Gender.class.getPackage().getName()))
     // 定数パラメータのプレフィックス指定(初期値 : CLS_)
    .setConstParamPrefix("CLS_")
    // パラメータ変換クラスの登録
    .addBindParamMapper(new CustomBindParamMapper())
    // ResultSetTypeの初期値
    // java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.TYPE_SCROLL_SENSITIVE のいずれか
    .setDefaultResultSetType(ResultSet.TYPE_FORWARD_ONLY)
    // ResultSetConcurrencyの初期値
    // java.sql.ResultSet.CONCUR_READ_ONLY, java.sql.ResultSet.CONCUR_UPDATABLE のいずれか
    .setDefaultResultSetConcurrency(ResultSet.CONCUR_READ_ONLY)
  ).build();
```

## 区分値定数や列挙型の利用 ( `ExecutionContextProvider#setConstantClassNames` /`#setEnumConstantPackageNames`)

これまでSQLの開発では、区分値や定数値などの固定値がマジックナンバーとしてSQL文内に埋め込まれていました。\
しかしマジックナンバーの記述は可読性が悪く仕様変更時の影響調査が困難なため不具合の温床となっていました。

例

```sql
select
 *
from employee
where emp_typ = '05' -- 05:従業員     <-- 従業員の区分が変わったらどうする？
```

**uroboroSQL**はエンタープライズ分野での開発に利用されてきた経験から、SQL文の中でマジックナンバーの代わりに定数や列挙型を利用するための仕組みを提供しています。

区分値定数/列挙型を利用するためには`ExecutionContextProvider`に以下の設定を追加します。

```java
// create SqlConfig
SqlConfig config = UroboroSQL
  .builder(...)
  // ExecutionContextProviderの設定
  .setExecutionContextProvider(new ExecutionContextProviderImpl()
    // 定数クラス設定の追加
    .setConstantClassNames(Arrays.asList(TypeConstants.class.getName()))
    // 列挙型パッケージ設定の追加
    .setEnumConstantPackageNames(Arrays.asList(Gender.class.getPackage().getName()))
     // 定数パラメータのプレフィックス指定(初期値 : CLS_)
    .setConstParamPrefix("CLS_")
  ).build();
```

定数クラス : TypeConstants.javaの実装例

```java
/**
 * 区分値定数クラス
 */
public final class TypeConstants {
  private TypeConstants() {}

  /** 区分種別：口座種別区分  区分種別番号：0035 */
  public static final String ACCOUNT_TYP = "0035";
  /** 区分種別：口座種別区分  区分値：普通  区分値番号：1 */
  public static final String ACCOUNT_TYP_SAVING = "1";
  /** 区分種別：口座種別区分  区分値：当座  区分値番号：2 */
  public static final String ACCOUNT_TYP_CHECKING = "2";
  /** 区分種別：口座種別区分  区分値：定期  区分値番号：3 */
  public static final String ACCOUNT_TYP_FIXED_DEPOSIT = "3";
  /** 区分種別：実行区分  区分種別番号：0052 */
  public static final String ISSUE_TYP = "0052";
  /** 区分種別：実行区分  区分値：未実行  区分値番号：1 */
  public static final String ISSUE_TYP_UNISSUED = "1";
  /** 区分種別：実行区分  区分値：実行済  区分値番号：2 */
  public static final String ISSUE_TYP_OUTSTANDING = "2";
}

/**
 * システム定数
 */
public final class Consts {
  private Consts() {}

  public static final class CommonValue {
    private CommonValue() {}

    /** 業務日付（オンライン） */
    public static final String ONLINE_DATE = "1";

    /** 業務日付（バッチ） */
    public static final String BATCH_DATE = "2";

    /** SQL上でのフラグ表現（TRUE=1） */
    public static final String FLAG_ON = "1";
    /** SQL上でのフラグ表現（FALSE=0） */
    public static final String FLAG_OFF = "0";
    /** 日付ALL0 */
    public static final String ZERO_DATE = "00000000";
    /** 日付最小値 */
    public static final String MIN_DATE = "19000101";
    /** 日付最大値 */
    public static final String MAX_DATE = "99991231";
  }
}
```

列挙型 : Gender.javaの実装例

```java
/**
 * 性別を表す列挙型
 */
public enum Gender {
  MALE("M"), FEMALE("F"), OTHER("O");

  private final String label;

  private Gender(String label) {
    this.label = label;
  }

  @Override
  public String toString() {
    return label;
  }
}
```

このように区分値定数や列挙型を定数パラメータとして登録しておくことで、SQL文の中で定数名が利用できるようになります。

定数パラメータを利用する場合、以下の命名ルールに従ってパラメータを指定します。

| パターン                    | 書式                                                                                                     |
| :-------------------------- | :------------------------------------------------------------------------------------------------------- |
| 定数                        | \[定数パラメータプレフィックス]\[定数フィールド名大文字]                                                   |
| 定数(Innerクラスがある場合) | \[定数パラメータプレフィックス]\[Innerクラス名大文字スネークケース]\_\[Innerクラス内定数フィールド名大文字] |
| 列挙型                      | \[定数パラメータプレフィックス]\[列挙型名大文字]\_\[列挙子名大文字]                                         |

::: tip
※定数パラメータプレフィックスの初期値は `CLS_`となっています。\
`ExecutionContextProvider#setConstParamPrefix()`で変更することが可能です。
:::

実際に使用する際はSQL文の中で置換文字列として以下のように指定します

* /\*#\[定数パラメータプレフィックス]\[定数フィールド名大文字]\*/
* /\*#\[定数パラメータプレフィックス]\[Innerクラス名大文字スネークケース]\_\[Innerクラス内定数フィールド名大文字]\*/
* /\*#\[定数パラメータプレフィックス]\[列挙型名大文字]\_\[列挙子名大文字]\*/

または

* /\*$\[定数パラメータプレフィックス]\[定数フィールド名大文字]\*/
* /\*$\[定数パラメータプレフィックス]\[Innerクラス名大文字スネークケース]\_\[Innerクラス内定数フィールド名大文字]\*/
* /\*$\[定数パラメータプレフィックス]\[列挙型名大文字]\_\[列挙子名大文字]\*/

という風に使用します。

::: tip
定数や列挙型の値は固定値なので生成されるSQLは毎回同じ値になり、SQL文解析処理によるCPU負荷を考慮する必要はありません。
:::

区分の例

```sql
select
 *
from account
where account_typ = /*#CLS_ACCOUNT_TYP_SAVING*/'1' -- 1:普通口座
```

定数の例

```sql
select
   emp.emp_no    as  emp_no
,  emp.first_name  as  first_name
,  emp.last_name  as  last_name
,  emp.birth_date  as  birth_date
,  emp.gender    as  gender
from
  employee  emp
where
  emp.birth_date    !=  /*#CLS_COMMON_VALUE_ZERO_DATE*/'00000000'  -- 定数パラメータの指定
```

列挙型の例

```sql
select
   emp.emp_no    as  emp_no
,  emp.first_name  as  first_name
,  emp.last_name  as  last_name
,  emp.birth_date  as  birth_date
,  emp.gender    as  gender
from
  employee  emp
where
  emp.gender    =  /*#CLS_GENDER_FEMALE*/'F'  -- 列挙型定数パラメータの指定
```

定数パラメータは条件分岐の中で使用することもできます。

```sql
select
   emp.emp_no    as  emp_no
,  emp.first_name  as  first_name
,  emp.last_name  as  last_name
,  emp.birth_date  as  birth_date
,  emp.gender    as  gender
from
  employee  emp
/*IF gender == CLS_GENDER_MALE or gender == CLS_GENDER_FEMALE */
where
  emp.gender    =  /*#CLS_GENDER_FEMALE*/'F'  -- 列挙型定数パラメータの指定
/*END*/
```

## バインドパラメータ変換クラスの設定 ( `ExecutionContextProvider#addBindParamMapper` )&#x20;

SQLを実行する際、独自に作成したクラスをバインドしたい場合があります。
そういったケースに対応できるよう**uroboroSQL**ではバインドパラメータをJDBCが受け入れられる型に変換するためのクラスを
設定することが出来ます。

バインドパラメータ変換クラスの例

```java
// Nameクラスに対するバインドパラメータ変換クラス
public class CustomBindParamMapper implements BindParameterMapper<Name> {
  @Override
  public Object toJdbc(Name original, Connection connection,
    BindParameterMapperManager parameterMapperManager) {
    return original.toString();
  }
}

// バインドパラメータに設定するドメインクラス
public class Name {
  private final String firstName;
  private final String lastName;

  public Name(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @Override
  public String toString() {
    return this.firstName + " " + this.lastName;
  }
}
```

`ExecutionContextProvider`の設定

```java
// create SqlConfig
SqlConfig config = UroboroSQL
.builder(...)
// ExecutionContextProviderの設定
.setExecutionContextProvider(new ExecutionContextProviderImpl()
  // パラメータ変換クラスの登録
  .addBindParamMapper(new CustomBindParamMapper())
).build();
```

バインドパラメータ設定例

```java
Name name = new Name("Bob", "Smith");
agent.update("insert_user").param("name", name).count();
```

## java.sql.ResultSetの挙動設定&#x20;

検索SQLの発行で取得する`java.util.ResultSet`の挙動を変更することができます。

```java
// create SqlConfig
SqlConfig config = UroboroSQL
  .builder(...)
  // ExecutionContextProviderの設定
  .setExecutionContextProvider(new ExecutionContextProviderImpl()
    // ResultSetTypeの初期値
    // java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.TYPE_SCROLL_SENSITIVE のいずれか
    .setDefaultResultSetType(ResultSet.TYPE_FORWARD_ONLY)
    // ResultSetConcurrencyの初期値
    // java.sql.ResultSet.CONCUR_READ_ONLY, java.sql.ResultSet.CONCUR_UPDATABLE のいずれか
    .setDefaultResultSetConcurrency(ResultSet.CONCUR_READ_ONLY)
  ).build();
```

### カーソル型の初期値（`DefaultResultSetType`）

`java.sql.ResultSet`のカーソルの型を指定します。
| 型 | 説明 | 初期値 |
| :----------------------------------------- | :--------------------------------------------------------------------------------- | :----: |
| java.sql.ResultSet#TYPE\_FORWARD\_ONLY | カーソルは最初から最後まで順方向にしか移動できません。 | ◯ |
| java.sql.ResultSet#TYPE\_SCROLL\_INSENSITIVE | カーソルは順方向・逆方向いずれにも移動可能です。ただし他による変更を反映しません。 | |
| java.sql.ResultSet#TYPE\_SCROLL\_SENSITIVE | カーソルは順方向・逆方向いずれにも移動可能です。また他による変更も反映します。 | |

### 変更可能性の初期値（`DefaultResultSetConcurrency`）

`java.sql.ResultSet`の変更可能性を指定します。
| 型 | 説明 | 初期値 |
| :---------------------------------- | :----------------------------------------------------------------------------------- | :----: |
| java.sql.ResultSet.CONCUR\_READ\_ONLY | カーソルはデータの読み出ししかサポートしません。 | ◯ |
| java.sql.ResultSet.CONCUR\_UPDATABLE | カーソルは変更可能です。カーソルを用いたデータの挿入・変更・削除がサポートされます。 | |

---

---
url: /uroborosql-doc/advanced/parameter-mapping.md
---

# JavaオブジェクトとJDBC型のパラメータマッピング

**uroboroSQL**では、JavaオブジェクトとJDBC間の型変換を自動的に行う仕組みを提供しています。\
この機能により、アプリケーション層で使用する型（Java 8 Date and Time API、Optional、Enum、カスタムドメインオブジェクトなど）とデータベース層で使用する型（java.sql.\*クラス、プリミティブ型など）を相互に変換できます。

マッピングは2つの方向で行われます：

1. **Javaオブジェクト → JDBC型の変換**: バインドパラメータ設定時に`BindParameterMapper`が使用されます
2. **JDBC型 → Javaオブジェクトの変換**: ResultSet取得時に`PropertyMapper`が使用されます

## 1. Javaオブジェクト → JDBCオブジェクトの変換（BindParameterMapper）

バインドパラメータを設定する際、`BindParameterMapperManager`が適切な`BindParameterMapper`を選択し、JavaオブジェクトをJDBCが受け入れ可能な型に変換します。

```mermaid
flowchart TD
    A[アプリケーション<br>Javaオブジェクト] --> B[BindParameterMapperManager]
    B -->D1{変換可能判定}
    D1 -->|ユーザ定義| M1[1.ユーザ定義<br>BindParameterMapper]
    D1 -->|JDBCネイティブ型| M2[2.JDBCネイティブ型変換]
    D1 -->|標準| M3[3.標準<br>BindParameterMapper]
    M1 --> G[JDBC型]
    M2 --> G
    M3 --> G
    G --> H[PreparedStatement<br>.setObject]
```

### BindParameterMapperの選択順序

1. ユーザ定義Mapper
   1. ServiceLoaderで登録されたユーザ定義Mapper
   2. BindParameterMapperManager#addMapperで追加されたユーザ定義Mapper
2. Javaプリミティブ型とラッパークラス他
   1. short, int, long, double, boolean, byte とそのラッパークラス
   2. String, BigDecimal, byte\[]
   3. java.sql.\*型
3. 標準Mapper
   1. DateTimeApiParameterMapper
   2. その他の標準Mapper（Date, BigInteger, Optional, Domain, Enum, 配列型）
4. 変換なし

::: tip Mapperの優先度制御
ユーザ定義Mapperは標準Mapperより優先されるため、標準の変換動作をオーバーライドすることができます。\
複数のMapperが同じ型を処理できる場合、最初にマッチしたMapperが使用されます。
:::

### 主要インターフェース

```java
public interface BindParameterMapper<T> {
    // 変換対象の型を返す
    Class<T> targetType();

    // 変換可能かどうかを判定
    boolean canAccept(Object object);

    // JDBCが受け入れ可能な型に変換
    Object toJdbc(T original, Connection connection, BindParameterMapperManager parameterMapperManager);
}
```

### 標準で提供されるMapper

**uroboroSQL**は以下の`BindParameterMapper`を標準で提供しています。

| Mapper名                              | 標準Mapper登録 | 対象Java型                                 | 変換後JDBC型          | 説明                                                 |
| ------------------------------------- | :------------: | ------------------------------------------ | --------------------- | ---------------------------------------------------- |
| **DateParameterMapper**               |       〇       | java.util.Date                             | java.sql.Timestamp    | java.util.DateをTimestampに変換                      |
| **BigIntegerParameterMapper**         |       〇       | BigInteger                                 | BigDecimal            | BigIntegerをBigDecimalに変換                         |
| **DateTimeApiParameterMapper**        |       〇       | TemporalAccessor（各種）                   | Timestamp/Date/Time   | Java 8 Date and Time APIの各型をSQL型に変換          |
| **OptionalParameterMapper**           |       〇       | Optional\<T>                              | Tの変換結果またはnull | Optionalの値を取り出して変換                         |
| **OptionalIntParameterMapper**        |       〇       | OptionalInt                                | Integer/null          | OptionalIntの値を抽出                                |
| **OptionalLongParameterMapper**       |       〇       | OptionalLong                               | Long/null             | OptionalLongの値を抽出                               |
| **OptionalDoubleParameterMapper**     |       〇       | OptionalDouble                             | Double/null           | OptionalDoubleの値を抽出                             |
| **DomainParameterMapper**             |       〇       | @Domain付きクラス                          | ドメインの値型        | ドメインオブジェクトから値を抽出                     |
| **EnumParameterMapper**               |       〇       | Enum                                       | String                | Enum値をtoString()メソッドで文字列に変換             |
| **StringArrayParameterMapper**        |       〇       | String\[]                                   | java.sql.Array        | String配列をSQL Arrayに変換                          |
| **IntArrayParameterMapper**           |       〇       | int\[]                                      | java.sql.Array        | int配列をSQL Arrayに変換                             |
| **IntWrapperArrayParameterMapper**    |       〇       | Integer\[]                                  | java.sql.Array        | Integer配列をSQL Arrayに変換                         |
| **LongArrayParameterMapper**          |       〇       | long\[]                                     | java.sql.Array        | long配列をSQL Arrayに変換                            |
| **LongWrapperArrayParameterMapper**   |       〇       | Long\[]                                     | java.sql.Array        | Long配列をSQL Arrayに変換                            |
| **DoubleArrayParameterMapper**        |       〇       | double\[]                                   | java.sql.Array        | double配列をSQL Arrayに変換                          |
| **DoubleWrapperArrayParameterMapper** |       〇       | Double\[]                                   | java.sql.Array        | Double配列をSQL Arrayに変換                          |
| **EmptyStringToNullParameterMapper**  |                | String                                     | String/null           | 空文字列をnullに変換                                 |
| **DateToStringParameterMapper**       |                | java.util.Date                             | String                | yyyyMMdd形式の文字列に変換                           |
| **LocalDateToStringParameterMapper**  |                | java.time.LocalDate                        | String                | yyyyMMdd形式の文字列に変換                           |
| **TimeToStringParameterMapper**       |                | LocalTime/OffsetTime                       | String                | HHmmss形式の文字列に変換                             |
| **DateTimeToStringParameterMapper**   |                | LocalDateTime/OffsetDateTime/ZonedDateTime | String                | yyyyMMddHHmmssSSS形式の文字列に変換                  |
| **SqlTimeToStringParameterMapper**    |                | java.sql.Time                              | String                | HHmmss形式の文字列に変換                             |
| **YearToStringParameterMapper**       |                | java.time.Year                             | String                | yyyy形式の文字列に変換                               |
| **YearMonthToStringParameterMapper**  |                | java.time.YearMonth                        | String                | yyyyMM形式の文字列に変換                             |
| **MonthDayToStringParameterMapper**   |                | java.time.MonthDay                         | String                | MMdd形式の文字列に変換                               |
| **MonthToStringParameterMapper**      |                | java.time.Month                            | String                | MM形式（01〜12）の文字列に変換                       |
| **DayOfWeekToStringParameterMapper**  |                | java.time.DayOfWeek                        | String                | 数字形式（1（月曜日）から7（日曜日））の文字列に変換 |

## 2. JDBC型 → Javaオブジェクトの変換（PropertyMapper）

ResultSetから値を取得する際、`PropertyMapperManager`が適切な`PropertyMapper`を選択し、JDBC型をアプリケーションで使用するJavaオブジェクトに変換します。

```mermaid
flowchart TD
    A[ResultSet] --> B[PropertyMapperManager]
    B --> D1{変換可能判定}
    D1 -->|ユーザ定義| M1[1.ユーザ定義<br>PropertyMapper]
    D1 -->|Javaネイティブ型| M2[2.JDBC標準変換<br>rs.getString等]
    D1 -->|標準| M3[3.標準<br>PropertyMapper]
    M1 --> G[Javaオブジェクト]
    M2 --> G
    M3 --> G
```

### PropertyMapperの選択順序

1. ユーザ定義Mapper
   1. ServiceLoaderで登録されたユーザ定義Mapper
   2. PropertyMapperManager#addMapperで登録されたユーザ定義Mapper
2. Javaプリミティブ型とラッパークラス他
   1. short, int, long, double, boolean, byte とそのラッパークラス
   2. String, BigDecimal, byte\[]
   3. java.sql.\*型
3. 標準Mapper
   1. DateTimeApiParameterMapper
   2. その他の標準Mapper（BigInteger, Optional, Domain, Enum, 配列型）

::: tip Mapperの優先度制御
ユーザ定義Mapperは標準Mapperより優先されるため、標準の変換動作をオーバーライドすることができます。\
複数のMapperが同じ型を処理できる場合、最初にマッチしたMapperが使用されます。
:::

### 主要インターフェース

```java
public interface PropertyMapper<T> {
    // 変換可能な型かどうかを判定
    boolean canAccept(Class<?> type);

    // ResultSetから値を取得して型変換
    T getValue(JavaType type, ResultSet rs, int columnIndex, PropertyMapperManager mapperManager) throws SQLException;
}
```

### 標準で提供されるMapper

**uroboroSQL**は以下の`PropertyMapper`を標準で提供しています。

| Mapper名                         | 標準Mapper登録 | 変換元JDBC型               | 対象Java型               | 説明                                            |
| -------------------------------- | :------------: | -------------------------- | ------------------------ | ----------------------------------------------- |
| **BigIntegerPropertyMapper**     |       〇       | BigDecimal/Long等          | BigInteger               | 数値型をBigIntegerに変換                        |
| **DateTimeApiPropertyMapper**    |       〇       | Timestamp/Date/Time/String | TemporalAccessor（各種） | SQL型やString型をJava 8 Date and Time APIに変換 |
| **OptionalPropertyMapper**       |       〇       | 任意                       | Optional\<T>            | Optional型に変換                                |
| **OptionalIntPropertyMapper**    |       〇       | Integer/null               | OptionalInt              | OptionalInt型に変換                             |
| **OptionalLongPropertyMapper**   |       〇       | Long/null                  | OptionalLong             | OptionalLong型に変換                            |
| **OptionalDoublePropertyMapper** |       〇       | Double/null                | OptionalDouble           | OptionalDouble型に変換                          |
| **DomainPropertyMapper**         |       〇       | ドメインの値型             | @Domain付きクラス        | 値からドメインオブジェクトを生成                |
| **EnumPropertyMapper**           |       〇       | String/Integer             | Enum                     | 文字列または数値からEnum値に変換                |
| **ArrayPropertyMapper**          |       〇       | java.sql.Array             | 配列型                   | SQL ArrayをJava配列に変換                       |

## 主要Mapperの詳細

### DateTimeApiParameterMapper / DateTimeApiPropertyMapper

Java 8 Date and Time APIの各型とSQL型の相互変換を行います。

* **Java → JDBC変換（DateTimeApiParameterMapper）**

| Java型                               | 変換後のJDBC型        |
| ------------------------------------ | --------------------- |
| LocalDate                            | java.sql.Date         |
| LocalTime                            | java.sql.Time         |
| OffsetTime                           | java.sql.Time         |
| LocalDateTime                        | java.sql.Timestamp    |
| OffsetDateTime                       | java.sql.Timestamp    |
| ZonedDateTime                        | java.sql.Timestamp    |
| Instant                              | java.sql.Timestamp    |
| Year                                 | String または Integer |
| YearMonth                            | String または Integer |
| MonthDay                             | String または Integer |
| Month                                | String または Integer |
| DayOfWeek                            | String または Integer |
| Era                                  | String または Integer |
| ChronoLocalDate （JapaneseDateなど） | java.sql.Date         |

* **JDBC → Java変換（DateTimeApiPropertyMapper）**

変換元JDBC型のカラム値から指定されたJava型に合わせた型変換を行います。

| 変換元JDBC型                                                    |
| --------------------------------------------------------------- |
| java.sql.Date                                                   |
| java.sql.Time                                                   |
| java.sql.Timestamp                                              |
| String（[変換可能日時フォーマット](#変換可能日時フォーマット)） |

| 変換可能Java型                       |
| ------------------------------------ |
| LocalDate                            |
| LocalTime                            |
| OffsetTime                           |
| LocalDateTime                        |
| OffsetDateTime                       |
| ZonedDateTime                        |
| Year                                 |
| YearMonth                            |
| MonthDay                             |
| Month                                |
| DayOfWeek                            |
| Era                                  |
| ChronoLocalDate （JapaneseDateなど） |

#### 変換可能日時フォーマット

| Java型                                     | 受け入れ可能なStringフォーマット                           | 例                                            |
| ------------------------------------------ | ---------------------------------------------------------- | --------------------------------------------- |
| LocalDate                                  | yyyyMMdd / yyyy-MM-dd                                      | 20250131 / 2025-01-31                         |
| LocalTime                                  | HH:mm / HH:mm:ss / HH:mm:ss.S…（小数1〜9桁）               | 12:34 / 12:34:56 / 12:34:56.789               |
|                                            | HHmm / HHmmss / HHmmssS…（小数1〜9桁, 区切りなし）         | 1234 / 123456 / 123456789                     |
| LocalDateTime/OffsetDateTime/ZonedDateTime | yyyy-MM-dd'T'HH:mm:ss / yyyy-MM-dd'T'HH:mm:ss.S…（1〜9桁） | 2025-01-31T12:34:56 / 2025-01-31T12:34:56.789 |
|                                            | yyyyMMddHHmmss                                             | 20250131123456                                |
|                                            | yyyyMMddHHmmssSSS（ミリ秒）                                | 20250131123456789                             |
|                                            | yyyyMMddHHmmssSSSSSS（マイクロ秒）                         | 20250131123456789012                          |
|                                            | yyyyMMddHHmmssSSSSSSSSS（ナノ秒）                          | 20250131123456789012345                       |
| Year                                       | 数値文字列（yyyy）                                         | 2025                                          |
| YearMonth                                  | 数値文字列（yyyyMM）                                       | 202501                                        |
| MonthDay                                   | 数値文字列（MMdd）                                         | 0131                                          |
| Month                                      | 数値文字列（1〜12）                                        | 1 / 12                                        |
| DayOfWeek                                  | 数値文字列（1〜7）                                         | 1（月）〜7（日）                              |
| Era                                        | 数値文字列（実装依存のコード）                             | 例：日本暦のJapaneseEra.of(1) = SHOWA など    |

#### 使用例

```java
// 検索結果格納用Beanクラス
public class ResultBean {
    private LocalDateTime eventDate;  // 検索結果の Timestampカラムの値がLocalDateTimeに変換されて設定
    // ...
}
List<ResultBean> results = agent.query("example/select_by_date")
    .param("targetDate", LocalDateTime.now()) // LocalDateTimeをバインドパラメータとして使用
    .collect(ResultBean.class);

```

### ToStringParameterMapper

古いシステムでは、日付型や日時型の値を `20250131`（`yyyyMMdd`形式）や `20250131123456`（`yyyyMMddHHmmss`形式）といった文字列として格納することがあります。\
このようなケースに対応するため **uroboroSQL** では日付型や日時型のバインドパラメータを文字列に変換するBindParameterMapperを標準で提供しています。

`ToStringParameterMapper` には以下の種類があります。

| Mapper名                             | 対象Java型                                 | 説明                                                 |
| ------------------------------------ | ------------------------------------------ | ---------------------------------------------------- |
| **DateToStringParameterMapper**      | java.util.Date                             | yyyyMMdd形式の文字列に変換                           |
| **LocalDateToStringParameterMapper** | java.time.LocalDate                        | yyyyMMdd形式の文字列に変換                           |
| **TimeToStringParameterMapper**      | LocalTime/OffsetTime                       | HHmmss形式の文字列に変換                             |
| **DateTimeToStringParameterMapper**  | LocalDateTime/OffsetDateTime/ZonedDateTime | yyyyMMddHHmmssSSS形式の文字列に変換                  |
| **SqlTimeToStringParameterMapper**   | java.sql.Time                              | HHmmss形式の文字列に変換                             |
| **YearToStringParameterMapper**      | java.time.Year                             | yyyy形式の文字列に変換                               |
| **YearMonthToStringParameterMapper** | java.time.YearMonth                        | yyyyMM形式の文字列に変換                             |
| **MonthDayToStringParameterMapper**  | java.time.MonthDay                         | MMdd形式の文字列に変換                               |
| **MonthToStringParameterMapper**     | java.time.Month                            | MM形式（01〜12）の文字列に変換                       |
| **DayOfWeekToStringParameterMapper** | java.time.DayOfWeek                        | 数字形式（1（月曜日）から7（日曜日））の文字列に変換 |

`ToStringParameterMapper` を有効にする場合、後述する[ユーザ定義Mapperの登録](#ユーザ定義mapperの登録) で `ToStringParameterMapper` の登録を行ってください。

::: tip
**JDBC → Java変換** では `DateTimeApiPropertyMapper` が 文字列型から日付型や日時型への変換に対応しているため、ユーザ定義PropertyMapperの登録は不要です
:::

### EmptyStringToNullParameterMapper

データベースによって `NULL` と `空文字（""）` の扱いが異なります。

* **`NULL` と `空文字` を区別する** ： PostgreSQL、MySQL、SQL Server
* **`空文字` を `NULL` として扱う** ： Oracle

`EmptyStringToNullParameterMapper` を使用するとバインドパラメータとして空文字列が設定された際、それを自動的に `NULL` に変換することができます。
これにより、データベース間の差異を吸収し、一貫した動作を実現できます。

#### 使用例

```java
// EmptyStringToNullParameterMapperを登録
config.getExecutionContextProvider()
  .addBindParameterMapper(new EmptyStringToNullParameterMapper());

// 空文字列がnullに変換される
agent.update("user/update_user")
  .param("middleName", "")  // 内部的にnullとしてバインドされる
  .count();
```

::: warning 注意
`EmptyStringToNullParameterMapper` は標準では登録されていません。必要に応じて[ユーザ定義Mapperの登録](#ユーザ定義mapperの登録)で登録してください。
:::

### EnumParameterMapper / EnumPropertyMapper

Enum型とデータベース値の相互変換を行います。

#### 使用例

```java
public enum Status {
    ACTIVE("01"), INACTIVE("02"), DELETED("03");

    private final String code;

    private Status(String code) {
      this.code = code;
    }

    @Override
    public String toString() {
      return code;
    }
}

// 検索結果を格納するBean
public class User {
    private Status status;  // "01"という文字列をStatus#toString()と比較し、一致するStatus.ACTIVEに変換される
    // ...
}

// バインドパラメータとして使用
List<User> users = agent.query("user/select_by_status")
    .param("status", Status.ACTIVE)  // "01"という文字列としてバインドされる
    .collect(User.class);
```

### DomainParameterMapper / DomainPropertyMapper

`@Domain`アノテーションが付いたドメインオブジェクトの変換を行います。
::: tip
@Domain アノテーションの記述方法については [Entityアノテーション > @Domain](../basics/entity-api.md#domain) を参照してください。
:::

#### 使用例

```java
// ドメインオブジェクトの定義
@Domain(valueType = String.class)
public class UserId {
    private final String value;

    public UserId(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}

// 検索結果を格納するBean
public class User {
    private UserId userId;  // VARCHAR値がUserIdオブジェクトに変換される
    // ...
}

// バインドパラメータとして使用
List<User> users = agent.query("user/select_by_user_id")
    .param("userId", new UserId("USER001"))  // 内部的に"USER001"がバインドされる
    .collect(User.class);
```

### OptionalParameterMapper / OptionalIntParameterMapper / OptionalLongParameterMapper / OptionalDoubleParameterMapper / OptionalPropertyMapper / OptionalIntPropertyMapper / OptionalLongPropertyMapper / OptionalDoublePropertyMapper

`Optional`型 / `OptionalInt`型 / `OptionalLong`型 / `OptionalDouble`型 とnull値の相互変換を行います。

#### 使用例

```java
// 検索結果を格納するBean
public class User {
    private Optional<String> middleName;  // NULLならOptional.empty()、値があればOptional.of(値)
    // ...
}

List<User> users = null;

// バインドパラメータとして使用
Optional<String> optionalName = Optional.of("John");
users = agent.query("user/select_by_name")
    .param("name", optionalName)  // "John"がバインドされる
    .collect(User.class);

Optional<String> emptyName = Optional.empty();
users = agent.query("user/select_by_name")
    .param("name", emptyName)  // nullがバインドされる
    .collect(User.class);
```

## ユーザ定義Mapperの作成

以下のように独自の型を作成し、この型に対して独自の型変換が必要な場合、ユーザ定義Mapperを作成することができます。

```java
// 電話番号型
public class PhoneNumber {
    private String countryCode;
    private String number;

    public String toFullNumber() {
        return countryCode + "-" + number;
    }
}
```

### ユーザ定義BindParameterMapperの作成

```java
// ユーザ定義BindParameterMapper
public class PhoneNumberParameterMapper implements BindParameterMapper<PhoneNumber> {

    @Override
    public Class<PhoneNumber> targetType() {
        return PhoneNumber.class;
    }

    @Override
    public Object toJdbc(PhoneNumber original, Connection connection, BindParameterMapperManager parameterMapperManager) {
        if (original == null) {
            return null;
        }
        return original.toFullNumber();  // 文字列に変換
    }
}
```

### ユーザ定義PropertyMapperの作成

```java
// ユーザ定義PropertyMapper
public class PhoneNumberPropertyMapper implements PropertyMapper<PhoneNumber> {
    @Override
    public boolean canAccept(Class<?> type) {
        return PhoneNumber.class.equals(type);
    }

    @Override
    public PhoneNumber getValue(JavaType type, ResultSet rs, int columnIndex, PropertyMapperManager mapperManager) throws SQLException {
        String fullNumber = rs.getString(columnIndex);
        if (fullNumber == null) {
            return null;
        }
        // 文字列をパースしてPhoneNumberオブジェクトを生成
        String[] parts = fullNumber.split("-");
        return new PhoneNumber(parts[0], parts[1]);
    }
}
```

## ユーザ定義Mapperの登録

ユーザ定義Mapperの登録は、以下のいずれかの方法で行います。

### 1. ServiceLoaderを使用した自動登録

`META-INF/services`ディレクトリに以下のファイルを作成することで、自動的にMapperが登録されます。

**BindParameterMapperの登録**

ファイル名: `META-INF/services/jp.co.future.uroborosql.parameter.mapper.BindParameterMapper`

```
com.example.mapper.PhoneNumberParameterMapper
```

**PropertyMapperの登録**

ファイル名: `META-INF/services/jp.co.future.uroborosql.mapping.mapper.PropertyMapper`

```
com.example.mapper.PhoneNumberPropertyMapper
```

### 2. SqlConfig生成時に登録

```java
SqlConfig config = UroboroSQL.builder("jdbc:h2:mem:test", "sa", "")
    .build();

// BindParameterMapperの登録
config.getExecutionContextProvider()
    .addBindParameterMapper(new PhoneNumberParameterMapper());

// PropertyMapperの登録
config.getEntityHandler()
    .addPropertyMapper(new PhoneNumberPropertyMapper());
```

---

---
url: /uroborosql-doc/license.md
---

# License

MIT License

Copyright (c) 2018

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

---
url: /uroborosql-doc/advanced/in-transaction-exception-handling.md
---

# PostgreSQLのトランザクション内SQLエラー対応

PostgreSQLでは、１つのトランザクション内でSQLエラーが発生した場合、後続するSQL文はすべて無条件でエラーとなります。\
この状態はトランザクションに対して`commit`もしくは`rollback`を実行するまで続きます。

::: warning
エラーが発生している状態で`commit`を実行しても実際には`rollback`されます
:::

これはPostgreSQL固有の動作であり、通常は問題ない動作なのですが、テーブルロックエラーなどリトライ処理を行うケースで問題になります。\
（SQLのリトライについては[SQL実行のリトライ](../configuration/sql-agent-provider.md#sql実行のリトライ-sqlagentprovider-setsqlretrycodelist-setdefaultmaxretrycount-setdefaultsqlretrywaittime)を参照）\
**uroboroSQL**ではリトライ指定のあるSQL実行、かつ、PostgreSQL（より正確には`Dialect#isRollbackToSavepointBeforeRetry()`が`true`の場合）の場合にsavepointを用いた部分ロールバックを行うことでこの問題に対応しています。\
具体的にはリトライ指定のあるSQL実行、かつ、PostgreSQLの場合はSQL実行の直前にリトライ用のsavepointを設定し、SQL実行が成功すればsavepointの解放、SQL実行が失敗した場合はリトライ用のsavepointまでロールバックを行います。

::: tip
リトライ指定のないSQL実行の場合はsavepointの設定は行われません。
:::

リトライ指定のないSQLで上記と同様の動作を行う場合はsavepointScopeを利用して以下のように実装してください。

```java
agent.required(() -> { // トランザクション開始
  agent.savepointScope(() -> {
    // savepointScopeの開始
    agent.update("example/insert_product")
      .param("productId", 1)
      .count();
  });
  agent.savepointScope(() -> {
    // 後続処理
    int count = agent.update("department/insert_department")
      .param("deptNo", 1)
      .param("deptName", "Sales")
      .count();
      ・・・
  });
});
```

---

---
url: /uroborosql-doc/getting_started/sql-repl.md
---

# SQL-REPL

ここまではJavaアプリケーションから**uroboroSQL**を利用する場合の説明でした。
**uroboroSQL**にはもう一つ特徴的な機能として、SQLを対話しながら実行するための **REPL(Read-Eval-Print Loop)** 機能を提供しています。

今度はこの**REPL**機能を利用してみましょう。

## REPLの利用

**REPL**を起動するためには`jp.co.future.uroborosql.client.SqlREPL`クラスを実行する必要があります。
サンプルアプリケーションで`SqlREPL`クラスを実行するためには以下のコマンドを実行します。

```sh
mvn -PREPL
```

実行すると以下のようにタイトル表示とコマンド説明、設定値の情報が表示され、そのあとコマンド入力状態になります。

```sh
===========================================================
                 _                    ____   ___  _
 _   _ _ __ ___ | |__   ___  _ __ ___/ ___| / _ \| |
| | | | '__/ _ \| '_ \ / _ \| '__/ _ \___ \| | | | |
| |_| | | | (_) | |_) | (_) | | | (_) |__) | |_| | |___
 \__,_|_|  \___/|_.__/ \___/|_|  \___/____/ \__\_\_____|

uroboroSQL SQL REPL ver.1.0.10
===========================================================

Commands :
        query   : execute query from loaded sql file.
                ex1) query [sql file name]<Enter> : Execute SQL without parameter.
                ex2) query [sql file name] param1=val1 param2=val2 ...<Enter> : Execute SQL with the specified parameters.
        update  : execute update from loaded sql file.
                ex1) update [sql file name]<Enter> : Execute SQL without parameter.
                ex2) update [sql file name] param1=val1 param2=val2 ...<Enter> : Execute SQL with the specified parameters.
        view    : view sql file.
                ex) view [sql file name]<Enter> : Show sql file contents.
        list    : list loaded sql files.
                ex1) list<Enter> : Show all loaded sql file(s).
                ex2) list keyword<Enter> : Show loaded sql file(s) filter by keyword.
        history : list command history.
                ex1) history<Enter> : Show all command history.
                ex2) history keyword<Enter> : Show command history filter by keyword.
        driver  : list loaded drivers.
        desc    : describe table.
                ex) desc [table name]<Enter> : Show table description.
        generate: generate sql to access the table.
                ex) generate [select/insert/update/delete] [table name]<Enter> : Show sql to access tables according to keywords.
        parse   : parse sql file.
                ex) parse [sql file name]<Enter> : Parse sql file.
        cls     : clear screen.
        exit    : exit SQL REPL. `CTRL+C` is an alias.
Properties file path:REPL\repl.properties
[Properties]
db.user=sa
db.password=
db.url=jdbc:h2:file:./target/db/repldb;

initialize.
uroborosql >
```

**REPL**を立ち上げた状態では接続したDB（H2DB メモリDB）には何もない状態なので、まずはテーブルを作成します。
サンプルアプリケーションで利用できるSQLファイルを確認しましょう。

```sh
uroborosql > list[Enter]
```

と入力してください。

```sh
uroborosql > list
LIST:
ddl/create_tables
department/insert_department
department/select_department
employee/insert_employee
employee/select_employee
employee/update_employee
relation/insert_dept_emp
relation/select_dept_emp
setup/insert_data
uroborosql >
```

ロード済みのSQLファイルの`SQL名`がわかります。
テーブルを作成するために`ddl/create_tables`を実行します。
`ddl/create_tables`はDDLなので実行するためには`update`コマンドを使用します。

```sh
uroborosql > u[Tab]
```

と入力してください。

```sh
uroborosql > update
```

という風に`u`に一致するコマンドがコード補完されます。
::: tip
**REPL**では`[Tab]`を押下することでコマンドや`SQL名`、バインドパラメータなどが必要に応じでコード補完されます。
:::

続いて

```sh
uroborosql > update d[Tab]
```

と入力してください。\
今度は`ddl`に一致する`SQL名`の候補が表示されます。

```sh
uroborosql > update d
ddl/create_tables   department/insert_department   department/select_department
```

この状態で`[Tab]`を入力することで候補を選択することが出来ます。\
`ddl/create_tables`を選択して`[Enter]`を入力すると以下のようになります。

```sh
uroborosql > update ddl/create_tables
```

もう一度`[Enter]`を入力するとSQLが実行されます。

```sql
uroborosql > update ddl/create_tables
[DEBUG] Executed SQL[
-- employee
drop table if exists employee cascade;
create table employee (
  emp_no number(6) auto_increment
  , first_name varchar(20) not null
  , last_name varchar(20) not null
  , birth_date date not null
  , gender char(1) not null
  , lock_version number(10) not null default 0
  , constraint employee_PKC primary key (emp_no)
) ;
-- dept_emp
drop table if exists dept_emp cascade;
create table dept_emp (
  emp_no number(6) not null
  , dept_no number(4) not null
  , constraint dept_emp_PKC primary key (emp_no,dept_no)
) ;
-- department
drop table if exists department cascade;
create table department (
  dept_no number(4) auto_increment
  , dept_name varchar(100) not null
  , lock_version number(10) not null default 0
  , constraint department_PKC primary key (dept_no)
) ;
comment on table employee is 'employee';
comment on column employee.emp_no is 'emp_no';
comment on column employee.first_name is 'first_name';
comment on column employee.last_name is 'last_name';
comment on column employee.birth_date is 'birth_date';
comment on column employee.gender is 'gender     ''F''emale/''M''ale/''O''ther';
comment on column employee.lock_version is 'lock_version';
comment on table dept_emp is 'dept_emp';
comment on column dept_emp.emp_no is 'emp_no';
comment on column dept_emp.dept_no is 'dept_no';
comment on table department is 'department';
comment on column department.dept_no is 'dept_no';
comment on column department.dept_name is 'dept_name';
comment on column department.lock_version is 'lock_version'
]
[DEBUG] Execute update SQL.
[DEBUG] SQL execution time [ddl/create_tables] : [00:00:00.030]
update sql[ddl/create_tables] end. row count=0
uroborosql >

```

`ddl/create_tables`が実行され、DBにテーブルが作成されました。

では次に作成されたテーブルの定義情報を確認します。\
テーブル定義情報の確認には`desc`コマンドを使用します。
ここでは`EMPLOYEE`テーブルの定義情報を確認してみましょう。

```sh
uroborosql > desc EMPLOYEE[Enter]
```

```sql
uroborosql > desc EMPLOYEE
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|TABLE_NAME|COLUMN_NAME |TYPE_NAME|COLUMN_SIZE|DECIMAL_DIGITS|IS_NULLABLE|COLUMN_DEF                                                                      |REMARKS                        |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|EMPLOYEE  |EMP_NO      |DECIMAL  |          6|             0|NO         |(NEXT VALUE FOR "PUBLIC"."SYSTEM_SEQUENCE_D06A5524_EC18_4835_A536_1F5A372BFC73")|emp_no                         |
|EMPLOYEE  |FIRST_NAME  |VARCHAR  |         20|             0|NO         |                                                                                |first_name                     |
|EMPLOYEE  |LAST_NAME   |VARCHAR  |         20|             0|NO         |                                                                                |last_name                      |
|EMPLOYEE  |BIRTH_DATE  |DATE     |         10|             0|NO         |                                                                                |birth_date                     |
|EMPLOYEE  |GENDER      |CHAR     |          1|             0|NO         |                                                                                |gender        'F'emale/'M'ale/'O'ther|
|EMPLOYEE  |LOCK_VERSION|DECIMAL  |         10|             0|NO         |                                                                               0|lock_version                   |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
uroborosql >
```

EMPLOYEEテーブルの定義情報が表形式で表示されました。

続いて初期データを投入しましょう。

`setup/insert_data`を実行します。

```sh
uroborosql > update setup/insert_data[Enter]
```

```sql
uroborosql > update setup/insert_data
[DEBUG] Executed SQL[
insert into department (dept_name) values ('sales');
insert into department (dept_name) values ('export');
insert into department (dept_name) values ('accounting');
insert into department (dept_name) values ('personnel');
insert into employee (first_name, last_name, birth_date, gender) values ('Bob', 'Smith', '1970-01-02', 'M');
insert into employee (first_name, last_name, birth_date, gender) values ('Susan', 'Davis', '1969-02-10', 'F');
insert into employee (first_name, last_name, birth_date, gender) values ('John', 'Wilson', '1982-05-08', 'M');
insert into employee (first_name, last_name, birth_date, gender) values ('Sharon', 'Johnson', '1990-01-20', 'F');
insert into employee (first_name, last_name, birth_date, gender) values ('Stephen', 'Taylor', '2003-12-31', 'M');
insert into dept_emp (emp_no, dept_no) values (1, 1);
insert into dept_emp (emp_no, dept_no) values (2, 1);
insert into dept_emp (emp_no, dept_no) values (3, 2);
insert into dept_emp (emp_no, dept_no) values (4, 3);
insert into dept_emp (emp_no, dept_no) values (5, 4)
]
[DEBUG] Execute update SQL.
[DEBUG] SQL execution time [setup/insert_data] : [00:00:00.017]
update sql[setup/insert_data] end. row count=1
uroborosql >
```

これでテーブルに初期データが挿入されました。
では、挿入したデータを検索してみましょう。

検索を行う前に、検索を行うSQLの内容を確認してみましょう。\
SQLの内容を確認するには`view`コマンドを使用します。

```sh
uroborosql > view department/select_department[Enter]
```

```sql
uroborosql > view department/select_department
select /* _SQL_ID_ */
        dept.dept_no            as      dept_no
,       dept.dept_name          as      dept_name
,       dept.lock_version       as      lock_version
from
        department      dept
/*BEGIN*/
where
/*IF SF.isNotEmpty(deptNo)*/
and     dept.dept_no    =       /*deptNo*/1
/*END*/
/*IF SF.isNotEmpty(deptName)*/
and     dept.dept_name  =       /*deptName*/'sample'
/*END*/
/*END*/
uroborosql >
```

検索を行う場合は`query`コマンドを使用します。
`query`の後に実行する`SQL名`を指定します。

```sh
uroborosql > query department/select_department[Enter]
```

```sql
uroborosql > query department/select_department
[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptNo)], Result:[false], Parameter:[deptNo:[null]]
[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptName)], Result:[false], Parameter:[deptName:[null]]
[DEBUG] Executed SQL[
select /* department/select_department */
        dept.dept_no            as      dept_no
,       dept.dept_name          as      dept_name
,       dept.lock_version       as      lock_version
from
        department      dept

]
[DEBUG] Execute search SQL.
[INFO ]
+-------+----------+------------+
|DEPT_NO|DEPT_NAME |LOCK_VERSION|
+-------+----------+------------+
|      1|sales     |           0|
|      2|export    |           0|
|      3|accounting|           0|
|      4|personnel |           0|
+-------+----------+------------+
[DEBUG] SQL execution time [department/select_department] : [00:00:00.078]
query sql[department/select_department] end.
uroborosql >
```

ここではバインドパラメータを指定しなかったため、絞込み条件のないSQLが実行され検索結果として4件のデータが取得できました。

**REPL**では上の結果のように、

* 実行するSQL
* バインドパラメータ
* SQL文の中の評価式とその評価結果
* 検索結果
* 実行時間

が表示されるので、SQLがどういう風に実行され、どういう値が取得できるのかが良く分かるようになっています。

次にバインドパラメータを指定して検索してみましょう。

検索するSQLにどのようなバインドパラメータや条件分岐があるかを確認するには`parse`コマンドを使用します。

```sh
uroborosql > parse department/select_department[Enter]
```

```sql
uroborosql > parse department/select_department
PARSE:

SQL :
select /* _SQL_ID_ */
        dept.dept_no            as      dept_no
,       dept.dept_name          as      dept_name
,       dept.lock_version       as      lock_version
from
        department      dept
/*BEGIN*/
where
/*IF SF.isNotEmpty(deptNo)*/
and     dept.dept_no    =       /*deptNo*/1
/*END*/
/*IF SF.isNotEmpty(deptName)*/
and     dept.dept_name  =       /*deptName*/'sample'
/*END*/
/*END*/

BRANCHES :
        BEGIN {
                IF ( SF.isNotEmpty(deptNo) ) {
                }
                IF ( SF.isNotEmpty(deptName) ) {
                }
        }

BIND_PARAMS :
        deptName
        deptNo
uroborosql >
```

`parse`コマンドの結果は以下のようになります。

* `SQL` : 解析対象のSQL
* `BRANCHES` : 条件分岐
* `BIND_PARAMS` : バインドパラメータ

条件分岐では `BEGIN`のスコープ（{}で囲まれた中）に２つのIF分岐が並んでいることがわかります。\
また、バインドパラメータでは `deptNo`と`deptName`があることがわかります。

`parse`コマンドで確認したバインドパラメータを指定して検索を行います。

```sh
uroborosql > query department/select_department deptNo=1[Enter]
```

```sql
uroborosql > query department/select_department deptNo=1
[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptNo)], Result:[true], Parameter:[deptNo:[1]]
[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptName)], Result:[false], Parameter:[deptName:[null]]
[DEBUG] Executed SQL[
select /* department/select_department */
        dept.dept_no            as      dept_no
,       dept.dept_name          as      dept_name
,       dept.lock_version       as      lock_version
from
        department      dept
where
dept.dept_no    =       ?/*deptNo*/

]
[DEBUG] Set the parameter.[INDEX[1], Parameter name[deptNo], Value[1], Class[Integer]]
[DEBUG] Execute search SQL.
[INFO ]
+-------+---------+------------+
|DEPT_NO|DEPT_NAME|LOCK_VERSION|
+-------+---------+------------+
|      1|sales    |           0|
+-------+---------+------------+
[DEBUG] SQL execution time [department/select_department] : [00:00:00.005]
query sql[department/select_department] end.
uroborosql >
```

`deptNo`に`1`を指定して検索しています。
この時、SQL文の評価式である/\*IF SF.isNotEmpty(deptNo)\*/が`true`となりSQLのwhere句に`dept_no`の条件が追加されバインドパラメータがバインドされます。\
その結果、検索結果は1件になっています。

このように`SQL名`の後ろに`バインドパラメータ名`=`値`という形でバインドパラメータを記述することでバインドパラメータを指定してSQLを実行することができます。

バインドパラメータが複数ある場合は`バインドパラメータ名1`=`値1` `バインドパラメータ名2`=`値2` ... という風に各パラメータの間を空白で区切って指定してください。

* バインドパラメータを複数指定する例

```sh
uroborosql > query department/select_department deptNo=1 deptName=sales[Enter]
```

```sql
uroborosql > query department/select_department deptNo=1 deptName=sales
[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptNo)], Result:[true], Parameter:[deptNo:[1]]
[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptName)], Result:[true], Parameter:[deptName:[{115,97,108,101,115},0,0]]
[DEBUG] Executed SQL[
select /* department/select_department */
        dept.dept_no            as      dept_no
,       dept.dept_name          as      dept_name
,       dept.lock_version       as      lock_version
from
        department      dept
where
dept.dept_no    =       ?/*deptNo*/
and     dept.dept_name  =       ?/*deptName*/

]
[DEBUG] Set the parameter.[INDEX[1], Parameter name[deptNo], Value[1], Class[Integer]]
[DEBUG] Set the parameter.[INDEX[2], Parameter name[deptName], Value[sales], Class[String]]
[DEBUG] Execute search SQL.
[INFO ]
+-------+---------+------------+
|DEPT_NO|DEPT_NAME|LOCK_VERSION|
+-------+---------+------------+
|      1|sales    |           0|
+-------+---------+------------+
[DEBUG] SQL execution time [department/select_department] : [00:00:00.006]
query sql[department/select_department] end.
uroborosql >
```

**REPL**を終了する場合はコマンド`quit`,もしくは`exit`を入力してください。

```sh
uroborosql > quit[Enter]
SQL REPL end.
```

終了メッセージが表示されてREPLが終了します。

**REPL**には他にも以下のコマンドがあります。

| コマンド | 説明                                                                          |
| :------- | :---------------------------------------------------------------------------- |
| query    | 検索SQLを実行します                                                           |
| update   | 更新SQL（insert/update/delete）やDDLを実行します                              |
| view     | SQL名で指定したSQLの内容を表示します                                          |
| list     | 使用可能なSQL名の一覧を表示します                                             |
| history  | 実行したコマンドの履歴を表示します                                            |
| driver   | 使用可能なJDBCドライバーの一覧を表示します                                    |
| desc     | 指定したテーブルの定義情報を表示します                                        |
| generate | 指定したテーブルに対するselect/insert/update/deleteを行うSQLを生成します      |
| parse    | 指定したSQLで使用されているバインドパラメータやIF分岐条件を抽出して表示します |
| cls      | コンソール画面のクリア                                                        |
| exit     | REPLを終了します                                                              |
| help     | 利用できるコマンドの説明を表示します                                          |

## REPLの設定

さて、ここまでREPLの操作を説明してきましたが、DB接続情報やSQLファイルの場所はどこで指定していたのでしょうか。
実は`jp.co.future.uroborosql.client.SqlREPL`を実行する際、引数としてプロパティファイルを指定します。このプロパティファイルにDB接続情報やSQLファイルの場所などREPLを実行するのに必要な情報が記載されています。

pom.xmlのREPL実行部分

```xml
<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>exec-maven-plugin</artifactId>
  <executions>
    <execution>
      <id>repl</id>
      <goals>
        <goal>java</goal>
      </goals>
      <configuration>
        <workingDirectory>${basedir}</workingDirectory>
        <mainClass>jp.co.future.uroborosql.client.SqlREPL</mainClass>
        <arguments>
          <argument>REPL/repl.properties</argument>
        </arguments>
      </configuration>
      <phase>process-test-classes</phase>
    </execution>
  </executions>
</plugin>
```

初期設定ではプロパティファイルの場所は`REPL/repl.properties`になっています。

* REPL/repl.properties

```properties
db.url=jdbc:h2:file:./target/db/repldb;
db.user=sa
db.password=

sql.additionalClassPath=${user.home}/.m2/repository/com/h2database/h2/1.4.192/h2-1.4.192.jar
```

| プロパティ名                                      | 説明                                                                                                                                                                                                                                                                                                      |
| :------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| db.url                                            | DB接続URL                                                                                                                                                                                                                                                                                                 |
| db.schema                                         | DB接続スキーマ                                                                                                                                                                                                                                                                                            |
| db.user                                           | DB接続ユーザ                                                                                                                                                                                                                                                                                              |
| db.password                                       | DB接続パスワード                                                                                                                                                                                                                                                                                          |
| sql.loadPath                                      | SQLをロードするパス。初期値は`sql`                                                                                                                                                                                                                                                                        |
| sql.encoding                                      | SQLファイルのエンコーディング。初期値は`UTF-8`                                                                                                                                                                                                                                                            |
| sql.fileExtension                                 | ロードするSQLファイルの拡張子。初期値は`.sql`                                                                                                                                                                                                                                                             |
| sql.detectChanges                                 | SQLファイルの変更検知を行うかどうか。初期値は`true`                                                                                                                                                                                                                                                       |
| sql.additionalClassPath                           | **REPL**起動時に起動時クラスパス以外でクラスパスに追加する場所。`;`で区切ることで複数指定可。SQLファイルのルート（sqlフォルダの親フォルダ）をクラスパスに追加することで、自動的にSQLファイルがロードされます。合わせて接続するDBのJDBCドライバを含むJarを指定することで動的にJDBCドライバを読み込みます。 |
| executionContextProvider.constantClassNames       | ExecutionContextProviderに登録する定数クラスを指定。`,`で区切ることで複数指定可。 ex) jp.co.future.uroborosql.context.test.TestConsts                                                                                                                                                                     |
| executionContextProvider.enumConstantPackageNames | ExecutionContextProviderに登録するEnum定数パッケージ名を指定。`,`で区切ることで複数指定可。ex) jp.co.future.uroborosql.context.test                                                                                                                                                                       |

このプロパティファイルを変更することでいろいろなDBに接続することができるようになります。

これまで見てきたように**REPL**を利用することで簡単にSQL実行や動作確認ができるので、SQL開発には欠かせないツールになります。
色々なSQLを記述して**REPL**で試してみてください。

これで *Getting Started* は終了です。

**uroboroSQL**で使用するSQLの文法や基本的な操作については[基本操作](../basics/index.md)を参照してください。

---

---
url: /uroborosql-doc/configuration/sql-agent-provider.md
---

# SqlAgentProvider

SQL実行を行うクラスである`SqlAgent`を生成するプロバイダークラスです。SQL実行時の挙動を変更するための初期値の設定が行えます。

::: tip クラス名の変更
uroborosql v1.x で SqlAgentFactory から SqlAgentProviderにクラス名が変更されました。
:::

設定例

```java
SqlConfig config = UroboroSQL.builder(...)
    // SqlAgentProviderの設定
    .setSqlAgentProvider(new SqlAgentProviderImpl()
    // JDBCフェッチサイズ
    .setFetchSize(1000)
    // Statementオブジェクトの検索タイムアウト時間(s)
    .setQueryTimeout(10)
    // 例外発生時のログ出力を行うかどうか
    .setOutputExceptionLog(true)
    // SQL_IDの置換文字列
    .setSqlIdKeyName("_SQL_ID_")
    // 検索結果を格納するMapのキー変換に使用するCaseFormatの初期値
    .setDefaultMapKeyCaseFormat(CaseFormat.UPPER_SNAKE_CASE)
    // 複数件挿入時の挿入方法の初期値
    .setDefaultInsertsType(InsertsType.BATCH)
    // アプリケーション全体のリトライ設定
    // SQLエラーコードが54,30006のいずれか(Oracleのリソース・ビジー)の場合
    .setSqlRetryCodeList(Arrays.asList("54", "30006"))
    // 最大リトライ回数
    .setDefaultMaxRetryCount(3)
    // リトライ間隔
    .setDefaultSqlRetryWaitTime(10)
    // トランザクション内での更新を強制するかどうか
    .setForceUpdateWithinTransaction(true)
    // 明示的な行ロック時の待機時間(s)デフォルト値
    .setDefaultForUpdateWaitSeconds(10)
    // データベースがサポートする ForUpdateの種類の指定を厳格に扱うかどうか
    .setStrictForUpdateType(false)
    )
  ).build();
```

## フェッチサイズと検索タイムアウト設定 ( `SqlAgentProvider#setFetchSize` /`#setQueryTimeout` )

`SqlAgent`で検索処理を行う際、データベースから一度に取得する行数（`fetchSize`）や
検索タイムアウト時間（秒）（`queryTimeout`）の初期値を指定することが出来ます。
指定しない場合`fetchSize`, `queryTimeout`ともに`-1`が設定されます。

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // JDBCフェッチサイズ
    .setFetchSize(1000)
    // Statementオブジェクトの検索タイムアウト時間(s)
    .setQueryTimeout(10)
  ).build();
```

::: warning 補足
`fetchSize`は、[Statement.setFetchSize](https://docs.oracle.com/javase/jp/8/docs/api/java/sql/Statement.html#setFetchSize-int-)に渡される値で、パフォーマンスに影響します。\
JDBCクライアント（uroborosqlを使用しているJavaアプリケーション）ではDBサーバ側で実行されたSELECTの結果セットをfetchサイズで指定された行数ずつ分割して取得します。
そのため結果行数に対して`fetchSize`が小さいと、JDBCクライアント <-> DBサーバ間の通信回数が増大してパフォーマンスに悪影響を及ぼします。\
（例：select結果が10,000件、fetchSizeが100の場合、JDBCクライアント⇔DBサーバ間の通信は10,000÷100 = 100回行われる）
:::

::: danger 注意
`fetchSize`はcollect/foreachメソッドで返却される結果セットの行数を制限する設定ではありません。
:::

## 例外発生時のログ出力を行うかどうかを設定 ( `SqlAgentProvider#setOutputExceptionLog` )

SQL実行時にSQL例外が発生した場合に、発生した例外と実行したSQLの詳細情報を出力するかどうかを指定できます。
指定しない場合`false`になります。

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // 例外発生時のログ出力を行うかどうか
    .setOutputExceptionLog(true)
  ).build();
```

## SQL\_IDの置換文字列設定 ( `SqlAgentProvider#setSqlIdKeyName` )

SQL文に特定の置換文字列をSQLコメントとして記述することで、SQL実行時に実行したSQLの元となるSQLファイルを特定するための
情報（`SQL_ID`）を埋め込むことが出来ます。`SQL_ID`を埋め込むことでSQLログやDBのSQL履歴で実行されたSQLの元となるファイルを
特定しやすくなります。\
必要に応じてこの置換文字列は変更することが出来ます。
指定しない場合`_SQL_ID_`になります。

設定例

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // SQL_IDの置換文字列
    .setSqlIdKeyName("_SQL_ID_")
  ).build();
```

department/select\_department.sql

```sql
select /* _SQL_ID_ */  -- _SQL_ID_ がSQLファイルを特定するための情報の埋め込み先となる
  dept.dept_no      as  dept_no
, dept.dept_name    as  dept_name
, dept.lock_version as  lock_version
from
  department  dept
/*BEGIN*/
where
/*IF SF.isNotEmpty(deptNo)*/
and dept.dept_no  = /*deptNo*/1
/*END*/
/*IF SF.isNotEmpty(deptName)*/
and dept.dept_name  = /*deptName*/'sample'
/*END*/
/*END*/
```

SQL実行処理

```java
agent.query("department/select_department")
  .param("deptNo", 1)
  .collect();
```

実行されるSQL

```sql
select /* department/select_department */  -- _SQL_ID_ にSQL名（department/select_department）が設定される
  dept.dept_no      as  dept_no
, dept.dept_name    as  dept_name
, dept.lock_version as  lock_version
from
  department  dept
where
  dept.dept_no  = 1/*deptNo*/
```

## CaseFormatの初期値設定 ( `SqlAgentProvider#setDefaultMapKeyCaseFormat` )

SQLによる検索で、以下のメソッドを使用して`List<Map<String, Object>>`や`Map<String, Object>`を取得する際、
取得したMapのキー名に対する書式の初期値を指定することが出来ます。
指定しない場合`CaseFormat.UPPER_SNAKE_CASE`になります。

| 対象メソッド         | 戻り値の型                    |
| :------------------- | :---------------------------- |
| SqlQuery#collect()   | List\<Map\<String, Object>>     |
| SqlQuery#findFirst() | Optional\<Map\<String, Object>> |
| SqlQuery#first()     | Map\<String, Object>           |
| SqlQuery#stream()    | Stream\<Map\<String, Object>>   |

指定しない場合（初期設定：`CaseFormat.UPPER_SNAKE_CASE`）

```java
agent.query("department/select_department")
  .collect();

// 結果(departments) キーがUPPER_SNAKE_CASEとなっている
[
 {"DEPT_NO"=1, "DEPT_NAME"="sales"},
 {"DEPT_NO"=2, "DEPT_NAME"="export"},
 {"DEPT_NO"=3, "DEPT_NAME"="accounting"},
 {"DEPT_NO"=4, "DEPT_NAME"="personnel"}
]
```

`CaseFormat.CAMEL_CASE`を初期値として設定

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // 検索結果を格納するMapのキー変換に使用するCaseFormatの初期値
    .setDefaultMapKeyCaseFormat(CaseFormat.CAMEL_CASE)
  ).build();
```

```java
agent.query("department/select_department")
  .collect();

// 結果(departments) キーがCAMEL_CASEとなっている
[
 {"deptNo"=1, "deptName"="sales"},
 {"deptNo"=2, "deptName"="export"},
 {"deptNo"=3, "deptName"="accounting"},
 {"deptNo"=4, "deptName"="personnel"}
]
```

## 複数件挿入時の挿入方法の初期値設定 ( `SqlAgentProvider#setDefaultInsertsType` )

`SqlAgent#inserts()`メソッドで使用する[InsertsType](../basics/entity-api.md#挿入方法（insertstype）の指定)の初期値を設定することが出来ます。
指定しない場合`InsertsType.BATCH`になります。

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // 複数件挿入時の挿入方法の初期値
    .setDefaultInsertsType(InsertsType.BATCH)
  ).build();
```

## SQL実行のリトライ ( `SqlAgentProvider#setSqlRetryCodeList` /`#setDefaultMaxRetryCount` /`#setDefaultSqlRetryWaitTime` )

SQLを実行した際、タイミングによって発生する例外（テーブルロックエラーなど）の場合はリトライを行い、
できるだけ正常に処理を終了させたい場合があります。\
通常、このようなケースでは以下のような実装を行います。

```java
String MAX_RETRY_COUNT = 3; // MAX_RETRY_COUNT はアプリケーションで定義された最大リトライ回数の定数とする
SqlConfig config = UroboroSQL.builder(...).build();

int retryCount = 0;
for(;;) {
  try (SqlAgent agent = config.agent()) {
    // INSERT文の実行
    // insert into product (product_id) values (/*productId*/0);
    agent.update("example/insert_product")
      .param("productId", 1)
      .count();
    break;
  } catch (UroborosqlSQLException ex) {
    // SQLExceptionが発生した際に行う処理を実装
    int errorCode = ex.getErrorCode();
    if (errorCode == 30006 || errorCode == 54) {// リソース・ビジー(Oracleの場合)
      // リトライ対象エラーコードの場合はリトライカウントをカウントアップしてリトライする
      retryCount++;
      if (retryCount == MAX_RETRY_COUNT) {
        // 最大リトライ回数に達した場合は例外をスローする
        throw ex;
      } else {
        try {
          // 10ms 待機
          Thread.sleep(10);
        } catch (InterruptedException iex) {
          // do nothing
        }
      }
    } else {
      // リトライ対象エラーコード以外はすぐに例外をスローする
      throw ex;
    }
  }
}
```

しかし、上記のようなリトライ処理を個々の実装で行うと、
実装漏れや実装ミス、実装方法の差異（for()の代わりにwhile()を使用するなど）により不具合が発生しやすくなります。\
**uroboroSQL**では、アプリケーション全体のリトライ設定と、全体設定より優先される個別処理でのリトライ用APIの
2種類のAPIを提供することで、より簡潔で確実なリトライ処理が行えるよう工夫されています。\
アプリケーション全体のリトライ設定は`SqlAgentProvider`生成時に行います。

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // アプリケーション全体のリトライ設定
    // SQLエラーコードが54,30006のいずれか(Oracleのリソース・ビジー)の場合
    .setSqlRetryCodeList(Arrays.asList("54", "30006"))
    // 最大リトライ回数（3回）リトライ
    .setDefaultMaxRetryCount(3)
    // リトライ間隔10ms待機
    .setDefaultSqlRetryWaitTime(10)
  ).build();
```

リトライAPIを用いた実装は次のようになります。

```java
// アプリケーション全体のリトライ設定に従ってリトライを行う。（個別のリトライ指定なし）
try (SqlAgent agent = config.agent()) {
  // INSERT文の実行
  // insert into product (product_id) values (/*productId*/0);
  agent.update("example/insert_product")
    .param("productId", 1)
    .count();
}

// 個別にリトライ設定を上書きする（retry()を利用）
try (SqlAgent agent = config.agent()) {
  // INSERT文の実行
  // insert into product (product_id) values (/*productId*/0);
  // リトライ対象エラーコードの場合、5回のリトライを20ms間隔で行う
  agent.update("example/insert_product")
    .param("productId", 1)
    .retry(5, 20)
    .count();
}
```

## DB更新処理をトランザクション内のみに強制 ( `SqlAgentProvider#setForceUpdateWithinTransaction` )&#x20;

複数のDB更新処理をまとめて行う際、途中で例外が発生するとDBデータが不整合な状態になる場合があります。このようなデータ不整合を防ぐためには[トランザクション](../basics/transaction.md#トランザクション)を利用します。\
しかし、通常の設定ではトランザクションを開始しない状態でもDB更新処理を行うことが可能になっているため不具合に気付きにくいという問題があります。\
**uroboroSQL**ではトランザクションを開始していない状態でDB更新処理が行なわれた場合に例外をスローするオプションを提供しています。このオプションを使用することでDBデータの整合性を維持しやすくなります。

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // トランザクション内での更新を強制するかどうか
    .setForceUpdateWithinTransaction(true)
    )
  ).build();
```

`SqlAgentProvider#setForceUpdateWithinTransaction()`に`true`を指定することでトランザクションを開始していない状態でDB更新処理が行なわれた場合に`UroborosqlTransactionException`がスローされます。

```java
agent.required(() -> { // トランザクション開始
  // トランザクション内でのDB更新なのでOK
  agent.updateWith("insert into employee (emp_no) values (/*empNo*/1001)")
    .param("empNo", 1)
    .count();
  });
});　// トランザクション終了

// トランザクション外でのDB更新なので UroborosqlTransactionException がスローされる
agent.updateWith("insert into department (dept_no, dept_name) values (/*deptNo*/1111, /*deptName*/'Sales')")
  .param("deptNo", 2)
  .param("deptName", "export")
  .count();
```

## 明示的な行ロック時の待機時間(s)のデフォルト値設定 ( `SqlAgentProvider#setDefaultForUpdateWaitSeconds` )&#x20;

`SqlEntityQuery#forUpdateWait()`による明示的な行ロックをおこなう際の待機時間を指定することができます。

```java
SqlConfig config = UroboroSQL.builder(...)
  // SqlAgentProviderの設定
  .setSqlAgentProvider(new SqlAgentProviderImpl()
    // 明示的な行ロック時の待機時間(s)デフォルト値
    .setDefaultForUpdateWaitSeconds(10)
    )
  ).build();
```

待機時間の初期値を設定することで`SqlEntityQuery#forUpdateWait()`を発行する際に適用され、
待機時間を都度指定する必要がなくなります。\
`SqlEntityQuery#forUpdateWait(int)`を使って個別に待機時間を指定した場合は個別設定が優先されます。

## データベースがサポートする ForUpdateの種類の指定を厳格に扱うかどうか ( `SqlAgentProvider#setStrictForUpdateType` )

データベースによっては forUpdateNoWait をサポートしないものがあります。\
そのような場合に SqlQuery#forUpdateNoWait の呼び出しを許可するかどうかを指定します。

* 厳格な判定を行う（true）： forUpdateNoWaitをサポートしないデータベースで SqlQuery#forUpdateNoWait が呼び出された場合は `UroborosqlRuntimeException` がスローされます。
* 厳格な判定を行わない（false）：forUpdateNoWaitをサポートしないデータベースで SqlQuery#forUpdateNoWait が呼び出された場合は SqlQuery#forUpdate と同じ動作になります。（デフォルト）

---

---
url: /uroborosql-doc/configuration.md
---

# SqlConfigの生成

**uroboroSQL**ではSqlConfigを生成するタイミングで各種の設定を行うことによりライブラリの動作や実行されるSQLを変更することができます。

シンプルな設定

```java
// create SqlConfig H2DBのメモリDBに接続する
SqlConfig config = UroboroSQL
  .builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "")
  .build();
```

`UroboroSQL`ビルダー取得API（`UroboroSQL.UroboroSQLBuilder`）

| メソッド名                                                       | 説明                                                       |
| :--------------------------------------------------------------- | :--------------------------------------------------------- |
| builder()                                                        | DB接続設定を行っていないビルダーを取得                     |
| builder(Connection conn)                                         | 引数で指定したコネクションでDB接続するビルダーを取得       |
| builder(DataSource dataSource)                                   | 引数で指定したデータソースを使ってDB接続するビルダーを取得 |
| builder(String url, String user, String password)                | 引数で指定したDB接続情報を元にDB接続するビルダーを取得     |
| builder(String url, String user, String password, String schema) | 引数で指定したDB接続情報を元にDB接続するビルダーを取得     |

上記APIで取得した`UroboroSQL.UroboroSQLBuilder`に対して下記の設定クラスを設定することで、設定変更ができます。

| 設定するクラス                                                                        | 説明                                                                                                                                            |
| :------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------- |
| [ConnectionSupplier](./connection-supplier.md#connectionsupplier)                     | JDBCコネクション提供クラス                                                                                                                      |
| [SqlAgentProvider](./sql-agent-provider.md#sqlagentprovider)                          | SQL実行クラス(`SqlAgent`)生成クラス                                                                                                             |
| [ExecutionContextProvider](./execution-context-provider.md#executioncontextprovider)  | SQL実行コンテキスト生成クラス                                                                                                                   |
| [SqlResourceManager](./sql-resource-manager.md#sqlresourcemanager)                    | SQLリソース管理クラス                                                                                                                           |
| [EventListenerHolder](./event-listener-holder.md#eventlistenerholder)                 | イベントリスナ格納クラス                                                                                                                        |
| [Dialect](./dialect.md#dialect)                                                       | Database方言を表すクラス                                                                                                                        |
| [Clock](https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/Clock.html) | タイムゾーンを使用して現在の時点、日付および時間へのアクセスを提供するクロック指定しない場合は `Clock.systemDefaultZone()` が設定されます。 |

---

---
url: /uroborosql-doc/configuration/sql-resource-manager.md
---

# SqlResourceManager

`SqlResourceManager`はSQLファイルを管理するクラスです。

::: tip クラス名の変更
uroborosql v1.x で SqlManager から SqlResourceManagerにクラス名が変更されました。
:::

SqlResourceManagerの具象クラスとしてSqlResourceManagerImplクラスが提供されています。

| クラス                 | 説明                                                                 |
| :--------------------- | :------------------------------------------------------------------- |
| SqlResourceManagerImpl | `java.nio`を利用したファイルアクセスを行う`SqlResourceManager`クラス |

SqlResourceManagerImplクラスの特徴

* SQLファイルルートフォルダ設定
* SQLファイルエンコーディング設定
* 起動時のファイルパスキャッシュ
* 遅延ファイルキャッシュ
* jarファイル中のSQL参照
* zipファイル中のSQL参照
* カスタムファイルアクセス対応（`java.nio.file`パッケージを使用）
* DB種類毎のファイルパス切り替え

## SQLファイルルートフォルダの設定

**uroboroSQL**は初期設定ではクラスパス上にある`sql`フォルダ配下のSQLを読み込みます。\
このSQLファイルルートフォルダは変更することができます。

SQLファイルルートフォルダの設定 (custom\_sqlフォルダを指定)

```java
// SqlResourceManagerImplの場合
SqlConfig config = UroboroSQL.builder(...)
  // SQLファイルのルートフォルダの設定(custom_sqlフォルダをルートフォルダにする場合)
  .setSqlResourceManager(new SqlResourceManagerImpl("custom_sql")).build();
```

## DB種類毎のファイルパス切り替え

後述する[Dialect](./dialect.md#dialect)を利用して、１つのSQL名に対してDB種類毎にファイルパスを切り替えることが出来ます。

以下のようなファイル構成を例として説明します。

```txt
sql
  ├─employee
  │    └─select_employee.sql  -- Oracle, postgresql以外のDB用SQL
  ├─oracle
  │   └─employee
  │        └─select_employee.sql  -- oracle DB用SQL
  └─postgresql
      └─employee
           └─select_employee.sql  -- postgresql DB用SQL
```

SQL名として`employee/select_employee`を指定した場合、\
Oracle DBの場合は`sql/oracle/employee/select_employee.sql`が読み込まれます。\
同様にPostgresql DBの場合は`sql/postgresql/employee/select_employee.sql`が読み込まれます。\
DBに対するDialect用のフォルダがない場合は通常通り`sql/employee/select_employee.sql`が読み込まれます。

DB毎のフォルダ名

| DB名                 | フォルダ名 |
| :------------------- | :--------- |
| H2 DB                | h2         |
| Microsoft SQL Server | mssql      |
| MySQL                | mysql      |
| Oracle               | oracle     |
| Postgresql           | postgresql |
| その他               | default    |

---

---
url: /uroborosql-doc/advanced/sql-coverage.md
---

# SQLカバレッジ

これまでアプリケーション上の条件分岐はカバレッジツールを利用して網羅率を確認することができました。\
しかし、SQL文の条件分岐は実際にその分岐が通っているかどうかを確認する手段がなく、リリース後に初めて通った条件で不具合を発生させることがありました。\
この問題を解決するために**uroboroSQL**では、SQL文の条件分岐を集計してカバレッジレポートを行う機能を提供します。

SQLカバレッジは**uroboroSQL**を利用するアプリケーションの起動時オプションに

```md
-Duroborosql.sql.coverage=true
```

を追加することで有効になります。\
SQLカバレッジを有効にするとアプリケーションが実行している間に実行されるSQLについて、カバレッジ情報が収集されます。\
カバレッジ情報の収集結果は標準では`target/coverage/sql-cover.xml`に出力されます。\
このファイルの場所や名前を変更したい場合は、起動時オプションに

```md
-Duroborosql.sql.coverage.file=[出力ファイルパス]
```

を指定してください。

出力された`sql-cover.xml`をJenkinsのCobertura pluginなどのXMLレポートとして読み込むとSQLファイルのカバレッジレポートが参照できるようになります。

![カバレッジレポート例](/assets/cobertura.CekyfXBT.png "Jenkins Cobertura Report"){width=600px}

またより、**uroboroSQL**のみでHTMLレポートを出力することができるようになりました。\
起動時オプションに

```md
-Duroborosql.sql.coverage=jp.co.future.uroborosql.coverage.reports.html.HtmlReportCoverageHandler
```

を指定することで本機能を利用することができます。

カバレッジ情報はデフォルトでは`target/coverage/sql`フォルダ配下に出力されます。\
出力先フォルダを変更した場合は、起動時オプションに

```md
-Duroborosql.sql.coverage.dir=[出力フォルダパス]
```

を指定してください。

出力されたレポートのサンプルは下記を参照してください。

## サマリーページ

![HTML Coverage Report Summary](/assets/html_coverage_report_summary.Tyh867tK.png){width=800px}

## 詳細ページ

![HTML Coverage Report](/assets/html_coverage_report.RQGV3Ebh.png){width=800px}

出力サンプル

---

---
url: /uroborosql-doc/basics/sql-file-api.md
---

# SQLファイルインタフェース

## SQLによる検索(`SqlAgent#query` /`#queryWith`)

SQLを検索する方法は2つあります。

| 利用メソッド                      | 説明                                             |
| :-------------------------------- | :----------------------------------------------- |
| SqlAgent#query("\[SQL名]")         | [SQL名](./index.md#sql名)で説明した`SQL名`を指定 |
| SqlAgent#queryWith("\[SQL文字列]") | `SQL文字列`を直接指定                            |

上記２つのメソッドは検索を行うための`SqlQuery`インタフェースのインスタンスを返却します。

```java
// SQL名を指定
SqlQuery query1 = agent.query("employee/select_employee");

// SQL文字列を指定
SqlQuery query2 = agent.queryWith("select first_name, last_name where employee");
```

### 検索結果の取得

`SqlAgent`から取得した`SQLQuery`を使用していろいろな形式で検索結果を取得することが出来ます。\
下記のSQLを例に説明します。

```sql
-- department/select_department.sql
select /* _SQL_ID_ */
  dept.dept_no  as  dept_no
,  dept.dept_name  as  dept_name
from
  department  dept
where
  1        =  1
/*IF SF.isNotEmpty(deptNo)*/
and  dept.dept_no  =  /*deptNo*/1
/*END*/
/*IF SF.isNotEmpty(deptName)*/
and  dept.dept_name  =  /*deptName*/'sample'
/*END*/
```

### リスト取得(`SqlQuery#collect`)

| メソッド名                    | 戻り値の型                |
| :---------------------------- | :------------------------ |
| SqlQuery#collect()            | List\<Map\<String, Object>> |
| SqlQuery#collect(CaseFormat)  | List\<Map\<String, Object>> |
| SqlQuery#collect(Class\<T>) | List\<Class\<T>>         |

検索結果をMapや指定したクラスのListとして取得します。\
Mapには`キー：カラムラベル名`、`値：カラムの値`の形で1行分のデータが格納されます。

::: warning
`SqlQuery#collect()`では検索結果をすべてメモリ上に格納します。大量データの検索を行う場合は後述の`SqlQuery#strem()`の利用を検討してください。
:::

#### `SqlQuery#collect()` 引数なし

```java
try (SqlAgent agent = config.agent()) {
  List<Map<String, Object>> departments = agent.query("department/select_department")
      .collect();
}
// 結果(departments)
[
 {"DEPT_NO"=1, "DEPT_NAME"="sales"},
 {"DEPT_NO"=2, "DEPT_NAME"="export"},
 {"DEPT_NO"=3, "DEPT_NAME"="accounting"},
 {"DEPT_NO"=4, "DEPT_NAME"="personnel"}
]
```

#### `SqlQuery#collect(CaseFormat)` `CaseFormat`指定

引数に`jp.co.future.uroborosql.utils.CaseFormat`を指定することで、Mapのキー名に対する書式を変更することができます。

`CaseFormat.CAMEL_CASE`指定

```java
try (SqlAgent agent = config.agent()) {
  List<Map<String, Object>> departments = agent.query("department/select_department")
      .collect(CaseFormat.CAMEL_CASE);
}
// 結果(departments) のキーが"deptNo", "deptName"となる
[
 {"deptNo"=1, "deptName"="sales"},
 {"deptNo"=2, "deptName"="export"},
 {"deptNo"=3, "deptName"="accounting"},
 {"deptNo"=4, "deptName"="personnel"}
]
```

`CaseFormat`の指定がない場合はデフォルトの`CaseFormat`（初期設定では`UPPER_SNAKE_CASE`）で加工した値になります。\
デフォルトの`CaseFormat`はSqlConfig生成時に変更することができます。
デフォルト`CaseFormat`の設定の詳細は [CaseFormatの初期値設定](../configuration/sql-agent-provider.md#caseformatの初期値設定) を参照してください

#### `SqlQuery#collect(Class<T>)` 型指定

引数にクラスを指定すると、検索結果をMapの代わりに指定したクラスのインスタンスのListで取得することができます。

エンティティクラスを指定した場合

```java
/**
 * Entity that can be mapped to department table
 */
public class Department {
  private long deptNo;
  private String deptName;

  public long getDeptNo() {　return this.deptNo;　}
  public void setDeptNo(long deptNo) {　this.deptNo = deptNo;　}
  public String getDeptName() {　return this.deptName;　}
  public void setDeptName(String deptName) {　this.deptName = deptName;　}
}
```

```java
try (SqlAgent agent = config.agent()) {
  List<Department> departments = agent.query("department/select_department")
      .collect(Department.class);
}
```

引数に以下のクラスを指定すると、検索結果の `先頭項目` を指定したクラスのインスタンスの形で取得することができます。&#x20;

::: details 引数に指定可能な型

* プリミティブ型
  * boolean
  * byte
  * short
  * int
  * long
  * float
  * double
* ラッパー型
  * java.lang.Boolean
  * java.lang.Byte
  * java.lang.Short
  * java.lang.Integer
  * java.lang.Long
  * java.lang.Float
  * java.lang.Double
* その他の基本型
  * java.lang.String
  * java.lang.BigInteger
  * java.lang.BigDecimal
  * Enum型
* 日付型
  * java.util.Date
* JDBCの提供する型
  * java.sql.Date
  * java.sql.Time
  * java.sql.Timestamp
  * java.sql.Array
  * java.sql.Clob
  * java.sql.NClob
  * java.sql.Blob
  * java.sql.Ref
  * java.sql.SQLXML
* java.time API
  * java.time.LocalDate
  * java.time.LocalTIme
  * java.time.OffsetTime
  * java.time.LocalDateTime
  * java.time.OffsetDateTime
  * java.time.ZonedDateTime
  * java.time.Year
  * java.time.Month
  * java.time.YearMonth
  * java.time.MonthDay
  * java.time.DayOfWeek
* Optional型
  * java.util.Optional
  * java.util.OptionalInt
  * java.util.OptionalLong
  * java.util.OptionalDouble
* 配列
  * java.lang.Object\[]
  * byte\[]
* ドメイン型
  * [Domain](./entity-api.md#domain) アノテーションを付与した型

:::

```java
try (SqlAgent agent = config.agent()) {
  List<Long> deptNoList = agent.query("department/select_department").collect(Long.class);
}
```

### 先頭取得（`SqlQuery#first`)

| メソッド名                  | 戻り値の型          |
| :-------------------------- | :------------------ |
| SqlQuery#first()            | Map\<String, Object> |
| SqlQuery#first(CaseFormat)  | Map\<String, Object> |
| SqlQuery#first(Class\<T>) | T                   |

検索結果の1件目を取得します。\
結果を取得できない（検索結果が0件）場合、`jp.co.future.uroborosql.exception.DataNotFoundException`をスローします。

::: tip
メモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。
:::

#### `SqlQuery#first()` 引数なし

```java
try (SqlAgent agent = config.agent()) {
  Map<String, Object> department = agent.query("department/select_department")
      .first();
} catch (DataNotFoundException ex) {
  ex.printStackTrace();
}

// 結果(department)
 {"DEPT_NO"=1, "DEPT_NAME"="sales"}
```

#### `SqlQuery#first(CaseFormat)` `CaseFormat`指定

引数に`jp.co.future.uroborosql.utils.CaseFormat`を指定することで、Mapのキー名に対する書式を変更することができます。

`CaseFormat.CAMEL_CASE`指定

```java
try (SqlAgent agent = config.agent()) {
  Map<String, Object> department = agent.query("department/select_department")
      .first(CaseFormat.CAMEL_CASE);
} catch (DataNotFoundException ex) {
  ex.printStackTrace();
}
// 結果(department)
 {"deptNo"=1, "deptName"="sales"}
```

#### `SqlQuery#first(Class<T>)` 型指定

引数にクラスを指定すると、検索結果を指定したクラスのインスタンスの形で取得することができます。

エンティティクラスを指定した場合

```java
try (SqlAgent agent = config.agent()) {
  Department department = agent.query("department/select_department")
      .first(Department.class);
} catch (DataNotFoundException ex) {
  ex.printStackTrace();
}
```

`SqlQuery#collect(Class<T>)` と同様、検索結果の先頭項目を指定したクラスのインスタンスの形で取得することができます。

```java
try (SqlAgent agent = config.agent()) {
  long deptNo = agent.query("department/select_department")
      .first(long.class);
} catch (DataNotFoundException ex) {
  ex.printStackTrace();
}
```

### 先頭取得（`SqlQuery#findFirst`)

| メソッド名                      | 戻り値の型                    |
| :------------------------------ | :---------------------------- |
| SqlQuery#findFirst()            | Optional\<Map\<String, Object>> |
| SqlQuery#findFirst(CaseFormat)  | Optional\<Map\<String, Object>> |
| SqlQuery#findFirst(Class\<T>) | Optional\<T>                |

検索結果の1件目をOptionalの形式で取得します。\
メモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。

#### `SqlQuery#findFirst()` 引数なし

```java
try (SqlAgent agent = config.agent()) {
  Optional<Map<String, Object>> department = agent.query("department/select_department")
      .findFirst();
}
// 結果(department)
 {"DEPT_NO"=1, "DEPT_NAME"="sales"}
```

#### `SqlQuery#findFirst(CaseFormat)` `CaseFormat`指定

引数に`jp.co.future.uroborosql.utils.CaseFormat`を指定することで、Mapのキー名に対する書式を変更することができます。

`CaseFormat.CAMEL_CASE`指定

```java
try (SqlAgent agent = config.agent()) {
  Optional<Map<String, Object>> departmentOpt = agent.query("department/select_department")
      .findFirst(CaseFormat.CAMEL_CASE);
}
// 結果(department)
 {"deptNo"=1, "deptName"="sales"}
```

#### `SqlQuery#findFirst(Class<T>)` 型指定

引数にクラスを指定すると、検索結果を指定したクラスのOptional型の形で取得することができます。

エンティティクラスを指定した場合

```java
try (SqlAgent agent = config.agent()) {
  Optional<Department> departmentOpt = agent.query("department/select_department")
      .findFirst(Department.class);
}
```

`SqlQuery#collect(Class<T>)` と同様、検索結果の先頭項目を指定したクラスのOptional型の形で取得することができます。

```java
try (SqlAgent agent = config.agent()) {
  Optional<Long> deptNoOpt = agent.query("department/select_department")
      .findFirst(Long.class);
}
```

### 先頭１件取得（`SqlQuery#one`)

| メソッド名                | 戻り値の型          |
| :------------------------ | :------------------ |
| SqlQuery#one()            | Map\<String, Object> |
| SqlQuery#one(CaseFormat)  | Map\<String, Object> |
| SqlQuery#one(Class\<T>) | T                   |

検索結果の1件目を取得します。[find()](#先頭取得（sqlquery-first)と違い、実行するSQLで複数件の検索結果を返す場合は例外をスローします。\
結果を取得できない（検索結果が0件）場合、`jp.co.future.uroborosql.exception.DataNotFoundException`をスローします。\
検索結果が2件以上存在する場合、`jp.co.future.uroborosql.exception.DataNotUniqueException`をスローします。

::: tip
メモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。
:::

#### `SqlQuery#one()` 引数なし

```java
try (SqlAgent agent = config.agent()) {
  Map<String, Object> department = agent.query("department/select_department")
      .one();
} catch (DataNotFoundException | DataNotUniqueException ex) {
  ex.printStackTrace();
}

// 結果(department)
 {"DEPT_NO"=1, "DEPT_NAME"="sales"}
```

#### `SqlQuery#one(CaseFormat)` `CaseFormat`指定

引数に`jp.co.future.uroborosql.utils.CaseFormat`を指定することで、Mapのキー名に対する書式を変更することができます。

`CaseFormat.CAMEL_CASE`指定

```java
try (SqlAgent agent = config.agent()) {
  Map<String, Object> department = agent.query("department/select_department")
      .one(CaseFormat.CAMEL_CASE);
} catch (DataNotFoundException | DataNotUniqueException ex) {
  ex.printStackTrace();
}
// 結果(department)
 {"deptNo"=1, "deptName"="sales"}
```

#### `SqlQuery#one(Class<T>)` 型指定

引数にクラスを指定すると、検索結果を指定したクラスのインスタンスの形で取得することができます。

エンティティクラスを指定した場合

```java
try (SqlAgent agent = config.agent()) {
  Department department = agent.query("department/select_department")
      .one(Department.class);
} catch (DataNotFoundException | DataNotUniqueException ex) {
  ex.printStackTrace();
}
```

`SqlQuery#collect(Class<T>)` と同様、検索結果の先頭項目を指定したクラスのインスタンスの形で取得することができます。

```java
try (SqlAgent agent = config.agent()) {
  long deptNo = agent.query("department/select_department")
      .one(long.class);
} catch (DataNotFoundException | DataNotUniqueException ex) {
  ex.printStackTrace();
}
```

### 先頭１件取得（`SqlQuery#findOne`)

| メソッド名                    | 戻り値の型                    |
| :---------------------------- | :---------------------------- |
| SqlQuery#findOne()            | Optional\<Map\<String, Object>> |
| SqlQuery#findOne(CaseFormat)  | Optional\<Map\<String, Object>> |
| SqlQuery#findOne(Class\<T>) | Optional\<T>                |

検索結果の1件目をOptionalの形式で取得します。\
検索結果が2件以上存在する場合、`jp.co.future.uroborosql.exception.DataNotUniqueException`をスローします。\
メモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。

#### `SqlQuery#findOne()` 引数なし

```java
try (SqlAgent agent = config.agent()) {
  Optional<Map<String, Object>> departmentOpt = agent.query("department/select_department")
      .findOne();
} catch (DataNotUniqueException ex) {
  ex.printStackTrace();
}
// 結果(department)
 {"DEPT_NO"=1, "DEPT_NAME"="sales"}
```

#### `SqlQuery#findOne(CaseFormat)` `CaseFormat`指定

引数に`jp.co.future.uroborosql.utils.CaseFormat`を指定することで、Mapのキー名に対する書式を変更することができます。

`CaseFormat.CAMEL_CASE`指定

```java
try (SqlAgent agent = config.agent()) {
  Optional<Map<String, Object>> departmentOpt = agent.query("department/select_department")
      .findOne(CaseFormat.CAMEL_CASE);
} catch (DataNotUniqueException ex) {
  ex.printStackTrace();
}
// 結果(department)
 {"deptNo"=1, "deptName"="sales"}
```

#### `SqlQuery#findOne(Class<T>)` 型指定

引数にクラスを指定すると、検索結果を指定したクラスのOptional型の形で取得することができます。

エンティティクラスを指定した場合

```java
try (SqlAgent agent = config.agent()) {
  Optional<Department> departmentOpt = agent.query("department/select_department")
      .findOne(Department.class);
} catch (DataNotUniqueException ex) {
  ex.printStackTrace();
}
```

`SqlQuery#collect(Class<T>)` と同様、検索結果の先頭項目を指定したクラスのOptionalの形で取得することができます。

```java
try (SqlAgent agent = config.agent()) {
  Optional<Long> deptNoOpt = agent.query("department/select_department")
      .findOne(Long.class);
} catch (DataNotUniqueException ex) {
  ex.printStackTrace();
}
```

### 指定カラムのStream取得(`SqlQuery#select`)&#x20;

| メソッド名                           | 戻り値の型   |
| :----------------------------------- | :----------- |
| SqlQuery#select(Class\<T>)         | Stream\<T> |
| SqlQuery#select(String, Class\<T>) | Stream\<T> |

検索結果のうち、先頭項目、もしくは指定した項目を`java.util.stream.Stream`の形式で取得します。\
Streamによる順次読み込みと終端操作までの遅延処理により、メモリ効率の良い操作が可能になります。

#### `SqlQuery#select(Class<T>)` 項目指定なし（先頭項目）

引数にクラスのみを指定すると、検索結果の先頭項目を指定したクラスのインスタンスの形で取得することができます。\
（引数に指定できる型については `SqlQuery#collect(Class<T>)` を参照）

```java
try (SqlAgent agent = config.agent()) {
  Stream<Long> deptNoStream = agent.query("department/select_department")
      .select(Long.class);
}
```

#### `SqlQuery#select(String, Class<T>)` 項目指定あり

引数に取得する項目名を指定すると、その項目を指定したクラスのインスタンスの形で取得することができます。

```java
try (SqlAgent agent = config.agent()) {
  Stream<String> deptNameStream = agent.query("department/select_department").select("deptName", String.class);
}
```

### Stream取得(`SqlQuery#stream`)

| メソッド名                                | 戻り値の型                  |
| :---------------------------------------- | :-------------------------- |
| SqlQuery#stream()                         | Stream\<Map\<String, Object>> |
| SqlQuery#stream(CaseFormat)               | Stream\<Map\<String, Object>> |
| SqlQuery#stream(Class\<T>)              | Stream\<T>                |
| SqlQuery#stream(ResultSetConverter\<T>) | Stream\<T>                |

検索結果を`java.util.stream.Stream`の形式で取得します。\
Streamによる順次読み込みと終端操作までの遅延処理により、メモリ効率の良い操作が可能になります。

#### `SqlQuery#stream()` 引数なし

```java
try (SqlAgent agent = config.agent()) {
  agent.query("department/select_department").stream()
    .forEach(System.out::println);
}
// 結果
{"DEPT_NO"=1, "DEPT_NAME"="sales"}
{"DEPT_NO"=2, "DEPT_NAME"="export"}
{"DEPT_NO"=3, "DEPT_NAME"="accounting"}
{"DEPT_NO"=4, "DEPT_NAME"="personnel"}
```

#### `SqlQuery#stream(CaseFormat)` `CaseFormat`指定

引数に`jp.co.future.uroborosql.utils.CaseFormat`を指定することで、Mapのキー名に対する書式を変更することができます。

`CaseFormat.PASCAL_CASE` 指定

```java
try (SqlAgent agent = config.agent()) {
  agent.query("department/select_department").stream(CaseFormat.PASCAL_CASE)
    .forEach(System.out::println);
}
// 結果
{"DeptNo"=1, "DeptName"="sales"}
{"DeptNo"=2, "DeptName"="export"}
{"DeptNo"=3, "DeptName"="accounting"}
{"DeptNo"=4, "DeptName"="personnel"}
```

#### `SqlQuery#stream(Class<T>)` 型指定

引数にクラスを指定すると、検索結果を指定したクラスのインスタンスの形で取得することができます。

エンティティクラスを指定した場合

```java
try (SqlAgent agent = config.agent()) {
  agent.query("department/select_department").stream(Department.class)
    .forEach(System.out::println);
}
```

`SqlQuery#collect(Class<T>)` と同様、検索結果の先頭項目を指定したクラスのインスタンスの形で取得することができます。

```java
try (SqlAgent agent = config.agent()) {
  Stream<Long> deptNoStream = agent.query("department/select_department").stream(Long.class);
}
```

`jp.co.future.uroborosql.converter.ResultSetConverter`インタフェースを実装したクラスを引数に渡すことで、検索結果により複雑な加工を行うことができます。

提供されている `ResultSetConverter` は以下になります。

| クラス                                          | 説明                                                                                                                    |
| :---------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------- |
| MapResultSetConverter                           | 検索結果を項目名と値のMapに変換します。項目名はコンストラクタにCaseFormatを指定することで書式を変更することができます。 |
| EntityResultSetConverter                        | 検索結果をエンティティ型のインスタンスに変換します。エンティティ型はコンストラクタで指定します。                        |
| ScalarResultSetConverter  | 検索結果のうち、１項目を指定した型のインスタンスに変換します。対象とする項目と変換する型はコンストラクタで指定します。  |

`ResultSetConverter`は`FunctionInterface`として提供されているので、`lambda式`による記述も可能です。

ResultSetConverter指定(lambda式)

```java
try (SqlAgent agent = config.agent()) {
  // ResultSetConverterはlambda式で指定可能
  agent.query("department/select_department").stream(rs -> {
    Map<String, Object> row = new HashMap<>();
    row.put("deptNo", rs.getObject("DEPT_NO"));
    row.put("deptName", rs.getObject("DEPT_NAME"));
    return row;
  }).forEach(System.out::println);
}
// 結果
{"deptNo"=1, "deptName"="sales"}
{"deptNo"=2, "deptName"="export"}
{"deptNo"=3, "deptName"="accounting"}
{"deptNo"=4, "deptName"="personnel"}
```

::: danger 注意
戻り値として取得されるStreamインスタンスは内部にResultSetリソースを保持しています。このResultSetはデータを最後まで読み込むか`Stream#close()`が呼ばれたタイミングでリソースのクローズを行います。(Stream生成時、Stream#onClose()にResultSetリソースの`closeHandler`を登録します)\
そのため、取得したStreamで全データを扱う終端処理(collectなど)を行うか、try-with-resourcesの利用やStream#close()の明示的な呼び出しによるStreamのクローズを行わないとResultSetリソースがクローズされずカーソルのリークが発生します。
:::
::: danger 注意
取得したStreamのクローズより先にSqlAgentインスタンスがクローズ、または破棄された場合、Streamの内部に保持しているResultSetリソースもクローズされてしまい不正な動作となります。StreamインスタンスとそのStreamを生成したSqlAgentインスタンスの生存期間を合わせる、もしくはSqlAgentインスタンスの生存期間を長くしてください。
:::

Streamのクローズ

```java
try (SqlAgent agent = config.agent()) {
  try (Stream<Map<String, Object>> stream = agent.query("department/select_department").stream()) {
    // Stream#findFirst() はStream内のResultSetリソースをクローズしないので、try-with-resourcesでStreamをクローズする
    stream.findFirst().ifPresent(System.out::println);
  }
}
```

### ResultSet取得(`SqlQuery#resultSet`)

| メソッド名           | 戻り値の型 |
| :------------------- | :--------- |
| SqlQuery#resultSet() | ResulitSet |

検索結果を`java.sql.ResultSet`の形式で取得します。

::: danger 注意
ResultSetリソースのクローズは各自で行う必要があります。
:::
::: danger 注意
ResultSetリソースのクローズより先にSqlAgentインスタンスがクローズ、または破棄された場合、ResultSetリソースもクローズされてしまい不正な動作となります。ResultSetリソースとそのResultSetを生成したSqlAgentインスタンスの生存期間を合わせる、もしくはSqlAgentインスタンスの生存期間を長くしてください。
:::

このAPIは他のフレームワークとの連携など、`ResultSet`リソースの取得が必要なケースを想定して提供しています。

::: warning
`ResultSet`リソースの取得が必要でなければ、`ResultSet`リソースのクローズが管理されている他のAPIの利用を検討してください。
:::

```java
try (SqlAgent agent = config.agent()) {
  try (ResultSet rs = agent.query("department/select_department").resultSet()) {
    // try-with-resourcesでResultSetをクローズする
    while (rs.next()) {
      // ResultSetからの値取得
      ・・・
    }
  }
}
```

## SQLによる更新(`SqlAgent#update` /`#updateWith` /`#updateChained`)

DB更新処理(登録/変更/削除)やDDLの実行も検索処理と同様`SQL名`を指定する場合と`SQL文字列`を指定するAPIが提供されています。\
また から、引数で指定された複数のSQLを単一の通信でまとめてデータベースに発行する `updateChained` APIが提供されています。これにより、ネットワークの往復によるオーバーヘッドを最小限に抑えることが可能です。

| 利用メソッド                                        | 説明                                                                                        |
| :-------------------------------------------------- | :------------------------------------------------------------------------------------------ |
| SqlAgent#update("\[SQL名]")                          | [SQL名](./index.md#sql名)で説明した`SQL名`を指定                                            |
| SqlAgent#updateWith("\[SQL文字列]")                  | `SQL文字列`を直接指定                                                                       |
| SqlAgent#updateChained("\[SQL名1]", "\[SQL名2]", ...) | 指定した複数のSQL名に対するSQLをまとめて発行する。  |

上記メソッドは更新を行うための`SqlUpdate`インタフェースのインスタンスを返却します。

```java
// １件挿入(SQL名指定)
int count = agent.update("department/insert_department")
  .param("deptNo", 1)
  .param("deptName", "Sales")
  .count();

// 更新(SQL文字列指定)
int count = agent.updateWith("update employee set first_name = /*firstName*/ where emp_no = /*empNo*/")
  .param("empNo", 1)
  .param("firstName", "Bob")
  .count();

// 複数SQL名指定
int count = agent.updateChained("department/insert_department", "department/update_department")
  .param("deptNo", 1)
  .param("deptName", "Sales")
  .param("updDeptName", "HR")
  .count();

```

department/insert\_department.sql

```sql
insert /* _SQL_ID_ */
into
  department
(
  dept_name
, lock_version
) values (
  /*deptName*/'sample'
,  0
)
```

department/update\_department.sql

```sql
update /* _SQL_ID_ */ department
set dept_name =  /*updDeptName*/'sample'
where
dept_name = /*deptName*/
```

`SqlUpdate`インタフェースの主なAPIは以下になります。

### 更新の実行(`SqlUpdate#count`)

| メソッド名        | 戻り値の型 |
| :---------------- | :--------- |
| SqlUpdate#count() | int        |

更新処理を行い、登録、更新、削除を行った行数を返します。

```java
try (SqlAgent agent = config.agent()) {
  // insert
  agent.update("department/insert_department")
    .param("deptNo", 1)
    .param("deptName", "sales")
    .count();
  // update
  agent.update("department/update_department")
    .param("deptNo", 1)
    .param("deptName", "HR")
    .count();
  // delete
  agent.update("department/delete_department")
    .param("deptNo", 1)
    .count();
}
```

::: warning updateChained の利用について
updateChainedメソッドは内部で指定された複数のSQLを1つに結合したうえで一度のDB間通信でまとめてSQLの発行を行います。\
大量のSQL更新があり、都度DB通信することによるオーバーヘッドが問題になる場合に有効です。\
ただし、内部で行われるSQL文の結合処理のオーバーヘッドもあるため、このメソッドを利用する場合は必ず実際に計測して効果があることを確認してください。
:::

::: danger updateChained で返却されるcount() の値

JDBCでは 1つのPreparedStatementで複数のSQLを実行した結果について明確に規定していません。そのため利用するDBによって結果が変わります。\
updateChainedを利用する場合はDB毎にどういう結果が返却されるかを理解したうえでご利用ください。

* H2 / Postgresql / MySQL : `最初のSQL` で登録、更新、削除を行った行数
* SQLServer : `最後のSQL` で登録、更新、削除を行った行数
* Oracle : 1つのPreparedStatementで複数のSQLを発行すると例外が発生

:::

## SQLによるバッチ更新(`SqlBatch#batch` /`#batchWith`)

大量のデータを一括で更新する場合、通常の更新ではSQLが都度実行されるため処理速度が遅く問題になる場合があります。\
こういったケースに対応するため、**uroboroSQL**ではバッチ更新用のAPIを提供しています。

バッチ更新処理も他と同様`SQL名`を指定する場合と`SQL文字列`を直接記述する２つのAPIが提供されています。

| 利用メソッド                      | 説明                                             |
| :-------------------------------- | :----------------------------------------------- |
| SqlAgent#batch("\[SQL名]")         | [SQL名](./index.md#sql名)で説明した`SQL名`を指定 |
| SqlAgent#batchWith("\[SQL文字列]") | `SQL文字列`を直接指定                            |

上記２つのメソッドはバッチ更新を行うための`SqlBatch`インタフェースのインスタンスを返却します。

::: danger batch/batchWith に指定するSQLの注意点
batch/batchWithの内部では `PreparedStatement` を作成し、渡されたパラメータをバインドしながら `PreparedStatement#executeBatch()` メソッドを呼び出すことでバッチ処理を行っています。\
その際 `PreparedStatement` は、引数で渡されたSQLを**定数パラメータとエスケープキャラクタ置換文字**で評価したSQLを元に生成し、この `PreparedStatement` をバッチ処理が終了するまで利用します。\
そのため、SQLの中に 条件分岐（`/*IF*/` など）や埋め込み文字（`/*# */` など）を記載していると、条件分岐や埋め込み文字をnullで判定したSQLを元に `PreparedStatement` が生成されることになり、意図しない結果になります。\
このことから、バッチ処理で使用するSQLには条件分岐や埋め込み文字を **使用しないようにする必要があります**。

例）\
下記のようなデータを

| id   | name   | age |
| :--- | :----- | :-- |
| null | taro   | 13  |
| 2    | hanako | 15  |
| 3    | jiro   | 10  |

以下のSQLでバッチインサートすると

```sql
insert into person (
/*IF id != null */
  id,
/*END*/
  name,
  age
) values (
/*IF id != null */
/*id*/,
/*END*/
/*name*/,
/*age*/
)
```

１件目のデータ（id=null, name=taro, age=13）を使ってSQLが評価され以下のようになる

```sql
insert into person (
  name,
  age
) values (
/*name*/,
/*age*/
)
```

このSQLでバッチインサートが行われると、2件目、3件目のデータで指定していた `id` の値がDBに格納されなくなります。

:::

`SqlBatch`インタフェースでは、`SqlFluent`インタフェースによるバインドパラメータの設定とは別に`java.util.stream.Stream`を用いたバッチパラメータの設定を行うAPIが提供されています。

| メソッド                                          | 説明                                                                                                                                     |
| :------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- |
| SqlBatch#paramStream(Stream\<Map\<String, Object>>) | バインドパラメータや置換文字列として使用するキーと値のセットを`java.util.stream.Stream`で設定する。                |
| SqlBatch#paramStream(Stream\<E>)                  | バインドパラメータや置換文字列として使用するエンティティクラスインスタンスを`java.util.stream.Stream`で設定する。 |

### バッチ更新の実行(`SqlBatch#count`)

| メソッド名       | 戻り値の型 |
| :--------------- | :--------- |
| SqlBatch#count() | int        |

バッチ更新処理を行い、登録、更新、削除を行った行数を返します。

バッチ更新

```java
// バッチ処理の実行
int count = agent.batch("department/insert_department")
  // 指定したファイルからMap<String, Object>のStreamを生成し、バッチ処理のパラメータとして指定する
  .paramStream(getDataByFile(Paths.get("data/department.tsv")))
  .count();

・・・

private Stream<Map<String, Object>> getDataByFile(final Path filePath) {
  try {
    final List<String> lines = Files.readAllLines(filePath);
    final String[] header = lines.get(0).split("\\t");
    return lines.stream()
        .skip(1)
        .map(s -> s.split("\\t"))
        .map(data -> IntStream.range(0, header.length)
            .<Map<String, Object>> collect(HashMap::new, (row, i) -> row.put(header[i], data[i]),
                Map::putAll));
  } catch (IOException e) {
    e.printStackTrace();
    throw new UncheckedIOException(e);
  }
}
```

data/department.tsv　の内容

```yaml
deptNo  deptName
1  sales
2  export
3  accounting
4  personnel
```

`paramStream()`メソッドに`SqlQuery#stream()`の結果を指定することで疑似的に`SELECT-INSERT` / `SELECT-UPDATE` / `SELECT-DELETE`を行うことができます。\
Stream APIを利用することで検索結果の件数が多い場合でも、少ないメモリ使用量でバッチ処理を行うことができます。

SELECT-UPDATE

```java
int updateCount = agent.batch("department/update_department")
  .paramStream(agent.query("department/select_department")
    .stream(CaseFormat.LOWER_SNAKE_CASE).map(e -> {
      Map<String, Object> ans = new HashMap<>(e);
      ans.replaceAll((k, v) -> v != null ? v.toString() + "_after" : "after"); // 取得した検索結果の各行の値に "_after" を付与する
      return ans;
    }))
  .count();

```

### バッチSQL実行動作のカスタマイズ

`SqlBatch`インタフェースにはバッチSQL実行時の動作を変更するためのAPIが提供されています。

| メソッド                                                      | 説明                                                                                      | デフォルト値                             |
| :------------------------------------------------------------ | :---------------------------------------------------------------------------------------- | :--------------------------------------- |
| by(BiPredicate\<ExecutionContext, Map\<String, Object>>)        | バッチSQLの実行条件を指定します。`BiPredicate`の結果がtrueの場合にバッチSQLを実行します。 | 1000件毎                                 |
| batchWhen(BiConsumer\<SqlAgent, ExecutionContext>)             | バッチSQLの実行タイミングで行う操作を指定します。                                         | 何もしない                               |
| errorWhen(TriConsumer\<SqlAgent, ExecutionContext, Exception>) | バッチSQLの実行時に例外が発生した時の動作を指定します。                                   | `UroborosqlRuntimeException`をスローする |

これらのAPIを利用することでより柔軟なSQL実行が可能になります。

バッチSQL実行時動作のカスタマイズ例

```java
List<Map<String, Object>> inputData = new ArrayList<>();
// 中略　入力データ作成

try (SqlAgent agent = config.agent()) {
  agent.batch("department/insert_department")
    .paramStream(inputData.stream())
    .by((ctx, row) -> ctx.batchCount() == 10)  // 10件毎にSQL実行
    .batchWhen((agent, ctx) -> agent.commit())  // SQL実行が成功したらコミットする
    .errorWhen((agent, ctx, ex) -> {
      log.error("error occured. ex:{}", ex.getMessage());
    })  // 例外が発生したらログ出力する
    .count();
}
```

## ストアドプロシージャの実行(`SqlAgent#proc` /`#procWith`)

**uroboroSQL**では、SQLの検索/更新のほかDBが提供するストアドプロシージャの呼び出し用APIも提供しています。

| 利用メソッド                     | 説明                                             |
| :------------------------------- | :----------------------------------------------- |
| SqlAgent#proc("\[SQL名]")         | [SQL名](./index.md#sql名)で説明した`SQL名`を指定 |
| SqlAgent#procWith("\[SQL文字列]") | `SQL文字列`を直接指定                            |

上記２つのメソッドはストアドプロシージャの呼出を行うための`Procedure`インタフェースのインスタンスを返却します。

### `Procedure`インタフェース

| メソッド名       | 戻り値の型          |
| :--------------- | :------------------ |
| Procedure#call() | Map\<String, Object> |

`Procedure`インタフェースでは、ストアドプロシージャからの戻り値を取得するためのAPIが提供されています。

| メソッド                                            | 説明                                                                                                                                                                                                                                                                                                                                |
| :-------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ProcedureFluent#outParam(String, int)               | ストアドプロシージャからの戻り値として受け取るパラメータを指定します実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値の`Map<String, Object>`に格納されて取得できます。第2引数で受け取る値の型をint型で指定します                                                                                             |
| ProcedureFluent#outParam(String, SQLType)           | ストアドプロシージャからの戻り値として受け取るパラメータを指定します実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値の`Map<String, Object>`に格納されて取得できます。第2引数で受け取る値の型をSQLType型で指定します                                                                                         |
| ProcedureFluent#inOutParam(String, int)             | ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値の`Map<String, Object>`に格納されて取得できます。第2引数で受け取る値の型をint型で指定します                                                                                     |
| ProcedureFluent#inOutParam(String, SQLType)         | ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値の`Map<String, Object>`に格納されて取得できます。第2引数で受け取る値の型をSQLType型で指定します                                                                                 |
| ProcedureFluent#inOutParamIfAbsent(String, int)     | ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します指定したパラメータ名のパラメータが事前に登録されていない場合に値を追加します実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値の`Map<String, Object>`に格納されて取得できます。第2引数で受け取る値の型をint型で指定します     |
| ProcedureFluent#inOutParamIfAbsent(String, SQLType) | ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します指定したパラメータ名のパラメータが事前に登録されていない場合に値を追加します実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値の`Map<String, Object>`に格納されて取得できます。第2引数で受け取る値の型をSQLType型で指定します |

```java
// Procedureインタフェースのインスタンスを取得
Map<String, Object> result = agent.procWith("{call product_id_exist_check(/*productId*/, /*checkOut*/)}")
  .param("productId", 0)
  .outParam("checkOut", java.sql.JDBCType.NUMERIC)
  .call();
// outParamメソッドで指定したパラメータの値(戻り値)を取得
BigDecimal checkOut = (BigDecimal)result.get("checkOut");
```

## リトライ(`SqlFluent#retry`)

SQLを実行した際、タイミングによって発生する例外（テーブルロックエラーなど）の場合はリトライを行い、できるだけ正常に処理を終了させたい場合があります。\
uroboroSQLでは、`retry` メソッドにより簡潔で確実なリトライ処理が行えるよう工夫されています。

```java
try (SqlAgent agent = config.agent()) {
  // INSERT文の実行
  // insert into product (product_id) values (/*productId*/0);
  // リトライ対象エラーコードの場合、5回のリトライを20ms間隔で行う
  agent.update("example/insert_product")
    .param("productId", 1)
    .retry(5, 20)
    .count();
}
```

---

---
url: /uroborosql-doc/advanced.md
---

# SQLファイルの解決ルール

## 複数フォルダの指定

sqlフォルダはクラスパスから参照することが出来れば複数指定することが出来ます。

* `src/test/resources`, `src/main/resources` の順にクラスパスに指定されている場合

```txt
src
    ├─main
    │   └─resources
    │       └─sql
    │           ├─department
    │           │    ├─insert_department.sql
    │           │    └─select_department.sql
    │           └─employee
    │                ├─insert_employee.sql
    │                └─select_employee.sql
    └─test
        └─resources
            └─sql
                ├─department
                │    ├─update_department.sql
                │    └─delete_department.sql
                └─employee
                     ├─update_employee.sql
                     └─select_employee.sql
```

::: warning
SQLファイルのパスが重複している場合、クラスパス上で先にあるフォルダのSQLファイルが使用されます。\
:::

上記のフォルダ構成の場合、`src/main/resources/sql/employee/select_employee.sql` と `src/test/resources/sql/employee/select_employee.sql` がともに `employee/select_employee` として解決されますが、クラスパスとして`src/test/resources`が先に指定されているため、`src/test/resources/sql/employee/select_employee.sql`が使用されます。

## jarファイルの指定

SQLファイルはjarの中にリソースとして含めることもできます。\
その場合、リソースのルート直下のsqlフォルダをルートフォルダとした相対パスでSQLファイルを指定することができます。
SQLファイルのルートフォルダ（初期値：sql)は変更することができます。\
変更方法の詳細は [SQLファイルルートフォルダの設定](../configuration/sql-resource-manager.md#sqlファイルルートフォルダの設定) を参照してください。

## DB種類毎のファイルパス切り替え

[Dialect](../configuration/dialect.md#dialect)を利用して、１つのSQL名に対してDB種類毎にファイルパスを切り替えることが出来ます。\
この機能により、接続先のDB種類が複数ある場合に発生するSQL構文の差異を吸収することができます。

以下のようなファイル構成を例として説明します。

```txt
sql
  ├─employee
  │    └─select_employee.sql  -- Oracle, postgresql以外のDB用SQL
  ├─oracle
  │   └─employee
  │        └─select_employee.sql  -- oracle DB用SQL
  └─postgresql
      └─employee
           └─select_employee.sql  -- postgresql DB用SQL
```

SQL名として`employee/select_employee`を指定した場合、\
Oracle DBの場合は`sql/oracle/employee/select_employee.sql`が読み込まれます。\
同様にPostgresql DBの場合は`sql/postgresql/employee/select_employee.sql`が読み込まれます。\
DBに対するDialect用のフォルダがない場合は通常通り`sql/employee/select_employee.sql`が読み込まれます。

DB毎のフォルダ名

| DB名                 | フォルダ名 |
| :------------------- | :--------- |
| H2 DB                | h2         |
| Microsoft SQL Server | mssql      |
| MySQL                | mysql      |
| Oracle               | oracle     |
| Postgresql           | postgresql |
| その他               | default    |

---

---
url: /uroborosql-doc/getting_started/sql-file-access.md
---

# SQLファイルを使用したDBアクセス

## SqlConfigの生成

SQLファイルを使用したサンプルコード [SqlFileApiSample.java](https://github.com/future-architect/uroborosql-sample/blob/main/src/main/java/jp/co/future/uroborosql/sample/SqlFileApiSample.java) を例として説明します。

まず初めにコンストラクタの中で最初に`SqlConfig`クラスを作成しています。
`SqlConfig`は**uroboroSQL**に対する各種の設定を保持するクラスで、`SqlConfig`の設定を変更することで**uroboroSQL**の動作を変更することが出来ます。\
ここでは[H2DB](http://www.h2database.com/html/main.html)のメモリDBに接続する`SqlConfig`インスタンスを生成しています。
`SqlConfig`の生成には`UroboroSQL`クラスによるBuilderAPIを使用します。

* 基本的な呼出方法（DBへの接続情報のみ指定）

```java
// create SqlConfig
SqlConfig config = UroboroSQL.builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "").build();
```

* 設定のカスタマイズ（定数の指定や検索結果の取得方法変更）

```java
// create SqlConfig
SqlConfig config = UroboroSQL
    .builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "")
    // ExecutionContextProviderの設定（Enum定数パッケージ設定の追加）
    .setExecutionContextProvider(new ExecutionContextProviderImpl()
    .setEnumConstantPackageNames(Arrays.asList(Gender.class.getPackage().getName())))
    // SqlAgentProviderの設定（Queryの戻り値のMapのキー文字列のデフォルトCaseFormat設定の追加）
    .setSqlAgentProvider(new SqlAgentProviderImpl().setDefaultMapKeyCaseFormat(CaseFormat.CAMEL_CASE))
    .build();
```

`SqlConfig`生成時のカスタマイズの詳細については [設定](../configuration/index.md)を参照してください。

## テーブルの作成と初期データの登録

次に事前準備として以降の処理で使用するテーブルの作成と初期データの登録を行います。（`SqlFileApiSample#setupTableAndData()`を参照）\
SQLを実行する場合は`SqlConfig`から`SqlAgent`を生成します。
`SqlAgent`は**uroboroSQL**の中核となるクラスで、**uroboroSQL**の各操作はこの`SqlAgent`を使って行います。\
`SqlAgent`は`AutoClosable`インタフェースを実装しているので、try-with-resources文で囲むことで処理終了時に自動でクローズされます。
このとき`SqlAgent`の中に保持する`Connection`や`Statement`も合わせてクローズされるため、クローズ漏れによるメモリリークを防ぐことができます。

```java
// create SqlAgent. SqlAgent implements AutoClosable.
try (SqlAgent agent = config.agent()) {
  // ここにSQL実行の処理を実装する
}
```

::: tip
以降の説明では`SqlAgent`に対する処理はtry-with-resources文の中で行っているものとします。
:::

**uroboroSQL**では実行するSQLをファイルパスに似た表現（以降 *SQL名* と呼ぶ）で指定します。
下の例ではクラスパス上にあるsqlフォルダ配下のddl/create\_tables.sqlを指定してSQL更新処理を実行します。

更新処理を行う場合、`SqlAgent#update("[SQL名]")`メソッドを使用して**SqlUpdate**を取得しUpdateの実行を行います。

```java
// create table :  テーブル作成
agent.update("ddl/create_tables").count();
// setup data : 初期データ挿入
agent.update("setup/insert_data").count();
```

ddl/create\_tables.sqlで作成したテーブルの構成は以下になります。

```mermaid
erDiagram
    department ||--o| dept_emp : ""
    employee ||--o| dept_emp : ""
    department {
        number dept_no
        varchar dept_name
        number lock_version
    }
    dept_emp {
        number emp_no FK
        number dept_no FK
    }
    employee {
        number emp_no
        varchar first_name
        varchar last_name
        date birth_date
        char gender
        number lock_version
    }
```

## SQLファイルを使用した検索

登録したデータを検索します。検索を行う際は、`SqlAgent#query("[SQL名]")`メソッドを使用して**SqlQuery**を取得し、バインドパラメータの設定や検索の実行を行います。

**SqlQuery**では検索結果をいくつかの形式で取得することができます。

| メソッド             | 説明                                                                                                                |
| :------------------- | :------------------------------------------------------------------------------------------------------------------ |
| SqlQuery#collect()   | 検索結果を`List<Map>`の形式で取得する                                                                               |
| SqlQuery#stream()    | 検索結果を`java.util.Stream<Map>`の形式で取得する                                                                   |
| SqlQuery#resultSet() | 検索結果の`ResultSet`を取得する                                                                                     |
| SqlQuery#first()     | 検索結果の１件目を取得する。取得できない場合は`DataNotFoundException`がスローされる                                 |
| SqlQuery#findFirst() | 検索結果の１件目を取得する。戻り値は`Optional`                                                                      |
| SqlQuery#one()       | 検索結果の１件目を取得する。取得できない場合、もしくは２件以上取得出来た場合は`DataNotFoundException`がスローされる |
| SqlQuery#findOne()   | 検索結果の１件目を取得する。戻り値は`Optional`。２件以上取得出来た場合は`DataNotFoundException`がスローされる       |

以下のように呼び出します。

```java
// no parameter : バインドパラメータ指定なしで検索
List<Map<String, Object>> deps1 = agent.query("department/select_department")
    .collect();

// add bind parameter : バインドパラメータを設定して検索
List<Map<String, Object>> deps2 = agent.query("department/select_department")
    .param("deptNo", 1)
    .collect();
```

ここで実行されるSQLは以下のようになっています。

* department/select\_department.sql

```sql
select /* _SQL_ID_ */
    dept.dept_no        as    dept_no
,   dept.dept_name      as    dept_name
,   dept.lock_version   as    lock_version
from
    department    dept
/*BEGIN*/
where
/*IF SF.isNotEmpty(deptNo)*/
and dept.dept_no    = /*deptNo*/1
/*END*/
/*IF SF.isNotEmpty(deptName)*/
and dept.dept_name  = /*deptName*/'sample'
/*END*/
/*END*/
```

* `/* _SQL_ID_ */` はSQLを特定するID(SQL\_IDといいます)を付与するための予約語で、実行時にSQLファイルを特定するための文字列に変換されます。
* `/*IF*/ ... /*END*/`は条件分岐で、IFの後ろの評価式が`True`となる場合に`/*IF*/`と`/*END*/`で囲まれた部分が出力されます。
* `/*deptNo*/`はバインドパラメータで、実行時に`?`に変換され、SqlQueryに設定したパラメータがSQLへバインドされます。
* `/*deptNo*/`の後ろの`1`はテスト用データです。このようにテスト用データをSQL文に記述しておくことで、このSQLを
  SQLクライアントツールで実行する際にエラーにならずに文法の確認を行うことができます。

SQLで使用できる構文については[2WaySQL](../background/#_2waysql)を参照してください。\
また、検索のより詳しい説明は[SQLによる検索](../basics/sql-file-api.md#sqlによる検索-sqlagent-query-sqlagent-querywith)を参照してください。

## SQLファイルを使用した行挿入

テーブルに対して行挿入を行うことも出来ます。
行挿入を行う際は、`SqlAgent#update("[SQL名]")`メソッドを使用して**SqlUpdate**を取得し、続けてバインドパラメータの設定やSQLの実行を行います。

```sql
agent.update("department/insert_department")
    .param("deptName", "production")
    .count();
```

ここで実行されるSQLは以下のようになっています。

* department/insert\_department.sql

```sql
insert /* _SQL_ID_ */
into
    department
(
    dept_name
,   lock_version
) values (
    /*deptName*/'sample'
,   0
)
```

`SqlAgent#update("[SQL名]")`では実行するSQLの内容によって行挿入の他に行更新や行削除を行うことが出来ます。より詳しい説明は[SQLによる更新](../basics/sql-file-api.md#sqlによる更新-sqlagent-update-sqlagent-updatewith)を参照してください。

---

---
url: /uroborosql-doc/why_uroborosql.md
---

# uroboroSQLとは

**uroboroSQL**は2Way-SQLが利用可能なJava製のシンプルなSQL実行ライブラリです。

[フューチャーアーキテクト]社内にて、2006-2007年頃に[S2Dao]を参考に開発され、プロジェクトで実際に利用されて現在まで改善が続けられてきました。社内ではWebアプリケーションフレームワークや各種設計開発支援ツールと連携・統合される形で利用されています。

とはいえ、社内で秘伝のタレ化していることは否めず、開発フェーズでは開発パートナーさんからも「ググれない」から使い方がわからないいう声もちらほら。だったらOSS化してしまえということのが公開のきっかけです。

## uroboroSQLを使う理由

JavaからRDBにアクセスするとき、Java標準のJPA(Java Persistence API)の実装である[EclipseLink]、[OpenJPA]はもとより、歴史のあるORMとして[Hibernate]、[MyBatis]、[Spring Data JDBC]といったグローバルで使われているものもありますし、日本でよく使われてきた[S2Dao]、[S2JDBC]、[DBflute]、[Doma]といったものもあります。

こういった数多のDB系ライブラリ・フレームワークの中で解決したい領域もそれぞれですが、**uroboroSQL**は主にSQL中心の設計コンセプトを採用しています。Javaを中心に考えてSQLを組み立てるという思想ではなく、SQLに足りないところをJavaで補うという思想です。

これはエンタープライズシステムにおいて、ORマッパーやクエリビルダでは実装しきれない、hint句による実行計画の指定や分析関数の利用など複雑かつDBプロダクト依存のSQLを使う場合に有効と考えています。

そのため、**uroboroSQL**はSQLは2Way-SQL方式で記述ができるものの、ORMでよくあるエンティティクラスとリレーションをたどって遅延ロードして子エンティティを取得するなどの機能は有していません。（単純なエンティティクラスへのマッピングは提供しています）

その分、エンタープライズで培われたノウハウとして、区分値サポート、リトライ、イベントハンドリングによるカスタマイズなどの機能を充実させています。また、2Way-SQLのIF分岐に対してカバレッジを取れるようにするという、品質視点での機能があるのも特徴です。

それが**uroboroSQL**の最大の関心事なのです。

## Further Reading

[フューチャーアーキテクト]: https://www.future.co.jp/architect/

[S2Dao]: http://s2dao.seasar.org/ja/

[EclipseLink]: https://www.eclipse.org/eclipselink/

[OpenJPA]: http://openjpa.apache.org/

[Hibernate]: https://hibernate.org/

[MyBatis]: http://www.mybatis.org/mybatis-3/ja/index.html

[Spring Data JDBC]: https://spring.io/projects/spring-data-jdbc#overview

[S2JDBC]: http://s2container.seasar.org/2.4/ja/s2jdbc.html

[DBFlute]: http://dbflute.seasar.org/

[Doma]: https://doma.readthedocs.io/en/stable/

---

---
url: /uroborosql-doc/about.md
---

# uroboroSQLについて

## GitHub

<https://github.com/future-architect/uroborosql>

## リリースノート

| バージョン | リリース日 | 概要                                                                                                                                                                                                    |
| :--------: | :--------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|  v1.0.10   | 2025/12/18 | 機能拡張リリース. パラメータログのログレベルをDEBUGからTRACEに変更                                                                                                                                      |
|   v1.0.9   | 2025/11/20 | バグフィックスリリース. SQLServerでDAOインタフェース経由のバッチインサートを行うとJDBCのエラーが発生する不具合の修正                                                                                    |
|   v1.0.8   | 2025/08/19 | 機能拡張リリース. DBコネクションのスキーマ名を固定することでDAO APIの性能改善を行うオプションの追加                                                                                                     |
|   v1.0.7   | 2025/08/05 | 機能拡張リリース. 定数や区分の登録数が多い（数千オーダー）場合にSQL実行に時間がかかる問題を改善。またDBコネクションのスキーマ名やDatabaseMetadataの中の変更されない情報をキャッシュするオプションを追加 |
|   v1.0.5   | 2025/05/04 | 機能拡張リリース. updateChainedメソッド追加                                                                                                                                                             |
|   v1.0.4   | 2025/03/03 | バグフィックスリリース. SQLServerに対してDate型のカラムにnullを指定すると例外が発生する不具合修正                                                                                                       |
|   v1.0.3   | 2024/10/30 | 機能拡張リリース. SqlInfoの内部実装修正（URLの保持）                                                                                                                                                    |
|   v1.0.2   | 2024/10/28 | 機能拡張リリース. ExecutionContext#contextAttrにアクセスするためのAPIをSqlEntityQuery, SqlEntityUpdate, SqlEntityDeleteに追加                                                                           |
|   v1.0.1   | 2024/10/20 | バグフィックスリリース. SqlKindの設定不備修正                                                                                                                                                           |
|   v1.0.0   | 2024/09/26 | uroborosql v1.0.0 メジャーバージョンリリース！                                                                                                                                                          |

See more info. [Github releases](https://github.com/future-architect/uroborosql/releases)

---

---
url: /uroborosql-doc/getting_started/entity-access.md
---

# エンティティクラスを使用したDBアクセス

**uroboroSQL**ではSQLファイルを使用したDBアクセスの他にエンティティクラスを使用したDBアクセスも提供しています。（[EntityApiSample.java](https://github.com/future-architect/uroborosql-sample/blob/main/src/main/java/jp/co/future/uroborosql/sample/EntityApiSample.java)を参照）

## エンティティクラスを使用した検索

エンティティクラスを使用した検索を行う際は、`SqlAgent#query(エンティティクラス)`メソッドを使用して**SqlEntityQuery**を取得し、バインドパラメータの設定や検索の実行を行います。

**SqlEntityQuery**では検索結果をいくつかの形式で取得することができます。

| メソッド                 | 説明                                                                                                             |
| :----------------------- | :--------------------------------------------------------------------------------------------------------------- |
| SqlEntityQuery#collect() | 検索結果を`List<エンティティクラス>`の形式で取得する                                                             |
| SqlEntityQuery#stream()  | 検索結果を`java.util.Stream<エンティティクラス>`の形式で取得する                                                 |
| SqlEntityQuery#first()   | 検索結果の１件目を取得する。戻り値は`Optional`                                                                   |
| SqlEntityQuery#one()     | 検索結果の１件目を取得する。検索結果が複数件になる場合は`DataNonUniqueException`をスローする。戻り値は`Optional` |

まずはテーブルに紐づくエンティティクラスを作成します。

* Department.java

```java
package jp.co.future.uroborosql.sample.entity;

import jp.co.future.uroborosql.enums.GenerationType;
import jp.co.future.uroborosql.mapping.annotations.GeneratedValue;
import jp.co.future.uroborosql.mapping.annotations.Id;
import jp.co.future.uroborosql.mapping.annotations.Table;
import jp.co.future.uroborosql.mapping.annotations.Version;

/**
 * Entity that can be mapped to department table
 */
@Table(name = "department")
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long deptNo;

    private String deptName;

    @Version
    private long lockVersion;

    public long getDeptNo() {
        return this.deptNo;
    }

    public void setDeptNo(final long deptNo) {
        this.deptNo = deptNo;
    }

    public String getDeptName() {
        return this.deptName;
    }

    public void setDeptName(final String deptName) {
        this.deptName = deptName;
    }

    public long getLockVersion() {
        return this.lockVersion;
    }

    public void setLockVersion(final long lockVersion) {
        this.lockVersion = lockVersion;
    }

    @Override
    public String toString() {
        return "Department [deptNo=" + this.deptNo + ", deptName=" + this.deptName + ", lockVersion="
                + this.lockVersion + "]";
    }
}
```

`@Table`アノテーションをクラスに指定することでテーブルとの紐づけを行います。上記の場合はdepartmentテーブルと紐づけています。\
エンティティクラスの詳細については[DAOインタフェース](../basics/entity-api.md#daoインタフェース)を参照してください。

この`Department`クラスを使用した検索は以下のようになります。

```java
// no parameter : バインドパラメータ指定なしで検索
List<Department> deps1 = agent.query(Department.class)
    .collect();
// add bind parameter : バインドパラメータを設定して検索
List<Department> deps2 = agent.query(Department.class)
    .equal("deptNo", 1)
    .collect();
```

検索結果の各行が`Department`クラスのインスタンスとして取得出来ます。

## エンティティクラスを使用した行挿入

エンティティクラスを使用してテーブルに行挿入を行うことが出来ます。行挿入を行う場合は`SqlAgent#insert(エンティティクラスインスタンス)`メソッドを使用します。

```java
Department dept = new Department();
dept.setDeptName("production");
// insert entity : 行挿入
int count = agent.insert(dept);
```

## エンティティクラスを使用した行更新

エンティティクラスを使用してテーブルの行更新を行うことが出来ます。行更新を行う場合は`SqlAgent#update(エンティティクラスインスタンス)`メソッド、または`SqlAgent#update(エンティティクラス)` を使用します。

`SqlAgent#update(エンティティクラスインスタンス)` を使用する場合（検索結果を更新する場合に便利）

```java
Department dept = agent.query(Department.class)
    .first().orElseThrow(UroborosqlRuntimeException::new);
dept.setDeptName("R&D");
// update entity : 行更新
int count = agent.update(dept);
```

`SqlAgent#update(エンティティクラス)` を使用する場合（特定の項目のみを更新する場合に便利）

```java
agent.update(Department.class)
    .set("deptName", "R&D")
    .equal("deptNo", 1);
```

どちらのメソッドを利用した場合でも、`@Version` アノテーションが付与されている `lockVersion` フィールドがマッピングされる `lock_version` カラムはカウントアップされます。

## エンティティクラスを使用した行削除

エンティティクラスを使用してテーブルの行削除を行うことが出来ます。行更新を行う場合は`SqlAgent#delete(エンティティクラスインスタンス)`メソッドを使用します。

```java
Department dept = agent.query(Department.class)
    .first().orElseThrow(UroborosqlRuntimeException::new);
// delete entity : 行削除
int count = agent.delete(dept);
```

エンティティクラスを使用したDBアクセスの詳細については[DAOインタフェース](../basics/entity-api.md#daoインタフェース)を参照してください。

**uroboroSQL**ではこれらの基本的な操作のほか、バッチ処理やトランザクション処理なども行うことができます。
詳細については[基本操作](../basics/)を参照してください。

---

---
url: /uroborosql-doc/advanced/system-properties.md
---

# システムプロパティ

**uroboroSQL**ではシステムプロパティを指定することで動作を変更することができます。

| プロパティ名                        | 説明                                                                                                                                                                                                                                                 | 初期値                          |
| :---------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------ |
| uroborosql.sql.coverage             | SQLカバレッジを出力するかどうかのフラグ。`true`の場合はSQLカバレッジを出力します。文字列として`jp.co.future.uroborosql.coverage.CoverageHandler`インタフェースの実装クラスが設定された場合はそのクラスを利用してカバレッジの収集を行います。 | なし                            |
| uroborosql.sql.coverage.file        | 指定されたPATH(ファイル)に SQLカバレッジのCobertura形式のxmlレポートを出力します。                                                                                                                                                                   | ./target/coverage/sql-cover.xml |
| uroborosql.sql.coverage.dir         | 指定されたPATH(フォルダ)にSQLカバレッジのHTMLレポートを出力します。                                                                                                                                                                                  | ./target/coverage/sql           |
| uroborosql.entity.cache.size        | Entityクラス情報のキャッシュサイズを指定します。キャッシュサイズを超えるEntityクラスの読み込みがあった場合は古い情報から破棄されます。                                                                                                           | 30                              |
| uroborosql.use.qualified.table.name | DAOインタフェースで生成するSQLにスキーマ名で修飾したテーブル名を出力(`true`)するか、テーブル名のみを出力(`false`)するかを指定                                                                                                                        | true                            |

---

---
url: /uroborosql-doc/basics/transaction.md
---

# トランザクション

**uroboroSQL**ではローカルトランザクションを提供します。\
トランザクションを利用することで、エラー発生時でも一部のデータだけ登録を成功させるといった細かな制御ができるようになります。

## トランザクションの開始と終了 ( `SqlAgent#required` /`#requiredNew` /`#notSupported` )

**uroboroSQL**で提供するトランザクションのレベルは以下の3つです

| トランザクションタイプ | トランザクション有り                                                                                                                                 | トランザクションなし                       |
| :--------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------- |
| required               | トランザクション内で処理を実行                                                                                                                       | 新たなトランザクションを開始して処理を実行 |
| requiresNew            | 既存のトランザクションを停止し、新たなトランザクションを開始して処理を実行。トランザクションが終了すると停止していたトランザクションを再開させる | 新たなトランザクションを開始して処理を実行 |
| notSupported           | 既存のトランザクションを停止し、トランザクション外で処理を実行。処理が終了すると停止していたトランザクションを再開させる                         | トランザクション外で処理を実行             |

`SqlAgent`インタフェースにトランザクションタイプに応じたメソッドが提供されており、そのメソッドを呼び出すことでトランザクションの開始と終了を制御します。

```java
agent.required(() -> {
  // トランザクション開始
  agent.updateWith("insert into employee (emp_no) values (/*empNo*/1001)")
    .param("empNo", 1)
    .count();

  agent.requiresNew(() -> {
    // 新しい トランザクション開始
    agent.updateWith("insert into department (dept_no, dept_name) values (/*deptNo*/1111, /*deptName*/'Sales')")
      .param("deptNo", 2)
      .param("deptName", "export")
      .count();
    // 新しい トランザクション終了 commit
  });
  // トランザクション終了 commit
});
```

::: tip
設定によりDB更新処理の実行をトランザクション内で行うことを強制することができます。詳しくは
[DB更新処理をトランザクション内のみに強制](../configuration/sql-agent-provider.md#db更新処理をトランザクション内のみに強制)を参照してください。
:::

## コミットとロールバック ( `SqlAgent#commit` /`#setRollbackOnly` )

トランザクションのlambda式が正常に終了すればトランザクションはコミットされます。\
トランザクションのlambda式が例外をスローした場合はトランザクションをロールバックします。\
明示的にコミットを行う場合は`SqlAgent#commit()`を呼び出します。\
例外をスローせずに明示的にロールバックを行う場合は`SqlAgent#setRollbackOnly()`を呼び出します。

```java
agent.required(() -> {
  // トランザクション開始
  agent.updateWith("insert into employee (emp_no) values (/*empNo*/1001)")
    .param("empNo", 1)
    .count();

  // 新しい トランザクション開始
  agent.requiresNew(() -> {
    agent.updateWith("insert into department (dept_no, dept_name) values (/*deptNo*/1, /*deptName*/'')")
      .param("deptNo", 2)
      .param("deptName", "Production")
      .count();
    // 明示的なcommit
    agent.commit();

    agent.updateWith("insert into department (dept_no, dept_name) values (/*deptNo*/1, /*deptName*/'')")
      .param("deptNo", 3)
      .param("deptName", "export")
      .count();
    // 明示的なrollback
    agent.setRollbackOnly();
    // 新しい トランザクション終了
  });
  // トランザクション終了 commit
});
```

## セーブポイント ( `SqlAgent#setSavepoint` /`#rollback` /`#releaseSavepoint`)

トランザクション内にセーブポイントを設けることで、トランザクション内の特定の操作のみ取り消すといった細かな制御ができます。

```java
agent.required(() -> {
  // トランザクション開始
  agent.update("employee/insert_employee")
    .param("empNo", 1001)
    .count();

  // セーブポイント(名前:sp)の設定
  agent.setSavepoint("sp");
  agent.update("employee/insert_employee")
    .param("empNo", 1002)
    .count();

  assertThat(agent.query("employee/select_employee").collect().size(), 2);

  // 最後のinsertを取消(セーブポイント(名前:sp)までロールバック)
  agent.rollback("sp");

  assertThat(agent.query("employee/select_employee").collect().size(), 1);
});
```

### セーブポイントスコープ(`SqlAgent#savepointScope`)&#x20;

`SqlAgent#savepointScope()` を使用して、より確実にsavepointの制御を行うことができます。

```java
// SqlAgent#savepointScope()を使ったsavepointの実装
agent.required(() -> {
  // トランザクション開始
  agent.update("employee/insert_employee")
    .param("empNo", 1001)
    .count();

  // セーブポイントスコープの開始
  agent.savepointScope(() -> {
    agent.update("employee/insert_employee")
      .param("empNo", 1002)
      .count();

    assertThat(agent.query("employee/select_employee").collect().size(), 2);
    // savepointScope内の処理を取り消す場合は例外をスローする
    throw new UroborosqlRuntimeException();
  })
  assertThat(agent.query("employee/select_employee").collect().size(), 1);
});
```

::: tip
PostgreSQLについては、自動的にセーブポイントを利用したトランザクションの部分ロールバックに対応しています。
詳細は、[PostgreSQLのトランザクション内SQLエラー対応](../advanced/index.md#postgresqlのトランザクション内sqlエラー対応)を参照してください。
:::

## AutoCommitスコープ(`SqlAgent#autoCommitScope`)&#x20;

トランザクション制御を行うアプリケーションで `uroborosql` を利用する場合、`SqlAgent#required` などを使ったトランザクションスコープによりコミットを制御するため、
`java.sql.Connection` の自動コミット・モードを `無効(false)` にします。

しかしDBの種類によっては特定のコマンドを発行する際、自動コミット・モードを `有効(true)` にして発行を行う必要があります。

::: tip 自動コミット・モードを有効にする必要のあるコマンド
例えば postgresqlの `vacuum` コマンドはトランザクション制御下では実行できないため、自動コミット・モードを有効にする必要があります
:::

こういったケースを実現する場合、  までは以下のような実装が必要でした。

```java
agent.required(() -> {
  // トランザクション開始
  // AutoCommitの開始
  try {
    agent.getConnection().setAutoCommit(true);
  } catch (SQLException ex) {
    throw new IllegalStateException(ex);
  }

  agent.update("employee/insert_employee")
    .param("empNo", 1001)
    .count(); // この段階で更新がコミットされる

  // AutoCommitの終了
  try {
    agent.getConnection().setAutoCommit(false);
  } catch (SQLException ex) {
    throw new IllegalStateException(ex);
  }

  assertThat(agent.query("employee/select_employee").collect().size(), 1);
});
```

上記の実装では、自動コミット・モードの切替えを try-catch で囲む必要があり記述が冗長でした。

&#x20;からは SqlAgent#autoCommitScope() を使って自動コミット・モードの切替えができるようになりました。

```java
// SqlAgent#autoCommitScope()を使った実装
agent.required(() -> {
  // トランザクション開始
  // AutoCommitの開始
  agent.autoCommitScope(() -> {
    agent.update("employee/insert_employee")
      .param("empNo", 1001)
      .count(); // この段階で更新がコミットされる

    assertThat(agent.query("employee/select_employee").collect().size(), 1);
    // 例外をスローしてもコミット済みなので追加したレコードは消えない
    throw new UroborosqlRuntimeException();
  });
  // AutoCommitの終了
  assertThat(agent.query("employee/select_employee").collect().size(), 1);
});
```

## エラーハンドリング ( `UroborosqlSQLException` )

**uroboroSQL**からSQLを実行した際にSQLExceptionがスローされると、
そのSQLExceptionを内部に保持する`UroborosqlSQLException`が呼び出し元に返却されます。\
`UroborosqlSQLException`は`java.lang.RuntimeException`を継承しているため明示的なキャッチは不要です。

呼出元のアプリケーションで明示的にエラーハンドリングを行う場合は、try-catchで`UroborosqlSQLException`をキャッチすることで、
例外発生時の挙動を制御することができます。

エラーハンドリングの例

```java
SqlConfig config = UroboroSQL.builder(...).build();

try (SqlAgent agent = config.agent()) {
  // INSERT文の実行
  // insert into product (product_id) values (/*productId*/0);
  agent.update("example/insert_product")
    .param("productId", 1)
    .count();
} catch (UroborosqlSQLException ex) {
  // SQLExceptionが発生した際に行う処理を実装
  throw new Exception("exception occured. ex=" + ex.getCause().getMessage(), ex);
}
```

---

---
url: /uroborosql-doc/best_practices.md
---

# ベストプラクティス

**uroboroSQL** を使用してSQLを実行する際のベストプラクティスについて説明します。

1. [ResultSetの扱いによるメモリ効率の差異](#_1-resultsetの扱いによるメモリ効率の差異-collect-streamの違い)
2. [SELECT-INSERTやSELECT-UPDATEの実装方式の違い](#_2-select-insertやselect-updateの実装方式の違い)
3. [バッチ処理とバルク処理の違い](#_3-バッチ処理とバルク処理の違い)
4. [バッチ件数による性能の違い](#_4-バッチ件数による性能の違い)

## 1. ResultSetの扱いによるメモリ効率の差異(collect, streamの違い)

**uroboroSQL** では、検索結果の取得方法として `collect()` と `stream()` の2つのメソッドが提供されています。これらは内部的なResultSetの処理方法が異なり、メモリ使用量に大きな影響を与えます。

### collect()メソッドの特徴

`collect()` メソッドは、検索結果を **すべてメモリ上に読み込んでからList形式で返却** します。

```java
// すべての検索結果をメモリに読み込む
List<Product> products = agent.query(Product.class)
    .collect();
```

**メモリ使用の特徴:**

* 検索結果の全レコードが一度にメモリ上に展開される
* 返却されたListは検索後も保持され続ける
* 大量データの検索では OutOfMemoryError のリスクがある

**適している場面:**

* 検索結果が少量(〜100件程度)の場合
* 検索結果を複数回参照する必要がある場合
* 検索結果をソートや加工してから利用する場合

### stream()メソッドの特徴

`stream()` メソッドは、検索結果を **1件ずつ逐次的に処理するStream形式で返却** します。

```java
// 検索結果を1件ずつストリーム処理
agent.query(Product.class)
    .stream()
    .forEach(product -> processProduct(product)); // 1件ずつ処理
```

**メモリ使用の特徴:**

* 検索結果を1件ずつメモリに読み込み、処理後は破棄される
* 常に処理中の1件分のメモリしか使用しない
* 大量データでも安定したメモリ使用量を維持できる

**適している場面:**

* 検索結果が大量(100件以上)の場合
* 検索結果を1回だけ順次処理する場合
* メモリ使用量を抑制したい場合

### メモリ効率の比較

10万件のデータを処理する場合の違いを例に説明します。

**collect()を使用した場合:**

```java
// 10万件すべてがメモリに読み込まれる
List<Product> products = agent.query(Product.class)
    .collect();  // メモリ: 10万件分のオブジェクト

// 処理中もリスト全体がメモリに残る
for (Product product : products) {
    processProduct(product);
}
// 処理後もGCされるまでメモリに残る
```

**stream()を使用した場合:**

```java
// 1件ずつ処理され、処理後は解放される
agent.query(Product.class)
    .stream()
    .forEach(product -> processProduct(product));  // メモリ: 常に1件分のみ
// 処理完了後は自動的に解放される
```

### 推奨事項

* **小〜中規模のデータ(〜100件)**: `collect()` を使用して可読性とシンプルさを優先
* **大規模データ(100件以上)**: `stream()` を使用してメモリ効率を優先
* **件数が不明な場合**: `stream()` を使用して安全性を優先

特に大量データを扱うバッチ処理では、`stream()` の使用が必須となります。

## 2. SELECT-INSERTやSELECT-UPDATEの実装方式の違い

SELECT-INSERTやSELECT-UPDATEは、あるテーブルから取得したデータを別のテーブルに挿入または更新する処理です。\
**uroboroSQL** では以下の3つの実装方式があり、それぞれパフォーマンス特性が異なります。\
（以下ではSELECT-INSERTを例に解説します）

### 方式1: SQLによるSELECT-INSERT（最も高速）

データベースエンジン内で完結するため、最も高速に処理できます。

```sql
-- sample/insert_target_tables.sql
insert
into
	target_table
(
	col1
,	col2
,	col3
)
select
	col1	as	col1
,	col2	as	col2
,	col3	as	col3
from
	source_table	st
where
	st.condition	=	/*condition*/''
```

```java
// SQL内でSELECTとINSERTを同時に実行
int count = agent.update("sample/insert_target_tables")
    .param("condition", conditionValue)
    .count();
```

**特徴:**

* データベース内で処理が完結し、ネットワーク転送が不要
* トランザクション管理がシンプル
* 大量データでも高速に処理可能
* Javaアプリケーション側でのデータ加工ができない

**パフォーマンス:** ★★★★★（最速）

**適している場面:**

* データの加工が不要な単純なコピー処理
* 大量データ（数万件以上）の一括転送
* データベース間の同期処理

### 方式2: バッチ処理によるSELECT-INSERT（推奨）

検索結果をバッチでまとめてINSERTします。データ加工とパフォーマンスのバランスが良い方式です。

```java
// SELECTした結果をバッチINSERT
agent.inserts(agent.query(SourceEntity.class) // 検索結果のStreamをTargetEntityに変換しながらバッチインサートのパラメータとして渡す
    .stream()
    .map(sourceEntity -> {
        // データ加工が可能
        TargetEntity targetEntity = new TargetEntity();
        targetEntity.setCol1(sourceEntity.getCol1());
        targetEntity.setCol2(transform(sourceEntity.getCol2())); // 加工処理
        targetEntity.setCol3(sourceEntity.getCol3());
        return targetEntity;
    }));
```

**特徴:**

* Javaコード内でデータ加工が可能
* バッチサイズ単位でまとめてINSERTされる（デフォルト1,000件）
* `stream()` を使用することでメモリ効率が良い
* ネットワーク転送は発生するが、バッチ化により最小化

**パフォーマンス:** ★★★★☆（高速）

**適している場面:**

* データの加工や変換が必要な場合
* ビジネスロジックを適用する必要がある場合
* 中〜大規模データ（数千〜数十万件）の処理

### 方式3: forループによる1件ずつINSERT（非推奨）

検索結果を1件ずつ個別にINSERTします。最も遅い方式です。

```java
// SELECTした結果を1件ずつINSERT
agent.query(SourceEntity.class)
    .stream()
    .forEach(sourceEntity -> {
        // データ加工が可能
        TargetEntity target = new TargetEntity();
        target.setCol1(sourceEntity.getCol1());
        target.setCol2(transform(sourceEntity.getCol2())); // 加工処理
        target.setCol3(sourceEntity.getCol3());

        agent.insert(target);
    });
```

**特徴:**

* 1件ごとにSQL実行とネットワーク転送が発生
* データベースへの負荷が高い
* トランザクション処理のオーバーヘッドが大きい
* `collect()` を使用する場合はメモリ使用量も大きい

**パフォーマンス:** ★☆☆☆☆（低速）

**適している場面:**

* ほぼ適している場面はない（レガシーコードの互換性維持など特殊な場合のみ）

### パフォーマンス比較

10万件のデータをSELECT-INSERTする場合の目安:

| 方式                      | 処理時間の目安 | ネットワーク転送                                    | メモリ使用量        |
| ------------------------- | -------------- | --------------------------------------------------- | ------------------- |
| 方式1: SQL内SELECT-INSERT | 1-2秒          | なし                                                | 最小                |
| 方式2: バッチ処理         | 5-10秒         | バッチ単位で発生（バッチサイズ:1,000の場合、100回） | 小（streamの場合）  |
| 方式3: 1件ずつINSERT      | 数分〜         | 10万回発生                                          | 大（collectの場合） |

### 推奨事項

* **データ加工が不要な場合**: 方式1（SQL内SELECT-INSERT）を使用
* **データ加工が必要な場合**: 方式2（バッチ処理）を使用
* **方式3は原則使用しない**: パフォーマンスが著しく低下するため避ける

特に大量データを扱う場合は、方式1または方式2を選択し、必ず `stream()` を使用してメモリ効率を確保してください。

## 3. バッチ処理とバルク処理の違い

**uroboroSQL** では、複数件のデータを効率的に登録・更新する方法として **バッチ処理** と **バルク処理** の2つが提供されています。\
これらは似ているように見えますが、内部動作とパフォーマンス特性が大きく異なります。

### バッチ処理の特徴

バッチ処理は、JDBC の `PreparedStatement.addBatch()` や `PreparedStatement.executeBatch()` を使用して、**更新コマンドと複数のパラメータ値のセットをまとめてデータベースに送信** する方式です。

```java
// バッチINSERT（DAO API）
Stream<Employee> employees = agent.query(Employee.class).stream();
agent.inserts(employees);

// バッチINSERT（SQLファイル API）
Stream<Product> products = agent.query(Product.class).stream();
agent.batch("example/insert_product")
    .paramStream(products)
    .count();
```

**内部動作:**

1. PreparedStatementを1つ作成
2. パラメータをバインドして `addBatch()` でバッファに追加
3. バッチサイズ（デフォルト1,000件）に達したら `executeBatch()` で一括実行
4. 全データ処理が完了するまで繰り返し

**特徴:**

* データベースへの送信回数が大幅に削減される
* ネットワークオーバーヘッドが最小化される
* 大量データ（数千〜数十万件）の処理に適している
* メモリ使用量が安定している

**パフォーマンス:** ★★★★★（大量データで高速）

### バルク処理の特徴

バルク処理は、**1つのINSERT文で複数行を同時に登録** する方式です。

```java
// バルクINSERT（DAO API）
Stream<Employee> employees = agent.query(Employee.class).stream();
agent.inserts(employees, InsertsType.BULK);
```

生成されるSQL:

```sql
insert
into
    employee
(
    col1
,   col2
,   col3
)
values
    (?, ?, ?)
,   (?, ?, ?)
,   (?, ?, ?)  -- 3行分を1つのINSERT文で
```

**内部動作:**

1. 複数件のデータを登録するINSERT文を生成（デフォルト10件ずつ）
2. 単一のSQL文として実行
3. 全データ処理が完了するまで繰り返し

**特徴:**

* 1回のSQL実行で複数件のデータを登録
* **一度に登録するデータ件数を増やすとSQL文が巨大化し、SQL文の生成コストも増加する**
* データベースによってはSQL文の長さ制限に抵触する可能性がある
* パース時間やメモリ消費が増加する
* DBの種類によってはバルクINSERTに対応していない場合がある（例: Oracle21c まで）

**パフォーマンス:** ★★★☆☆（少量データでは高速、大量データでは不適）

### バッチ処理とバルク処理の使い分け

| 項目               | バッチ処理                          | バルク処理                       |
| ------------------ | ----------------------------------- | -------------------------------- |
| 適切なデータ件数   | 数百件〜                            | **数十件まで**                   |
| SQL実行回数        | バッチサイズ単位（例: 1,000件ごと） | バッチサイズ単位（例: 10件ごと） |
| メモリ使用量       | 安定                                | データ量に比例して増加           |
| SQL文のサイズ      | 固定                                | データ量に比例して増加           |
| ネットワーク転送量 | 最小                                | 少量                             |

### 推奨事項

* **原則バッチ処理を使用**
* 処理時間の高速化が必要で、計測によりバッチ処理よりもバルク処理のほうが早く、かつ、メモリやCPU使用量の増加を許容できる場合のみバルク処理を採用する

::: danger **重要な注意点**

バルク処理は便利ですが、**データ件数が数十件を超える場合は使用しないでください**\
SQL文が巨大化することで以下の問題が発生する可能性があります:

* データベースのSQL文長制限に抵触（例: MySQLの `max_allowed_packet` 制限）
* パース時間の増加によるパフォーマンス低下
* メモリ使用量の急増
* ネットワーク転送時のタイムアウト

大量データの処理では、必ずバッチ処理を選択してください。
:::

## 4. バッチ件数による性能の違い

バッチ処理やバルク処理では、実行時にインサート条件としてバッチサイズを指定することで何件ごとにデータベースへ送信するかを制御できます。このバッチサイズの設定値によって処理性能が大きく変わります。

### バッチサイズの指定方法

```java
// DAO APIの場合
// バッチサイズを指定（デフォルトは1,000件）
agent.inserts(employees, (ctx, count, row) -> count == 500);  // 500件ごとに送信するようInsertConditionを指定

// SQLファイル APIの場合
agent.batch("example/insert_product")
    .paramStream(products)
    .by((ctx, row) -> ctx.batchCount() == 500)  // 500件ごとに送信
    .count();
```

### バッチサイズによる性能の違い

バッチサイズが小さすぎる場合と大きすぎる場合、それぞれ異なる問題が発生します。

**バッチサイズが小さい場合（例: 10件）:**

```java
// 10件ごとに送信
agent.inserts(employees, (ctx, count, row) -> count == 10);
```

* データベースへの送信回数が増加
* ネットワークオーバーヘッドが大きくなる
* 全体の処理時間が増加

**バッチサイズが大きい場合（例: 10,000件）:**

```java
// 10,000件ごとに送信
agent.inserts(employees, (ctx, count, row) -> count == 10000);
```

* 1回の送信データ量が増加
* PreparedStatementにバインドパラメータを格納するバッファの格納量が増えることでメモリ使用量が増加
* データベースのバッファサイズを超える可能性
* ネットワークタイムアウトのリスク増加

### 最適なバッチサイズ

10万件のデータをINSERTする場合の処理時間の目安\
**（DBの性能やネットワーク環境により大きく変わるため、あくまで目安として参照してください）**

| バッチサイズ | 処理時間の目安 | データベース送信回数 | 特徴                           |
| -----------: | -------------- | -------------------: | ------------------------------ |
|         10件 | 30-40秒        |             10,000回 | 送信回数が多すぎて非効率       |
|        100件 | 12-15秒        |              1,000回 | やや送信回数が多い             |
|      1,000件 | 5-10秒         |                100回 | **バランスが良い（推奨）**     |
|      5,000件 | 6-12秒         |                 20回 | メモリ使用量増加、効果は限定的 |
|     10,000件 | 7-15秒         |                 10回 | メモリ使用量大、リスク増加     |

### 推奨事項

* **デフォルト値（1,000件）を使用**: ほとんどのケースで最適なパフォーマンスを発揮
* **特殊な要件がある場合のみ調整**:
  * メモリが非常に限られている環境: 500件程度に削減
  * 高速ネットワーク環境で超大量データ: 2,000-5,000件に増加

::: danger **調整する場合は必ず計測する**
バッチ処理やバルク処理の処理時間は環境によって最適値が異なるため、**必ず**実測して効果を確認したうえで変更すること
:::

---

---
url: /uroborosql-doc/advanced/cache-metadata.md
---

# メタデータのキャッシュ

## 概要

**uroboroSQL**では、パフォーマンスを向上させるために、各種メタデータをキャッシュする仕組みを提供しています。\
開発環境やテスト環境など、メタデータの変更が頻繁に発生する環境では、必要に応じてキャッシュをクリアすることができます。

## キャッシュの種類

**uroboroSQL**では以下の3種類のメタデータキャッシュが管理されています。

### TableMetadataキャッシュ

`DefaultEntityHandler`で管理されるテーブルメタデータのキャッシュです。

#### 特徴

| 項目                 | 内容                                                                         |
| -------------------- | ---------------------------------------------------------------------------- |
| **キャッシュ対象**   | エンティティクラスとテーブル構造の対応情報（カラム名、データ型、主キーなど） |
| **キャッシュキー**   | 接続情報（スキーマ・カタログ）とエンティティクラスの組み合わせ               |
| **キャッシュタイプ** | LRUキャッシュ（ConcurrentLruCache）                                          |
| **デフォルトサイズ** | 30エントリ                                                                   |

#### サイズの変更

システムプロパティ `uroborosql.entity.cache.size` でキャッシュサイズを変更できます。

```java
// JVM起動時のオプション
-Duroborosql.entity.cache.size=100
```

::: warning キャッシュサイズを変更する際の注意点
キャッシュサイズを大きくすると、キャッシュヒット率が向上しパフォーマンスの改善が見込めます。ただし、その分メモリ消費量が増加します。\
キャッシュサイズを変更する際は、メモリ使用量を監視し、アプリケーションへの影響がないことを確認してください。
:::

#### TableMetadataキャッシュのクリア

データベースのテーブル構造（カラムの追加・削除・変更）を行った場合、TableMetadataキャッシュに古い情報が残る可能性があります。

**対処方法**: `DefaultEntityHandler.clearCache()` の実行、またはアプリケーションの再起動

TableMetadataキャッシュは`DefaultEntityHandler`の静的フィールドとして保持されています。\
キャッシュはLRU方式で自動的に管理されるため、古いエントリは自動的に削除されますが、\
`DefaultEntityHandler.clearCache()` メソッドを使用して明示的にキャッシュをクリアすることもできます。

```java
// DefaultEntityHandlerキャッシュのクリア
DefaultEntityHandler.clearCache();
```

::: warning 注意事項
`DefaultEntityHandler.clearCache()` を実行すると、すべてのテーブルメタデータがクリアされます。\
クリア後の最初のアクセス時には、マッピング情報の再構築が行われるため、処理時間が若干増加します。
:::

### MappingColumnキャッシュ

`MappingUtils`で管理されるエンティティのフィールドとカラムのマッピング情報のキャッシュです。

#### 特徴

| 項目                 | 内容                                                                                  |
| -------------------- | ------------------------------------------------------------------------------------- |
| **キャッシュ対象**   | エンティティクラスのフィールド情報、アノテーション情報、SQL種別ごとのカラムマッピング |
| **キャッシュキー**   | スキーマ、テーブル名、エンティティクラスの組み合わせ                                  |
| **キャッシュタイプ** | LRUキャッシュ（ConcurrentLruCache）                                                   |
| **デフォルトサイズ** | 30エントリ                                                                            |

#### サイズの変更

システムプロパティ `uroborosql.entity.cache.size` でキャッシュサイズを変更できます（TableMetadataキャッシュと共通）。

```java
// JVM起動時のオプション
-Duroborosql.entity.cache.size=100
```

::: warning キャッシュサイズを変更する際の注意点
キャッシュサイズを大きくすると、キャッシュヒット率が向上しパフォーマンスの改善が見込めます。ただし、その分メモリ消費量が増加します。\
キャッシュサイズを変更する際は、メモリ使用量を監視し、アプリケーションへの影響がないことを確認してください。
:::

#### MappingColumnキャッシュのクリア

エンティティクラスのフィールドやアノテーションを変更した場合、MappingColumnキャッシュのクリアが必要です。

**対処方法**: `MappingUtils.clearCache()` の実行、またはアプリケーションの再起動

MappingColumnキャッシュは`MappingUtils`の静的フィールドとして保持されています。\
キャッシュはLRU方式で自動的に管理されるため、古いエントリは自動的に削除されますが、\
`MappingUtils.clearCache()` メソッドを使用して明示的にキャッシュをクリアすることもできます。

```java
// MappingColumnキャッシュのクリア
MappingUtils.clearCache();
```

::: warning 注意事項
`MappingUtils.clearCache()` を実行すると、すべてのエンティティクラスのマッピング情報がクリアされます。\
クリア後の最初のアクセス時には、マッピング情報の再構築が行われるため、処理時間が若干増加します。
:::

### SQL情報キャッシュ

`SqlResourceManager`で管理されるSQLファイルの内容とメタデータのキャッシュです。

#### 特徴

| 項目                 | 内容                                                          |
| -------------------- | ------------------------------------------------------------- |
| **キャッシュ対象**   | SQLファイルの内容（SQL文）、ファイルURL、ファイルスキーマ情報 |
| **キャッシュキー**   | SQL名                                                         |
| **キャッシュタイプ** | ConcurrentHashMap                                             |
| **デフォルトサイズ** | 無制限（読み込んだすべてのSQLファイルをキャッシュ）           |

#### SQLファイルの変更

アプリケーションを起動した状態でSQLファイルの内容を変更した場合、SQL情報キャッシュのクリアまたは再読み込みが必要です。

**対処方法**:`SqlResourceManager.clearCache()` の実行、またはアプリケーションの再起動

#### SQL情報キャッシュのクリア

`SqlResourceManager.clearCache()` メソッドを使用して、すべてのSQLキャッシュをクリアできます。

```java
SqlConfig config = UroboroSQL.builder("jdbc:h2:mem:test", "sa", "").build();

// すべてのSQLキャッシュをクリア
config.getSqlResourceManager().clearCache();
```

## 本番環境での注意事項

::: warning
本番環境では、キャッシュクリアによる一時的なパフォーマンス低下が発生する可能性があります。\
以下の点に注意してください：

* キャッシュクリア直後は、メタデータの再取得やSQLファイルの再読み込みが発生するため、レスポンスタイムが増加します
* 高負荷時のキャッシュクリアは避け、メンテナンスウィンドウなどの適切なタイミングで実施してください
* 可能であれば、アプリケーションの再デプロイによるキャッシュのリフレッシュを推奨します

:::

---

---
url: /uroborosql-doc/advanced/logging.md
---

# ログ出力

**uroboroSQL**ではログ出力ライブラリとしてSLF4Jを使用しています。SLF4Jの詳細は[公式のドキュメント](https://www.slf4j.org/)を参照して下さい。\
**uroboroSQL**で出力されるログ内容は以下表の通りです。

| ログ名                                     | 説明                                 | TRACE                                  | DEBUG                                                                                                                                   | INFO | WARN                                                                                                      | ERROR                                     | FATAL |
| :----------------------------------------- | :----------------------------------- | :------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------- | :--- | :-------------------------------------------------------------------------------------------------------- | :---------------------------------------- | :---- |
| jp.co.future.uroborosql.log                | サービスログ                         | SQLロード時情報                        | 実行SQL名リトライ情報                                                                                                              | -    | -                                                                                                         | エラーログ                                | -     |
| jp.co.future.uroborosql.sql                | SQLログ                              | テンプレートSQLバインドパラメータ | SQLファイルパス実行SQL                                                                                                             | -    | -                                                                                                         | -                                         | -     |
| jp.co.future.uroborosql.setting            | 設定ログ                             | -                                      | 設定時情報                                                                                                                              | -    | -                                                                                                         | -                                         | -     |
| jp.co.future.uroborosql.performance        | パフォーマンスログ                   | -                                      | SQL実行時間                                                                                                                             | -    | -                                                                                                         | -                                         | -     |
| jp.co.future.uroborosql.parser             | パーサーログ                         | -                                      | IF文評価結果                                                                                                                            | -    | -                                                                                                         | -                                         | -     |
| jp.co.future.uroborosql.coverage           | SQLカバレッジログ                    | カバレッジデータダンプ                 | -                                                                                                                                       | -    | -                                                                                                         | -                                         | -     |
| jp.co.future.uroborosql.repl               | REPLログ                             | -                                      | -                                                                                                                                       | -    | -                                                                                                         | REPLエラーログ                            | -     |
| jp.co.future.uroborosql.event.secretcolumn | イベントログ（カラム暗号化・復号化） | -                                      | -                                                                                                                                       | -    | 暗号化に失敗した場合                                                                                      | 復号化に失敗しResultSetを作成できない場合 | -     |
| jp.co.future.uroborosql.event.auditlog     | イベントログ（監査ログ）             | -                                      | 監査ログ                                                                                                                                | -    | -                                                                                                         | -                                         | -     |
| jp.co.future.uroborosql.event.debug        | イベントログ（SQLデバッグ）          | -                                      | SQLデバッグログトランザクション開始・終了パラメータ設定時SQL実行時OUTパラメータ取得時 | -    | -                                                                                                         | ログメッセージの作成に失敗した場合        | -     |
| jp.co.future.uroborosql.event.dumpresult   | イベントログ（検索結果ダンプ）       | -                                      | 検索結果のダンプログ                                                                                                                    | -    | ResultSet type が `TYPE_FORWARD_ONLY` の場合ログメッセージの作成に失敗した場合 | -                                         | -     |
| jp.co.future.uroborosql.event.replcommand  | イベントログ（REPL）                 | -                                      | REPLコマンド名                                                                                                                          | -    | -                                                                                                         | -                                         | -     |

---

---
url: /uroborosql-doc/basics.md
---

# 事前準備

**uroboroSQL**を利用した基本的なDB操作を説明します。

## DB接続

まず最初にSQLを実行するDBへの接続を行います。\
DBに接続するためには`SqlConfig`インタフェースのインスタンスを生成する必要があります。

`SqlConfig`インスタンスは`UroboroSQL`クラスのビルダーメソッドを使用して生成します。

```java
// JDBC接続を行うSqlConfigの生成
// SqlConfig config = UroboroSQL.builder(url, user, password).build();
SqlConfig config = UroboroSQL.builder("jdbc:h2:mem:uroborosql", "sa", "").build();

// DataSourceを使用したDB接続を行うSqlConfigの生成
// SqlConfig config = UroboroSQL.builder(datasource).build();
Context context = new InitialContext();
DataSource dataSource = context.lookup("java:comp/env/jdbc/datasource");
SqlConfig config = UroboroSQL.builder(dataSource).build();

```

`UroboroSQL`クラスを使って`SqlConfig`インスタンスを生成する際、**uroboroSQL**の挙動を変更する各種の設定も合わせて行うことができます。\
設定の詳細については[設定](../configuration/index.md)を参照してください。

::: warning
`SqlConfig`インスタンスはアプリケーション内で接続先毎に１つ保持するようにしてください。
SQL実行の都度生成すると、不要なインスタンスの生成やSQLロード処理が実行されます。
:::

## SqlAgentインスタンスの取得

次にすべての操作の基点となる`SqlAgent`インタフェースのインスタンスを取得します。

```java
try (SqlAgent agent = config.agent()) {
  // この中でSQLの操作を行う
}
```

SQLの操作はすべてこの`SqlAgent`インスタンスを使って行うことになります。

::: tip
`SqlAgent`インタフェースは`java.lang.AutoClosable`インタフェースを実装しており、`try-with-resources`で記述することで終了時に自動的にclose処理が呼び出され、中で保持しているConnectionやPreparedStatementなどのリソースオブジェクトも正しくクローズされます。
:::

## SQLファイルの配置

**uroboroSQL**ではSQL文の書かれたファイルのパスを指定してSQLを実行することができます。\
その際、SQLファイルはクラスパスから参照できる場所に配置されている必要があります。

```txt
src
    └─main
        └─resources
            └─sql
                ├─department
                │    ├─insert_department.sql
                │    └─select_department.sql
                └─employee
                     ├─insert_employee.sql
                     └─select_employee.sql
```

上のようなフォルダ構成の場合で、`src/main/resources/`をクラスパスに指定すれば、
その下の`sql`フォルダをルートフォルダとした相対パスでSQLファイルを指定することができます。

::: tip
SQLファイルのルートフォルダ（初期値：`sql`)は変更することができます。\
変更方法の詳細は [SQLファイルルートフォルダの設定](../configuration/sql-resource-manager.md#sqlファイルルートフォルダの設定) を参照してください。
:::

## SQL名

SQLファイルの指定する際のファイルパスを`SQL名`といいます。\
上記フォルダ構成の場合、それぞれのSQLファイルは以下のような`SQL名`となります。

| SQLファイルパス（SQLルートフォルダから） | SQL名                        |
| :--------------------------------------- | :--------------------------- |
| department/insert\_department.sql         | department/insert\_department |
| department/select\_department.sql         | department/select\_department |
| employee/insert\_employee.sql             | employee/insert\_employee     |
| employee/select\_employee.sql             | employee/select\_employee     |

SQLファイルの配置は設定によりカスタマイズが可能です。SQLファイル配置のカスタマイズについては [SQLファイルの解決ルール](../advanced/#sqlファイルの解決ルール) を参照してください。

## 共通API

検索([SqlQuery](https://github.com/future-architect/uroborosql/blob/main/src/main/java/jp/co/future/uroborosql/fluent/SqlQuery.java))、更新([SqlUpdate](https://github.com/future-architect/uroborosql/blob/main/src/main/java/jp/co/future/uroborosql/fluent/SqlUpdate.java))、バッチ更新([SqlBatch](https://github.com/future-architect/uroborosql/blob/main/src/main/java/jp/co/future/uroborosql/fluent/SqlBatch.java))、ストアドプロシージャ実行([Procedure](https://github.com/future-architect/uroborosql/blob/main/src/main/java/jp/co/future/uroborosql/fluent/Procedure.java))を行うクラスは、バインドパラメータや置換文字列の設定を行うためのAPI([SqlFluent](https://github.com/future-architect/uroborosql/blob/main/src/main/java/jp/co/future/uroborosql/fluent/SqlFluent.java))を実装しています。

バインドパラメータや置換文字列の設定はこのAPIを利用して設定を行ってください。\
流れるAPI(Fluent API)を採用しているため、値の設定は連続して行うことができるようになっています。

パラメータ設定例

```java
Map<String, Object> department = agent.query("department/select_department")
  .param("deptNo", 1)
  .param("deptName", "sales")
  .first();
```

| 主なメソッド                                                           | 説明                                                                                   |
| :--------------------------------------------------------------------- | :------------------------------------------------------------------------------------- |
| \<V> SqlFluent#param(String key, V value)                            | バインドパラメータや置換文字列として使用するキーと値のセットを設定する                 |
| \<V> SqlFluent#param(String key, V value, SQLType sqlType)           | SQLTypeを指定して値を設定する                                                          |
| \<V> SqlFluent#param(String key, V value, int sqlType)               | SQLTypeを表すint型を指定して値を設定する                                               |
| \<V> SqlFluent#param(String key, Supplier\<V> supplier)            | supplierの評価結果をキーの値としてパラメータに設定する          |
| \<V> SqlFluent#paramIfAbsent(String key, V value)                    | 指定したキーがまだ登録されていない場合に値を設定する                                   |
| \<V> SqlFluent#paramIfAbsent(String key, V value, SQLType sqlType)   | 指定したキーがまだ登録されていない場合にSQLTypeを指定して値を設定する                  |
| \<V> SqlFluent#paramIfAbsent(String key, V value, int sqlType)       | 指定したキーがまだ登録されていない場合にSQLTypeを表すint型を指定して値を設定する       |
| \<V> SqlFluent#paramIfNotEmpty(String key, V value)                  | 指定した値が空文字、空配列、空List以外の場合に値を設定する                             |
| \<V> SqlFluent#paramIfNotEmpty(String key, V value, SQLType sqlType) | 指定した値が空文字、空配列、空List以外の場合にSQLTypeを指定して値を設定する            |
| \<V> SqlFluent#paramIfNotEmpty(String key, V value, int sqlType)     | 指定した値が空文字、空配列、空List以外の場合にSQLTypeを表すint型を指定して値を設定する |
| SqlFluent#paramMap(Map\<String, ?> paramMap)                         | 引数のMapのKey/Valueのセットをパラメータに設定する                                     |
| \<V> SqlFluent#paramBean(V bean)                                     | 引数として渡されたbeanのフィールド名と値のセットをパラメータに設定する                 |

他にもパラメータの型に応じたパラメータ設定メソッドが提供されています。

::: tip 配列型の指定
DBの種類によっては配列型をサポートしています。（postgresqlなど）\
バインドパラメータで配列型を利用する場合、以下のようにJavaの配列を値としてparamメソッドに渡してください

* Java実装例

```java
agent.query("select_with_array")
  .param("arrayValues", new String[] {"1", "2"})
  .first();
```

* SQL例

```sql
select
  st.val
from sample_table st
where 1 = 1
and st.val = ANY(/*arrayValues*/)
```

:::

---

---
url: /uroborosql-doc/background/el.md
---

# 式言語

**uroboroSQL**では、条件分岐に式言語を利用することができます。\
利用可能な式言語は以下の２つになります。

* [Spring Expression Language(SpEL)](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions) &#x20;
* [OGNL](https://github.com/jkuhnert/ognl)

利用する式言語の切替は依存関係ライブラリの指定により行ってください。\
依存関係ライブラリの指定については[環境設定](../getting_started/index.md#ビルドツールの設定)を参照してください。

条件分岐の評価式として使用する場合、評価結果が真偽値(true/false)になるように記述してください。

## Spring Expression Language(SpEL)

以下に式言語としてSpring Expression Language(SpEL)を利用する場合の基本文法を提示します。\
SpEL文法の詳細は[こちら](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-language-ref)を参照してください。

### リテラル(SpEL)

以下のリテラルが使用できます。

* 文字列はシングルクォートで囲む。シングルクォート自体を使用する場合はシングルクォートを２つ重ねる('')
* 数字や真偽値、nullはそのまま記述

### 演算子(SpEL)

以下の演算子が使用できます。

### 算術演算子(SpEL)

* e1 + e2 (足し算)
* e1 - e2 (引き算)
* e1 \* e2 (掛け算)
* e1 / e2, e1 div e2 (割り算)
* e1 % e2, e1 mod e2 (余り)

### 比較演算子(SpEL)

* e1 eq e2, e1 == e2 (等しい)
  * e1・e2のいずれかがnullの場合、両方ともnullの時のみe1とe2は等しい
  * e1・e2が同じオブジェクトの場合、またはequals()メソッドにより等しいと判断される場合、e1とe2は等しい
  * e1・e2が数値の場合、倍精度浮動小数点数が等しい時のみe1とe2は等しい
  * その以外の場合、e1とe2は等しくない
* e1 ne e2, e1 != e2 (等しくない)
* e1 lt e2, e1 < e2 (小なり)
* e1 le e2, e1 <= e2 (小なりイコール)
* e1 gt e2, e1 > e2 (大なり)
* e1 ge e2, e1 >= e2 (大なりイコール)

### 論理演算子(SpEL)

* e1 or e2 (論理和)
* e1 and e2 (論理積)
* not e, ! e (論理否定)

### 連結演算子(SpEL)

* e1 + e2 (文字列連結)

### その他の演算子(SpEL)

* instanceof (型判定)
  * ex) 'xyz' instanceof T(int) // false T() はタイプ（型）を表す
* matches (正規表現)
  * ex) '5.00' matches '^\[0-9]{2}$' // false

### メソッド・フィールドの呼び出し(SpEL)

以下のようにメソッド・フィールドの呼び出しができます。

* e.method(args) (メソッドの呼び出し)
* e.property (フィールドの呼び出し)
* T(type).staticMethod(args) (staticメソッドの呼び出し)

## OGNL

以下に式言語としてOGNLを利用する場合の基本文法を提示します。\
OGNL文法の詳細は[こちら](https://commons.apache.org/proper/commons-ognl/language-guide.html)を参照してください。

### リテラル(OGNL)

以下のリテラルが使用できます。

* “a”(java.lang.String)
* 'a'(char)
* 1(int)
* 1L(long)
* 0.1F(float)
* 0.1D(double)
* 0.1B(java.math.BigDecimal)
* 1H(java.math.BigInteger)
* true, false(Boolean)
* null

### 演算子(OGNL)

以下の演算子が使用できます。

### 算術演算子(OGNL)

* e1 + e2 (足し算)
* e1 - e2 (引き算)
* e1 \* e2 (掛け算)
* e1 / e2 (割り算)
* e1 % e2 (余り)

### 比較演算子(OGNL)

* e1 eq e2, e1 == e2 (等しい)
  * e1・e2のいずれかがnullの場合、両方ともnullの時のみe1とe2は等しい
  * e1・e2が同じオブジェクトの場合、またはequals()メソッドにより等しいと判断される場合、e1とe2は等しい
  * e1・e2が数値の場合、倍精度浮動小数点数が等しい時のみe1とe2は等しい
  * その以外の場合、e1とe2は等しくない
* e1 neq e2, e1 != e2 (等しくない)
* e1 lt e2, e1 < e2 (小なり)
* e1 lte e2, e1 <= e2 (小なりイコール)
* e1 gt e2, e1 > e2 (大なり)
* e1 gte e2, e1 >= e2 (大なりイコール)

### 論理演算子(OGNL)

* e1 or e2, e1 || e2 (論理和)
* e1 and e2, e1 && e2 (論理積)
* not e, ! e (論理否定)

### 連結演算子(OGNL)

* e1 + e2 (文字列連結)

### メソッド・フィールドの呼び出し(OGNL)

以下のようにメソッド・フィールドの呼び出しができます。

* e.method(args) (メソッドの呼び出し)
* e.property (フィールドの呼び出し)

## SqlFunction(SF)

**uroboroSQL**では評価式を利用する際、標準で`SqlFunction`（SF）を使用することができます。
評価式と合わせて`SqlFunction`クラスのメソッドを呼び出すことができます。

* 評価式で使用する場合

```sql
/*IF SF.isNotEmpty(emp_no)*/
  -- emp_noが null または 空 でない場合に処理される
/*END*/
```

* バインドパラメータと合わせて使用する場合

```sql
emp_name like /*SF.contains(emp_name)*/'' escape '$'
-- emp_name=Bobの場合、 emp_name like %Bob% escape '$' となる
```

* `SqlFunction`が提供するメソッドの一覧

| メソッド名                                           | 戻り値   | 説明                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| :--------------------------------------------------- | :------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SF.isEmpty(Object obj)                               | boolean  | 指定したオブジェクトが空であること判定する。指定したオブジェクトがOptional型の場合は、その中身を評価する。 では、従来の文字列中心の判定仕様を見直し、List型などのコレクションを含む文字列以外のオブジェクトについても一貫した空判定が行われるように仕様を変更している。判定の詳細は[Javadoc](https://www.javadoc.io/doc/jp.co.future/uroborosql/latest/jp/co/future/uroborosql/utils/SqlFunction.html)のisEmptyメソッドを参照のこと。        |
| SF.isNotEmpty(Object obj)                            | boolean  | 指定したオブジェクトが空でないことを判定する。指定したオブジェクトがOptional型の場合は、その中身を評価する。 では、従来の文字列中心の判定仕様を見直し、List型などのコレクションを含む文字列以外のオブジェクトについても一貫した非空判定が行われるように仕様を変更している。判定の詳細は[Javadoc](https://www.javadoc.io/doc/jp.co.future/uroborosql/latest/jp/co/future/uroborosql/utils/SqlFunction.html)のisNotEmptyメソッドを参照のこと。 |
| SF.isBlank(Object obj)                               | boolean  | 指定したオブジェクトの文字列表現が空、もしくは空白であること判定する                                                                                                                                                                                                                                                                                                                                                                                                         |
| SF.isNotBlank(Object obj)                            | boolean  | 指定したオブジェクトの文字列表現が空、もしくは空白でないこと判定する                                                                                                                                                                                                                                                                                                                                                                                                         |
| SF.trim(Object obj)                                  | String   | 文字列の前後の空白を除去する。nullを渡した場合は結果もnullとなる                                                                                                                                                                                                                                                                                                                                                                                                             |
| SF.trimToEmpty(Object obj)                           | String   | 文字列の前後の空白を除去する。nullを渡した場合は空文字となる                                                                                                                                                                                                                                                                                                                                                                                                                 |
| SF.left(String str, int len)                         | String   | 文字列の先頭から指定した文字数の文字列を取得する                                                                                                                                                                                                                                                                                                                                                                                                                             |
| SF.right(String str, int len)                        | String   | 文字列の最後から指定した文字数の文字列を取得する                                                                                                                                                                                                                                                                                                                                                                                                                             |
| SF.mid(String str, int pos, int len)                 | String   | 文字列の指定した位置から指定した文字数の文字列を取得する                                                                                                                                                                                                                                                                                                                                                                                                                     |
| SF.rightPad(String str, int size)                    | String   | 文字列の末尾に空白を埋めて指定された長さにする                                                                                                                                                                                                                                                                                                                                                                                                                               |
| SF.rightPad(String str, int size, char padChar)      | String   | 文字列の末尾に指定した埋め込み文字を埋めて指定された長さにする                                                                                                                                                                                                                                                                                                                                                                                                               |
| SF.leftPad(String str, int size)                     | String   | 文字列の先頭に空白を埋めて指定された長さにする                                                                                                                                                                                                                                                                                                                                                                                                                               |
| SF.leftPad(String str, int size, char padChar)       | String   | 文字列の先頭に指定した埋め込み文字を埋めて指定された長さにする                                                                                                                                                                                                                                                                                                                                                                                                               |
| SF.split(String str)                                 | String\[] | 文字列を空白で区切って配列に格納する。nullが入力された場合はnullを返す                                                                                                                                                                                                                                                                                                                                                                                                       |
| SF.split(String str, char separatorChar)             | String\[] | 文字列を指定した区切り文字で区切って配列に格納する。nullが入力された場合はnullを返す                                                                                                                                                                                                                                                                                                                                                                                         |
| SF.split(String str, String separatorChars, int max) | String\[] | 文字列を指定した区切り文字で区切って配列に格納する。nullが入力された場合はnullを返す                                                                                                                                                                                                                                                                                                                                                                                         |
| SF.capitalize(String str)                            | String   | 文字列の先頭文字を大文字にする                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| SF.uncapitalize(String str)                          | String   | 文字列の先頭を小文字にする                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| SF.startsWith(CharSequence text)                     | String   | 指定されたテキストで始まるLIKE句用の検索文字列を生成する。引数のテキストはエスケープ処理される                                                                                                                                                                                                                                                                                                                                                        |
| SF.contains(CharSequence text)                       | String   | 指定されたテキストを含むLIKE句用の検索文字列を生成する。引数のテキストはエスケープ処理される                                                                                                                                                                                                                                                                                                                                                          |
| SF.endsWith(CharSequence text)                       | String   | 指定されたテキストで終わるLIKE句用の検索文字列を生成する。数のテキストはエスケープ処理される                                                                                                                                                                                                                                                                                                                                                          |

---

---
url: /uroborosql-doc/advanced/update-delegate.md
---

# 更新処理の委譲

Webアプリケーションを作成する場合、以下のような流れで画面からの登録処理を行うことがあります。

1. データ検証（データの存在有無や重複チェック、データの整合性チェックなど）
2. 登録、更新処理

その際、より厳密に一度 「1. データ検証」だけを実施し、問題がなければ再度「1.データ検証」 と 「2.登録、更新処理」 を合わせて処理を行うことがあります。\
この場合 「1.データ検証」だけを行うモードかどうかをフロントエンドから渡し、
それによって 「1. データ検証」 と 「2.登録、更新処理」 を実行するか分岐することになります。

* 個別処理での実装イメージ

```java
if (request.isCheckMode()) {
  // 1. データ検証（データ検証用のQuery発行）
  validateData(request);
} else {
  // 1. データ検証（データ検証用のQuery発行）
  validateData(request);
  // 2. 登録、更新処理
  createData(request);
}
```

このような処理を個別実装で行うと実装漏れが起こりやすく、テストも大変になります。\
`更新処理の委譲` を利用することで、データ検証を行うモードの場合には更新処理をスキップする、といった動作を一律指定することが出来ます。

`更新処理の委譲` を利用する場合、ExecutionContextに委譲用のFunctionを指定します。

* setUpdateDelegate 実装例

```java
SqlUpdate update = agent.update("example/update_product")
  .set("productName", "new_name")
  .set("janCode", "1234567890123")
  .equal("productId", 1);
ExecutionContext ctx = update.context();
ctx.setUpdateDelegate(context -> 2); // 更新の委譲処理。登録する Function は 引数として ExecutionContext を受取り、int（更新件数）を返却する
update.count(); // SQLは発行されず、代わりに委譲用のFunctionが実行され戻り値 2 が返る
```

ExecutionContext#setUpdateDelegate() は通常 [イベントハンドラーの設定](../configuration/event-listener-holder.html#eventlistenerholder-%E3%81%A8-eventsubscriber) と合わせて利用します。

* EventSubscriberでのExecutionContext#setUpdateDelegate()の設定例

```java
/**
 * 更新処理委譲イベントサブスクライバー
 **/
public class UpdateDelegateEventSubscriber extends EventSubscriber {
    @Override
    public void initialize() {
      beforeParseSqlListener(this::onBeforeParseSql);
    }

    /**
     * SQLパース前のイベントを処理する.
     *
     * @param event イベント
     */
    protected void onBeforeParseSql(final BeforeParseSqlEvent event) {
      switch (event.getExecutionContext().getSqlKind()) {
        case INSERT,
             MERGE,
             UPDATE,
             BATCH_INSERT,
             BATCH_UPDATE,
             BULK_INSERT,
             ENTITY_BATCH_INSERT,
             ENTITY_BULK_INSERT,
             ENTITY_INSERT,
             ENTITY_UPDATE -> {
                if (チェックモードなら) {
                  ExecutionContext ctx = event.getExecutionContext();
                  ctx.setUpdateDelegate(context -> 1);
                }
             };
        default -> {}
      }
    }
}
```

* setUpdateDelegateを利用した実装イメージ

```java
// 1. データ検証（データ検証用のQuery発行）
validateData(request);
// 2. 登録、更新処理　（チェックモードの場合はsetUpdateDelegateにより更新SQLの発行が行われない）
createData(request);
```

---

---
url: /uroborosql-doc/getting_started.md
---

# 環境設定

## ビルドツールの設定

**uroboroSQL**をMavenプロジェクトに組み込むには、**pom.xml**に以下のライブラリ依存関係を追加してください。
**uroboroSQL**は[Maven Central Repository](https://central.sonatype.com/artifact/jp.co.future/uroborosql)で公開されています。

```xml
<dependency>
  <groupId>jp.co.future</groupId>
  <artifactId>uroborosql</artifactId>
  <version>1.0.10</version>
</dependency>
```

また、 より式言語ライブラリの選択が可能になりました。\
以下の2つのライブラリのうち、**どちらか** を選択してライブラリ依存関係に追加して下さい。

[Spring Expression Language(SpEL)](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions)を利用する場合&#x20;

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-expression</artifactId>
  <version>5.3.24</version>
</dependency>
```

[OGNL](https://github.com/jkuhnert/ognl)を利用する場合

```xml
<dependency>
  <groupId>ognl</groupId>
  <artifactId>ognl</artifactId>
  <version>3.3.4</version>
</dependency>
```

**uroboroSQL**でREPLを使用する場合は追加で以下のライブラリ依存関係を追加してください。

```xml
<dependency>
  <groupId>org.jline</groupId>
  <artifactId>jline</artifactId>
  <version>3.21.0</version>
</dependency>
<dependency>
  <groupId>org.fusesource.jansi</groupId>
  <artifactId>jansi</artifactId>
  <version>2.4.0</version>
</dependency>
```

Gradleプロジェクトの場合は、**build.gradle**のdependencies内に以下のライブラリ依存関係を追加してください。

```groovy
compile group: 'jp.co.future', name: 'uroborosql', version: '1.0.10'

// 式言語ライブラリとしてSpring Expression Language(SpEL)を使用する場合
compile group: 'org.springframework', name: 'spring-expression', version: '5.3.24'
// 式言語ライブラリとしてOGNLを使用する場合
compile group: 'ognl', name: 'ognl', version: '3.3.4'

// REPLを使用する場合
compile group: 'org.jline', name: 'jline', version: '3.21.0'
compile group: 'org.fusesource.jansi', name: 'jansi', version: '2.4.0'
```

::: tip
uroboroSQLを利用するためには、Java11以上の環境が必要です。
:::

::: warning ライブラリ依存関係指定時の注意
Spring Expression Language(SpEL) や OGNL をライブラリ依存関係に追加する際は、**かならず** どちらか一方のみを指定するようにしてください。\
両方のライブラリを依存に追加すると予期しない動作を発生させ、不具合の原因になります。
:::

## 事前準備

事前準備として、

* Java11以上のJDKディストリビューション
  * [Eclipse Temurin](https://adoptium.net/temurin/releases/)
  * [AdoptOpenJDK](https://adoptopenjdk.net/index.html)
  * [Amazon Corretto](https://aws.amazon.com/jp/corretto/)
  * [Oracle JDK](https://www.oracle.com/java/technologies/downloads/)
* [Apache Maven](https://maven.apache.org/download.cgi) のv3.3.1以上のバージョン

をインストールしてください。

## サンプルプロジェクトの実行

**uroboroSQL**のサンプルアプリケーションである[uroborosql-sample](https://github.com/future-architect/uroborosql-sample)を使って**uroboroSQL**を動かしてみましょう。

まず始めに[uroborosql-sample](https://github.com/future-architect/uroborosql-sample)から最新のソースコードを取得します。

```sh
git clone https://github.com/future-architect/uroborosql-sample.git
```

取得できたらcloneしたフォルダに移動します。

```sh
cd uroborosql-sample
```

まずはサンプルアプリケーションを実行してみましょう。
サンプルアプリケーションは以下の起動コマンドで実行します。

```sh
mvn -PrunMain
```

これでサンプルアプリケーションが実行されます。\
（初回実行時は必要なライブラリをダウンロードするため時間がかかります）\
アプリケーションの実行ログが出力され、Mavenが正常終了すれば成功です。
色々ログが流れますが、この中で

* DB接続
* テーブル作成と初期データの挿入
* SQLによる検索
* トランザクション
* SQLによる挿入、更新、削除
* バッチ更新

といった一連の処理が実行されています。

## サンプルプロジェクトの構成

ではサンプルアプリケーションの構成を見ていきましょう。

```txt
uroborosql-sample
├─REPL
│      repl.properties
│      
└─src
   └─main
       ├─java
       │  └─jp
       │      └─co
       │          └─future
       │              └─uroborosql
       │                  └─sample
       │                      │  AbstractApiSample.java
       │                      │  Main.java
       │                      │  EntityApiSample.java
       │                      │  SqlFileApiSample.java
       │                      │  
       │                      ├─entity
       │                      │      Department.java
       │                      │      Employee.java
       │                      │      DeptEmp.java
       │                      │      
       │                      └─type
       │                              Gender.java
       │                              
       └─resources
           │  logback.xml
           │  
           ├─data
           │      department.tsv
           │      dept_emp.tsv
           │      employee.tsv
           │      
           └─sql
               ├─ddl
               │      create_tables.sql
               │      
               ├─setup
               │       insert_data.sql
               │      
               ├─department
               │      insert_department.sql
               │      select_department.sql
               │      
               ├─employee
               │      insert_employee.sql
               │      select_employee.sql
               │      update_employee.sql
               │      
               └─relation
                      insert_dept_emp.sql
                      select_dept_emp.sql

```

主要なファイルの説明です

| ファイル                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 説明                                                                                                                |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------ |
| [Main.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/Main.java)                                                                                                                                                                                                                                                                                                                                | uroborosql-sampleのメインプログラムです。ここから各サンプルコードの呼び出しを行っています。                         |
| [SqlFileApiSample.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/SqlFileApiSample.java) / [EntityApiSample.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/EntityApiSample.java)                                                                                                                                          | 提供されているAPIの種類毎のサンプルコードです。                                                                     |
| [Department.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/entity/Department.java) / [Employee.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/entity/Employee.java) / [DeptEmp.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/entity/DeptEmp.java) | テーブル構造を表すエンティティクラスです。サンプルコードの中で使用します。                                          |
| [Gender.java](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/java/jp/co/future/uroborosql/sample/type/Gender.java)                                                                                                                                                                                                                                                                                                                       | 性別を表すEnumクラスです。サンプルコードの中で使用します。                                                          |
| [sqlフォルダ配下のSQL](https://github.com/future-architect/uroborosql-sample/tree/master/src/main/resources/sql)                                                                                                                                                                                                                                                                                                                                                     | uroborosqlで実行するSQLファイルです。                                                                               |
| [dataフォルダ配下のTSV](https://github.com/future-architect/uroborosql-sample/tree/master/src/main/resources/data)                                                                                                                                                                                                                                                                                                                                                   | テーブルデータ作成用のTSVファイルです。Mainクラスの中でテーブルへの一括データ投入を行う際のデータとして利用します。 |
| [logback.xml](https://github.com/future-architect/uroborosql-sample/blob/master/src/main/resources/logback.xml)                                                                                                                                                                                                                                                                                                                                                      | ログ出力設定ファイルです。                                                                                          |

---

---
url: /uroborosql-doc/developer_guide.md
---

# 開発者ガイド

uroboroSQLを開発する人向けのガイドです

## ソースコードの取得

[GitHub](https://github.com/future-architect/uroborosql)からソースをクローンする。

```sh
git clone https://github.com/future-architect/uroborosql.git
```

## ソースのビルド

ビルドには[Apache Maven](https://maven.apache.org/)を利用します。

```sh
mvn compile
```

## テスト

テストは[JUnit](http://junit.org/junit4/)で行います。

```sh
mvn test
```

カバレッジは[Jacoco](http://www.eclemma.org/jacoco/)で確認することができます。

```sh
mvn test jacoco:report
```

target/site/jacoco フォルダにjacocoカバレッジレポートが出力されます。

開発を行う際は、Jadocコメントが正しく記載されているようにしてください。\
javadocプラグインでjavadocを生成し、エラーが出力されないことを確認してください。

```sh
mvn javadoc:javadoc
```

## Mavenローカルリポジトリへのインストール

```sh
mvn install
```

## IDE

### Eclipse

クローンしたフォルダをEclipseの既存Mavenプロジェクトとしてインポートしてください。\
MavenのinitializeフェーズでEclipseプロジェクトの文字コードをUTF-8にする設定が入っているので、インポートが完了すれば開発が始められる状態になります。

### Intellij

Import Project でクローンしたフォルダを指定してください。\
Import project from external model でMavenを選択してください。\
プロジェクトが読み込まれると開発が始められる状態になります。

## Continuous Integration

Continuous Integration(CI)はGitHub Actionsで行っています。

また、CIと合わせてカバレッジレポートを[Coveralls](https://coveralls.io/github/future-architect/uroborosql)で公開しています。

* <https://coveralls.io/github/future-architect/uroborosql>

## Issue Management

IssueとPullRequestはGithubの機能を利用しています。\
コメントは英語で記載をお願いします。（Google翻訳がお勧めです）

* <https://github.com/future-architect/uroborosql/issues>
* <https://github.com/future-architect/uroborosql/pulls>
