(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,s,i=e[0],l=e[1],c=e[2],u=0,d=[];u<i.length;u++)s=i[u],Object.prototype.hasOwnProperty.call(a,s)&&a[s]&&d.push(a[s][0]),a[s]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);d.length;)d.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,i=1;i<t.length;i++){var l=t[i];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=s(s.s=t[0]))}return n}var r={},a={1:0},o=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,i=document.createElement("script");i.charset="utf-8",i.timeout=120,s.nc&&i.setAttribute("nonce",s.nc),i.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"e1a5c61f",3:"f74bbe9d",4:"93701c86",5:"7af68e87",6:"a5fdc69f",7:"a6e58161",8:"8d22e40d",9:"04c18d6d",10:"1663d500",11:"0614fdda",12:"6064d663",13:"fe09fe32",14:"fc231e30",15:"49279ee3",16:"6ae6757c",17:"b992cbad",18:"95fa51cf",19:"68c10ff1",20:"156efa43",21:"eb299bbe",22:"9466963c",23:"7a77a636",24:"b162d445",25:"b1a51fbb",26:"1b4bd17a",27:"05b4e69b",28:"4c32ba70",29:"bfdf3542",30:"3b44c701",31:"6bab11b7",32:"733d5055",33:"57f384f9",34:"20af6add"}[n]+".js"}(n);var l=new Error;o=function(e){i.onerror=i.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:i})}),12e4);i.onerror=i.onload=o,document.head.appendChild(i)}return Promise.all(e)},s.m=n,s.c=r,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)s.d(t,r,function(e){return n[e]}.bind(null,r));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/uroborosql-doc/",s.oe=function(n){throw console.error(n),n};var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=e,i=i.slice();for(var c=0;c<i.length;c++)e(i[c]);var p=l;o.push([49,0]),t()}([function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(24),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){var r=t(68),a=t(71);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";function r(n,e,t,r,a,o,s,i){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):a&&(l=i?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(6),a=t(53),o=t(54),s=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(1).Symbol;n.exports=r},function(n,e,t){var r=t(58),a=t(59),o=t(60),s=t(61),i=t(62);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(26);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(2)(Object,"create");n.exports=r},function(n,e,t){var r=t(80);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(20);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,u=r.easing;return l.offsetWidth,s((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),i(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,p,u)),1===n?(i(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){i(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,s=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),p=document.querySelector(r.parent);return i(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&d(a),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),i=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){var r=t(52),a=t(4),o=Object.prototype,s=o.hasOwnProperty,i=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&s.call(n,"callee")&&!i.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(2)(t(1),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(72),a=t(79),o=t(81),s=t(82),i=t(83);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(0),a=t(20),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(s.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(5),a=t(4);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(7),a=t(63),o=t(64),s=t(65),i=t(66),l=t(67);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=s,c.prototype.has=i,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(5),a=t(15);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(84),a=t(4);n.exports=function n(e,t,o,s,i){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,s,n,i))}},function(n,e,t){var r=t(31),a=t(87),o=t(32);n.exports=function(n,e,t,s,i,l){var c=1&t,p=n.length,u=e.length;if(p!=u&&!(c&&u>p))return!1;var d=l.get(n),m=l.get(e);if(d&&m)return d==e&&m==n;var f=-1,g=!0,h=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++f<p;){var y=n[f],v=e[f];if(s)var q=c?s(v,y,f,e,n,l):s(y,v,f,n,e,l);if(void 0!==q){if(q)continue;g=!1;break}if(h){if(!a(e,(function(n,e){if(!o(h,e)&&(y===n||i(y,n,t,s,l)))return h.push(e)}))){g=!1;break}}else if(y!==v&&!i(y,v,t,s,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var r=t(16),a=t(85),o=t(86);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=a,s.prototype.has=o,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(97),a=t(103),o=t(37);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(1),a=t(99),o=e&&!e.nodeType&&e,s=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=s&&s.exports===o?r.Buffer:void 0,l=(i?i.isBuffer:void 0)||a;n.exports=l}).call(this,t(22)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(100),a=t(101),o=t(102),s=o&&o.isTypedArray,i=s?a(s):r;n.exports=i},function(n,e,t){var r=t(27),a=t(18);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(2)(t(1),"Set");n.exports=r},function(n,e,t){var r=t(15);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(42),a=t(11);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(0),a=t(19),o=t(114),s=t(117);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(50),a=t(55),o=t(126),s=t(134),i=t(143),l=t(48),c=o((function(n){var e=l(n);return i(e)&&(e=void 0),s(r(n,1,i,!0),a(e,2))}));n.exports=c},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,s=parseInt,i="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=i||l||Function("return this")(),p=Object.prototype.toString,u=Math.max,d=Math.min,m=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var i=a.test(n);return i||o.test(n)?s(n.slice(2),i?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,s,i,l,c=0,p=!1,h=!1,y=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,o=a;return r=a=void 0,c=e,s=n.apply(o,t)}function q(n){return c=n,i=setTimeout(_,e),p?v(n):s}function b(n){var t=n-l;return void 0===l||t>=e||t<0||h&&n-c>=o}function _(){var n=m();if(b(n))return S(n);i=setTimeout(_,function(n){var t=e-(n-l);return h?d(t,o-(n-c)):t}(n))}function S(n){return i=void 0,y&&r?v(n):(r=a=void 0,s)}function E(){var n=m(),t=b(n);if(r=arguments,a=this,l=n,t){if(void 0===i)return q(l);if(h)return i=setTimeout(_,e),v(l)}return void 0===i&&(i=setTimeout(_,e)),s}return e=g(e)||0,f(t)&&(p=!!t.leading,o=(h="maxWait"in t)?u(g(t.maxWait)||0,e):o,y="trailing"in t?!!t.trailing:y),E.cancel=function(){void 0!==i&&clearTimeout(i),c=0,r=l=a=i=void 0},E.flush=function(){return void 0===i?s:S(m())},E}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(149)},function(n,e,t){var r=t(23),a=t(51);n.exports=function n(e,t,o,s,i){var l=-1,c=e.length;for(o||(o=a),i||(i=[]);++l<c;){var p=e[l];t>0&&o(p)?t>1?n(p,t-1,o,s,i):r(i,p):s||(i[i.length]=p)}return i}},function(n,e,t){var r=t(6),a=t(13),o=t(0),s=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(s&&n&&n[s])}},function(n,e,t){var r=t(5),a=t(4);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(6),a=Object.prototype,o=a.hasOwnProperty,s=a.toString,i=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,i),t=n[i];try{n[i]=void 0;var r=!0}catch(n){}var a=s.call(n);return r&&(e?n[i]=t:delete n[i]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(56),a=t(112),o=t(21),s=t(0),i=t(123);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?s(n)?a(n[0],n[1]):r(n):i(n)}},function(n,e,t){var r=t(57),a=t(111),o=t(40);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(25),a=t(29);n.exports=function(n,e,t,o){var s=t.length,i=s,l=!o;if(null==n)return!i;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<i;){var p=(c=t[s])[0],u=n[p],d=c[1];if(l&&c[2]){if(void 0===u&&!(p in n))return!1}else{var m=new r;if(o)var f=o(u,d,p,n,e,m);if(!(void 0===f?a(d,u,3,o,m):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(8),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(8);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(8);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(8);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(7);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(7),a=t(14),o=t(16);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var s=t.__data__;if(!a||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(27),a=t(69),o=t(15),s=t(28),i=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,u=c.hasOwnProperty,d=RegExp("^"+p.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?d:i).test(s(n))}},function(n,e,t){var r,a=t(70),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(1)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(73),a=t(7),o=t(14);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(74),a=t(75),o=t(76),s=t(77),i=t(78);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(9);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(9),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(9),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(9);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(10);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(10);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(10);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(10);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(25),a=t(30),o=t(88),s=t(91),i=t(107),l=t(0),c=t(34),p=t(36),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,f,g){var h=l(n),y=l(e),v=h?"[object Array]":i(n),q=y?"[object Array]":i(e),b=(v="[object Arguments]"==v?u:v)==u,_=(q="[object Arguments]"==q?u:q)==u,S=v==q;if(S&&c(n)){if(!c(e))return!1;h=!0,b=!1}if(S&&!b)return g||(g=new r),h||p(n)?a(n,e,t,m,f,g):o(n,e,v,t,m,f,g);if(!(1&t)){var E=b&&d.call(n,"__wrapped__"),x=_&&d.call(e,"__wrapped__");if(E||x){var L=E?n.value():n,w=x?e.value():e;return g||(g=new r),f(L,w,t,m,g)}}return!!S&&(g||(g=new r),s(n,e,t,m,f,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(6),a=t(89),o=t(26),s=t(30),i=t(90),l=t(17),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=i;case"[object Set]":var f=1&r;if(m||(m=l),n.size!=e.size&&!f)return!1;var g=d.get(n);if(g)return g==e;r|=2,d.set(n,e);var h=s(m(n),m(e),r,c,u,d);return d.delete(n),h;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(1).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(92),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,s,i){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var u=p;u--;){var d=c[u];if(!(l?d in e:a.call(e,d)))return!1}var m=i.get(n),f=i.get(e);if(m&&f)return m==e&&f==n;var g=!0;i.set(n,e),i.set(e,n);for(var h=l;++u<p;){var y=n[d=c[u]],v=e[d];if(o)var q=l?o(v,y,d,e,n,i):o(y,v,d,n,e,i);if(!(void 0===q?y===v||s(y,v,t,o,i):q)){g=!1;break}h||(h="constructor"==d)}if(g&&!h){var b=n.constructor,_=e.constructor;b==_||!("constructor"in n)||!("constructor"in e)||"function"==typeof b&&b instanceof b&&"function"==typeof _&&_ instanceof _||(g=!1)}return i.delete(n),i.delete(e),g}},function(n,e,t){var r=t(93),a=t(94),o=t(33);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(23),a=t(0);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(95),a=t(96),o=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,i=s?function(n){return null==n?[]:(n=Object(n),r(s(n),(function(e){return o.call(n,e)})))}:a;n.exports=i},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var s=n[t];e(s,t,n)&&(o[a++]=s)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(98),a=t(13),o=t(0),s=t(34),i=t(35),l=t(36),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),p=!t&&a(n),u=!t&&!p&&s(n),d=!t&&!p&&!u&&l(n),m=t||p||u||d,f=m?r(n.length,String):[],g=f.length;for(var h in n)!e&&!c.call(n,h)||m&&("length"==h||u&&("offset"==h||"parent"==h)||d&&("buffer"==h||"byteLength"==h||"byteOffset"==h)||i(h,g))||f.push(h);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(5),a=t(18),o=t(4),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!s[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(24),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a&&r.process,i=function(){try{var n=o&&o.require&&o.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=i}).call(this,t(22)(n))},function(n,e,t){var r=t(104),a=t(105),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(106)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(108),a=t(14),o=t(109),s=t(38),i=t(110),l=t(5),c=t(28),p=c(r),u=c(a),d=c(o),m=c(s),f=c(i),g=l;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=g(new a)||o&&"[object Promise]"!=g(o.resolve())||s&&"[object Set]"!=g(new s)||i&&"[object WeakMap]"!=g(new i))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case m:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(2)(t(1),"DataView");n.exports=r},function(n,e,t){var r=t(2)(t(1),"Promise");n.exports=r},function(n,e,t){var r=t(2)(t(1),"WeakMap");n.exports=r},function(n,e,t){var r=t(39),a=t(33);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],s=n[o];e[t]=[o,s,r(s)]}return e}},function(n,e,t){var r=t(29),a=t(113),o=t(120),s=t(19),i=t(39),l=t(40),c=t(11);n.exports=function(n,e){return s(n)&&i(e)?l(c(n),e):function(t){var s=a(t,n);return void 0===s&&s===e?o(t,n):r(e,s,3)}}},function(n,e,t){var r=t(41);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(115),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,s=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var r=t(116);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(16);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var s=n.apply(this,r);return t.cache=o.set(a,s)||o,s};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(118);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(6),a=t(119),o=t(0),s=t(20),i=r?r.prototype:void 0,l=i?i.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(121),a=t(122);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(42),a=t(13),o=t(0),s=t(35),i=t(18),l=t(11);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,u=!1;++c<p;){var d=l(e[c]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++c!=p?u:!!(p=null==n?0:n.length)&&i(p)&&s(d,p)&&(o(n)||a(n))}},function(n,e,t){var r=t(124),a=t(125),o=t(19),s=t(11);n.exports=function(n){return o(n)?r(s(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(41);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(21),a=t(127),o=t(129);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(128),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,s=-1,i=a(o.length-e,0),l=Array(i);++s<i;)l[s]=o[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=o[s];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(130),a=t(133)(r);n.exports=a},function(n,e,t){var r=t(131),a=t(132),o=t(21),s=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(2),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(31),a=t(135),o=t(140),s=t(32),i=t(141),l=t(17);n.exports=function(n,e,t){var c=-1,p=a,u=n.length,d=!0,m=[],f=m;if(t)d=!1,p=o;else if(u>=200){var g=e?null:i(n);if(g)return l(g);d=!1,p=s,f=new r}else f=e?[]:m;n:for(;++c<u;){var h=n[c],y=e?e(h):h;if(h=t||0!==h?h:0,d&&y==y){for(var v=f.length;v--;)if(f[v]===y)continue n;e&&f.push(y),m.push(h)}else p(f,y,t)||(f!==m&&f.push(y),m.push(h))}return m}},function(n,e,t){var r=t(136);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(137),a=t(138),o=t(139);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(38),a=t(142),o=t(17),s=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(37),a=t(4);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(43)},function(n,e,t){"use strict";t(44)},function(n,e,t){"use strict";t(45)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({});function a(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function i(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function p(n){return"[object Object]"===c.call(n)}function u(n){return"[object RegExp]"===c.call(n)}function d(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function h(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}h("slot,component",!0);var y=h("key,ref,slot,slot-scope,is");function v(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var q=Object.prototype.hasOwnProperty;function b(n,e){return q.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,E=_((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),x=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),L=/\B([A-Z])/g,w=_((function(n){return n.replace(L,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function C(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function j(n,e){for(var t in e)n[t]=e[t];return n}function I(n){for(var e={},t=0;t<n.length;t++)n[t]&&j(e,n[t]);return e}function D(n,e,t){}var N=function(n,e,t){return!1},Q=function(n){return n};function k(n,e){if(n===e)return!0;var t=l(n),r=l(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return k(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var s=Object.keys(n),i=Object.keys(e);return s.length===i.length&&s.every((function(t){return k(n[t],e[t])}))}catch(n){return!1}}function O(n,e){for(var t=0;t<n.length;t++)if(k(n[t],e))return t;return-1}function T(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var P=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],R={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:N,isReservedAttr:N,isUnknownElement:N,getTagNamespace:D,parsePlatformTagName:Q,mustUseProp:N,async:!0,_lifecycleHooks:F},M=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var U=new RegExp("[^"+M.source+".$_\\d]");var B,W="__proto__"in{},G="undefined"!=typeof window,z="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,V=z&&WXEnvironment.platform.toLowerCase(),H=G&&window.navigator.userAgent.toLowerCase(),J=H&&/msie|trident/.test(H),K=H&&H.indexOf("msie 9.0")>0,Y=H&&H.indexOf("edge/")>0,X=(H&&H.indexOf("android"),H&&/iphone|ipad|ipod|ios/.test(H)||"ios"===V),Z=(H&&/chrome\/\d+/.test(H),H&&/phantomjs/.test(H),H&&H.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(G)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var rn=function(){return void 0===B&&(B=!G&&!z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),B},an=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,ln="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);sn="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=D,pn=0,un=function(){this.id=pn++,this.subs=[]};un.prototype.addSub=function(n){this.subs.push(n)},un.prototype.removeSub=function(n){v(this.subs,n)},un.prototype.depend=function(){un.target&&un.target.addDep(this)},un.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},un.target=null;var dn=[];function mn(n){dn.push(n),un.target=n}function fn(){dn.pop(),un.target=dn[dn.length-1]}var gn=function(n,e,t,r,a,o,s,i){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=i,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},hn={child:{configurable:!0}};hn.child.get=function(){return this.componentInstance},Object.defineProperties(gn.prototype,hn);var yn=function(n){void 0===n&&(n="");var e=new gn;return e.text=n,e.isComment=!0,e};function vn(n){return new gn(void 0,void 0,void 0,String(n))}function qn(n){var e=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=Array.prototype,_n=Object.create(bn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=bn[n];$(_n,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,o=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&s.observeArray(a),s.dep.notify(),o}))}));var Sn=Object.getOwnPropertyNames(_n),En=!0;function xn(n){En=n}var Ln=function(n){this.value=n,this.dep=new un,this.vmCount=0,$(n,"__ob__",this),Array.isArray(n)?(W?function(n,e){n.__proto__=e}(n,_n):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var o=t[r];$(n,o,e[o])}}(n,_n,Sn),this.observeArray(n)):this.walk(n)};function wn(n,e){var t;if(l(n)&&!(n instanceof gn))return b(n,"__ob__")&&n.__ob__ instanceof Ln?t=n.__ob__:En&&!rn()&&(Array.isArray(n)||p(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Ln(n)),e&&t&&t.vmCount++,t}function An(n,e,t,r,a){var o=new un,s=Object.getOwnPropertyDescriptor(n,e);if(!s||!1!==s.configurable){var i=s&&s.get,l=s&&s.set;i&&!l||2!==arguments.length||(t=n[e]);var c=!a&&wn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=i?i.call(n):t;return un.target&&(o.depend(),c&&(c.dep.depend(),Array.isArray(e)&&In(e))),e},set:function(e){var r=i?i.call(n):t;e===r||e!=e&&r!=r||i&&!l||(l?l.call(n,e):t=e,c=!a&&wn(e),o.notify())}})}}function Cn(n,e,t){if(Array.isArray(n)&&d(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(An(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function jn(n,e){if(Array.isArray(n)&&d(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||b(n,e)&&(delete n[e],t&&t.dep.notify())}}function In(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&In(e)}Ln.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)An(n,e[t])},Ln.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)wn(n[e])};var Dn=R.optionMergeStrategies;function Nn(n,e){if(!e)return n;for(var t,r,a,o=ln?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(t=o[s])&&(r=n[t],a=e[t],b(n,t)?r!==a&&p(r)&&p(a)&&Nn(r,a):Cn(n,t,a));return n}function Qn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?Nn(r,a):a}:e?n?function(){return Nn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function kn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function On(n,e,t,r){var a=Object.create(n||null);return e?j(a,e):a}Dn.data=function(n,e,t){return t?Qn(n,e,t):e&&"function"!=typeof e?n:Qn(n,e)},F.forEach((function(n){Dn[n]=kn})),P.forEach((function(n){Dn[n+"s"]=On})),Dn.watch=function(n,e,t,r){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in j(a,n),e){var s=a[o],i=e[o];s&&!Array.isArray(s)&&(s=[s]),a[o]=s?s.concat(i):Array.isArray(i)?i:[i]}return a},Dn.props=Dn.methods=Dn.inject=Dn.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return j(a,n),e&&j(a,e),a},Dn.provide=Qn;var Tn=function(n,e){return void 0===e?n:e};function Pn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[E(a)]={type:null});else if(p(t))for(var s in t)a=t[s],o[E(s)]=p(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var o in t){var s=t[o];r[o]=p(s)?j({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Pn(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Pn(n,e.mixins[r],t);var o,s={};for(o in n)i(o);for(o in e)b(n,o)||i(o);function i(r){var a=Dn[r]||Tn;s[r]=a(n[r],e[r],t,r)}return s}function Fn(n,e,t,r){if("string"==typeof t){var a=n[e];if(b(a,t))return a[t];var o=E(t);if(b(a,o))return a[o];var s=x(o);return b(a,s)?a[s]:a[t]||a[o]||a[s]}}function Rn(n,e,t,r){var a=e[n],o=!b(t,n),s=t[n],i=Un(Boolean,a.type);if(i>-1)if(o&&!b(a,"default"))s=!1;else if(""===s||s===w(n)){var l=Un(String,a.type);(l<0||i<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!b(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Mn(e.type)?r.call(n):r}(r,a,n);var c=En;xn(!0),wn(s),xn(c)}return s}function Mn(n){var e=n&&n.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function $n(n,e){return Mn(n)===Mn(e)}function Un(n,e){if(!Array.isArray(e))return $n(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if($n(e[t],n))return t;return-1}function Bn(n,e,t){mn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,e,t)}finally{fn()}}function Wn(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&m(o)&&!o._handled&&(o.catch((function(n){return Bn(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Bn(n,r,a)}return o}function Gn(n,e,t){if(R.errorHandler)try{return R.errorHandler.call(null,n,e,t)}catch(e){e!==n&&zn(e,null,"config.errorHandler")}zn(n,e,t)}function zn(n,e,t){if(!G&&!z||"undefined"==typeof console)throw n;console.error(n)}var Vn,Hn=!1,Jn=[],Kn=!1;function Yn(){Kn=!1;var n=Jn.slice(0);Jn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&on(Promise)){var Xn=Promise.resolve();Vn=function(){Xn.then(Yn),X&&setTimeout(D)},Hn=!0}else if(J||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Vn="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(Yn)}:function(){setTimeout(Yn,0)};else{var Zn=1,ne=new MutationObserver(Yn),ee=document.createTextNode(String(Zn));ne.observe(ee,{characterData:!0}),Vn=function(){Zn=(Zn+1)%2,ee.data=String(Zn)},Hn=!0}function te(n,e){var t;if(Jn.push((function(){if(n)try{n.call(e)}catch(n){Bn(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Vn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var re=new sn;function ae(n){!function n(e,t){var r,a,o=Array.isArray(e);if(!o&&!l(e)||Object.isFrozen(e)||e instanceof gn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,re),re.clear()}var oe=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function se(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Wn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),o=0;o<a.length;o++)Wn(a[o],null,n,e,"v-on handler")}return t.fns=n,t}function ie(n,e,t,r,o,i){var l,c,p,u;for(l in n)c=n[l],p=e[l],u=oe(l),a(c)||(a(p)?(a(c.fns)&&(c=n[l]=se(c,i)),s(u.once)&&(c=n[l]=o(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)a(n[l])&&r((u=oe(l)).name,e[l],u.capture)}function le(n,e,t){var r;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),v(r.fns,l)}a(i)?r=se([l]):o(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=se([i,l]),r.merged=!0,n[e]=r}function ce(n,e,t,r,a){if(o(e)){if(b(e,t))return n[t]=e[t],a||delete e[t],!0;if(b(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function pe(n){return i(n)?[vn(n)]:Array.isArray(n)?function n(e,t){var r,l,c,p,u=[];for(r=0;r<e.length;r++)a(l=e[r])||"boolean"==typeof l||(c=u.length-1,p=u[c],Array.isArray(l)?l.length>0&&(ue((l=n(l,(t||"")+"_"+r))[0])&&ue(p)&&(u[c]=vn(p.text+l[0].text),l.shift()),u.push.apply(u,l)):i(l)?ue(p)?u[c]=vn(p.text+l):""!==l&&u.push(vn(l)):ue(l)&&ue(p)?u[c]=vn(p.text+l.text):(s(e._isVList)&&o(l.tag)&&a(l.key)&&o(t)&&(l.key="__vlist"+t+"_"+r+"__"),u.push(l)));return u}(n):void 0}function ue(n){return o(n)&&o(n.text)&&!1===n.isComment}function de(n,e){if(n){for(var t=Object.create(null),r=ln?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){for(var s=n[o].from,i=e;i;){if(i._provided&&b(i._provided,s)){t[o]=i._provided[s];break}i=i.$parent}if(!i)if("default"in n[o]){var l=n[o].default;t[o]="function"==typeof l?l.call(e):l}else 0}}return t}}function me(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],s=o.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,o.context!==e&&o.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(o);else{var i=s.slot,l=t[i]||(t[i]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n,e,t){var a,o=Object.keys(e).length>0,s=n?!!n.$stable:!o,i=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(s&&t&&t!==r&&i===t.$key&&!o&&!t.$hasNormal)return t;for(var l in a={},n)n[l]&&"$"!==l[0]&&(a[l]=he(e,l,n[l]))}else a={};for(var c in e)c in a||(a[c]=ye(e,c));return n&&Object.isExtensible(n)&&(n._normalized=a),$(a,"$stable",s),$(a,"$key",i),$(a,"$hasNormal",o),a}function he(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({});return(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&(0===n.length||1===n.length&&n[0].isComment)?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function ye(n,e){return function(){return n[e]}}function ve(n,e){var t,r,a,s,i;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)t.push(e(p.value,t.length)),p=c.next()}else for(s=Object.keys(n),t=new Array(s.length),r=0,a=s.length;r<a;r++)i=s[r],t[r]=e(n[i],i,r);return o(t)||(t=[]),t._isVList=!0,t}function qe(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=j(j({},r),t)),a=o(t)||e):a=this.$slots[n]||e;var s=t&&t.slot;return s?this.$createElement("template",{slot:s},a):a}function be(n){return Fn(this.$options,"filters",n)||Q}function _e(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Se(n,e,t,r,a){var o=R.keyCodes[e]||t;return a&&r&&!R.keyCodes[e]?_e(a,r):o?_e(o,n):r?w(r)!==e:void 0}function Ee(n,e,t,r,a){if(t)if(l(t)){var o;Array.isArray(t)&&(t=I(t));var s=function(s){if("class"===s||"style"===s||y(s))o=n;else{var i=n.attrs&&n.attrs.type;o=r||R.mustUseProp(e,i,s)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=E(s),c=w(s);l in o||c in o||(o[s]=t[s],a&&((n.on||(n.on={}))["update:"+s]=function(n){t[s]=n}))};for(var i in t)s(i)}else;return n}function xe(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||we(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Le(n,e,t){return we(n,"__once__"+e+(t?"_"+t:""),!0),n}function we(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ae(n[r],e+"_"+r,t);else Ae(n,e,t)}function Ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ce(n,e){if(e)if(p(e)){var t=n.on=n.on?j({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function je(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];Array.isArray(o)?je(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function Ie(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function De(n,e){return"string"==typeof n?e+n:n}function Ne(n){n._o=Le,n._n=g,n._s=f,n._l=ve,n._t=qe,n._q=k,n._i=O,n._m=xe,n._f=be,n._k=Se,n._b=Ee,n._v=vn,n._e=yn,n._u=je,n._g=Ce,n._d=Ie,n._p=De}function Qe(n,e,t,a,o){var i,l=this,c=o.options;b(a,"_uid")?(i=Object.create(a))._original=a:(i=a,a=a._original);var p=s(c._compiled),u=!p;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=de(c.inject,a),this.slots=function(){return l.$slots||ge(n.scopedSlots,l.$slots=me(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(n.scopedSlots,this.slots())}}),p&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ge(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var o=Me(i,n,e,t,r,u);return o&&!Array.isArray(o)&&(o.fnScopeId=c._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return Me(i,n,e,t,r,u)}}function ke(n,e,t,r,a){var o=qn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function Oe(n,e){for(var t in e)n[E(t)]=e[t]}Ne(Qe.prototype);var Te={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Te.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){0;var s=a.data.scopedSlots,i=n.$scopedSlots,l=!!(s&&!s.$stable||i!==r&&!i.$stable||s&&n.$scopedSlots.$key!==s.$key),c=!!(o||n.$options._renderChildren||l);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=o,n.$attrs=a.data.attrs||r,n.$listeners=t||r,e&&n.$options.props){xn(!1);for(var p=n._props,u=n.$options._propKeys||[],d=0;d<u.length;d++){var m=u[d],f=n.$options.props;p[m]=Rn(m,f,e,n)}xn(!0),n.$options.propsData=e}t=t||r;var g=n.$options._parentListeners;n.$options._parentListeners=t,Je(n,t,g),c&&(n.$slots=me(o,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Ze(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Xe(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},Pe=Object.keys(Te);function Fe(n,e,t,i,c){if(!a(n)){var p=t.$options._base;if(l(n)&&(n=p.extend(n)),"function"==typeof n){var u;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Ue;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,c=null,p=null;t.$on("hook:destroyed",(function(){return v(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==p&&(clearTimeout(p),p=null))},d=T((function(t){n.resolved=Be(t,e),i?r.length=0:u(!0)})),f=T((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),g=n(d,f);return l(g)&&(m(g)?a(n.resolved)&&g.then(d,f):m(g.component)&&(g.component.then(d,f),o(g.error)&&(n.errorComp=Be(g.error,e)),o(g.loading)&&(n.loadingComp=Be(g.loading,e),0===g.delay?n.loading=!0:c=setTimeout((function(){c=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),g.delay||200)),o(g.timeout)&&(p=setTimeout((function(){p=null,a(n.resolved)&&f(null)}),g.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(u=n,p)))return function(n,e,t,r,a){var o=yn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(u,e,t,i,c);e=e||{},St(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],i=e.model.callback;o(s)?(Array.isArray(s)?-1===s.indexOf(i):s!==i)&&(a[r]=[i].concat(s)):a[r]=i}(n.options,e);var d=function(n,e,t){var r=e.options.props;if(!a(r)){var s={},i=n.attrs,l=n.props;if(o(i)||o(l))for(var c in r){var p=w(c);ce(s,l,c,p,!0)||ce(s,i,c,p,!1)}return s}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var i=n.options,l={},c=i.props;if(o(c))for(var p in c)l[p]=Rn(p,c,e||r);else o(t.attrs)&&Oe(l,t.attrs),o(t.props)&&Oe(l,t.props);var u=new Qe(t,l,s,a,n),d=i.render.call(null,u._c,u);if(d instanceof gn)return ke(d,t,u.parent,i,u);if(Array.isArray(d)){for(var m=pe(d)||[],f=new Array(m.length),g=0;g<m.length;g++)f[g]=ke(m[g],t,u.parent,i,u);return f}}(n,d,e,t,i);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Pe.length;t++){var r=Pe[t],a=e[r],o=Te[r];a===o||a&&a._merged||(e[r]=a?Re(o,a):o)}}(e);var h=n.options.name||c;return new gn("vue-component-"+n.cid+(h?"-"+h:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:d,listeners:f,tag:c,children:i},u)}}}function Re(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Me(n,e,t,r,c,p){return(Array.isArray(t)||i(t))&&(c=r,r=t,t=void 0),s(p)&&(c=2),function(n,e,t,r,i){if(o(t)&&o(t.__ob__))return yn();o(t)&&o(t.is)&&(e=t.is);if(!e)return yn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=pe(r):1===i&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var c,p;if("string"==typeof e){var u;p=n.$vnode&&n.$vnode.ns||R.getTagNamespace(e),c=R.isReservedTag(e)?new gn(R.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(u=Fn(n.$options,"components",e))?new gn(e,t,r,void 0,void 0,n):Fe(u,t,n,r,e)}else c=Fe(e,t,n,r);return Array.isArray(c)?c:o(c)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(c,p),o(t)&&function(n){l(n.style)&&ae(n.style);l(n.class)&&ae(n.class)}(t),c):yn()}(n,e,t,r,c)}var $e,Ue=null;function Be(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function We(n){return n.isComment&&n.asyncFactory}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||We(t)))return t}}function ze(n,e){$e.$on(n,e)}function Ve(n,e){$e.$off(n,e)}function He(n,e){var t=$e;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Je(n,e,t){$e=n,ie(e,t||{},ze,Ve,He,n),$e=void 0}var Ke=null;function Ye(n){var e=Ke;return Ke=n,function(){Ke=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ze(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ze(n.$children[t]);nt(n,"activated")}}function nt(n,e){mn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,o=t.length;a<o;a++)Wn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var et=[],tt=[],rt={},at=!1,ot=!1,st=0;var it=0,lt=Date.now;if(G&&!J){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}function pt(){var n,e;for(it=lt(),ot=!0,et.sort((function(n,e){return n.id-e.id})),st=0;st<et.length;st++)(n=et[st]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();st=et.length=tt.length=0,rt={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ze(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),an&&R.devtools&&an.emit("flush")}var ut=0,dt=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ut,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=D)),this.value=this.lazy?void 0:this.get()};dt.prototype.get=function(){var n;mn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Bn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ae(n),fn(),this.cleanupDeps()}return n},dt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},dt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},dt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==rt[e]){if(rt[e]=!0,ot){for(var t=et.length-1;t>st&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,te(pt))}}(this)},dt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user)try{this.cb.call(this.vm,n,e)}catch(n){Bn(n,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,n,e)}}},dt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},dt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},dt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||v(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var mt={enumerable:!0,configurable:!0,get:D,set:D};function ft(n,e,t){mt.get=function(){return this[e][t]},mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,mt)}function gt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&xn(!1);var o=function(o){a.push(o);var s=Rn(o,e,t,n);An(r,o,s),o in n||ft(n,"_props",o)};for(var s in e)o(s);xn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?D:A(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;p(e=n._data="function"==typeof e?function(n,e){mn();try{return n.call(e,e)}catch(n){return Bn(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&b(r,o)||(s=void 0,36!==(s=(o+"").charCodeAt(0))&&95!==s&&ft(n,"_data",o))}var s;wn(e,!0)}(n):wn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=rn();for(var a in e){var o=e[a],s="function"==typeof o?o:o.get;0,r||(t[a]=new dt(n,s||D,D,ht)),a in n||yt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)bt(n,t,r[a]);else bt(n,t,r)}}(n,e.watch)}var ht={lazy:!0};function yt(n,e,t){var r=!rn();"function"==typeof t?(mt.get=r?vt(e):qt(t),mt.set=D):(mt.get=t.get?r&&!1!==t.cache?vt(e):qt(t.get):D,mt.set=t.set||D),Object.defineProperty(n,e,mt)}function vt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),un.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function bt(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var _t=0;function St(n){var e=n.options;if(n.super){var t=St(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&j(n.extendOptions,r),(e=n.options=Pn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Et(n){this._init(n)}function xt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=n.name||t.options.name;var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=Pn(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)ft(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,P.forEach((function(n){s[n]=t[n]})),o&&(s.options.components[o]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=j({},s.options),a[r]=s,s}}function Lt(n){return n&&(n.Ctor.options.name||n.tag)}function wt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function At(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var s=t[o];if(s){var i=Lt(s.componentOptions);i&&!e(i)&&Ct(t,o,r,a)}}}function Ct(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,v(t,e)}Et.prototype._init=function(n){var e=this;e._uid=_t++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Pn(St(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Je(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=me(e._renderChildren,a),n.$scopedSlots=r,n._c=function(e,t,r,a){return Me(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Me(n,e,t,r,a,!0)};var o=t&&t.data;An(n,"$attrs",o&&o.attrs||r,null,!0),An(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate"),function(n){var e=de(n.$options.inject,n);e&&(xn(!1),Object.keys(e).forEach((function(t){An(n,t,e[t])})),xn(!0))}(e),gt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Cn,n.prototype.$delete=jn,n.prototype.$watch=function(n,e,t){if(p(e))return bt(this,n,e,t);(t=t||{}).user=!0;var r=new dt(this,n,e,t);if(t.immediate)try{e.call(this,r.value)}catch(n){Bn(n,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(Et),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var i=s.length;i--;)if((o=s[i])===e||o.fn===e){s.splice(i,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?C(t):t;for(var r=C(arguments,1),a='event handler for "'+n+'"',o=0,s=t.length;o<s;o++)Wn(t[o],e,r,e,a)}return e}}(Et),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Ye(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||v(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Et),function(n){Ne(n.prototype),n.prototype.$nextTick=function(n){return te(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=ge(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Ue=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Bn(t,e,"render"),n=e._vnode}finally{Ue=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof gn||(n=yn()),n.parent=a,n}}(Et);var jt=[String,RegExp,Array],It={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:jt,exclude:jt,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ct(this.cache,n,this.keys)},mounted:function(){var n=this;this.$watch("include",(function(e){At(n,(function(n){return wt(e,n)}))})),this.$watch("exclude",(function(e){At(n,(function(n){return!wt(e,n)}))}))},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var r=Lt(t),a=this.include,o=this.exclude;if(a&&(!r||!wt(a,r))||o&&r&&wt(o,r))return e;var s=this.cache,i=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,v(i,l),i.push(l)):(s[l]=e,i.push(l),this.max&&i.length>parseInt(this.max)&&Ct(s,i[0],i,this._vnode)),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return R}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:j,mergeOptions:Pn,defineReactive:An},n.set=Cn,n.delete=jn,n.nextTick=te,n.observable=function(n){return wn(n),n},n.options=Object.create(null),P.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,It),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=C(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Pn(this.options,n),this}}(n),xt(n),function(n){P.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Et),Object.defineProperty(Et.prototype,"$isServer",{get:rn}),Object.defineProperty(Et.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Et,"FunctionalRenderContext",{value:Qe}),Et.version="2.6.12";var Dt=h("style,class"),Nt=h("input,textarea,option,select,progress"),Qt=h("contenteditable,draggable,spellcheck"),kt=h("events,caret,typing,plaintext-only"),Ot=h("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Tt="http://www.w3.org/1999/xlink",Pt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ft=function(n){return Pt(n)?n.slice(6,n.length):""},Rt=function(n){return null==n||!1===n};function Mt(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=$t(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=$t(e,t.data));return function(n,e){if(o(n)||o(e))return Ut(n,Bt(e));return""}(e.staticClass,e.class)}function $t(n,e){return{staticClass:Ut(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Ut(n,e){return n?e?n+" "+e:n:e||""}function Bt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=Bt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Wt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=h("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),zt=h("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Vt=function(n){return Gt(n)||zt(n)};var Ht=Object.create(null);var Jt=h("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Wt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Yt={create:function(n,e){Xt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Xt(n,!0),Xt(e))},destroy:function(n){Xt(n,!0)}};function Xt(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,s=r.$refs;e?Array.isArray(s[t])?v(s[t],a):s[t]===a&&(s[t]=void 0):n.data.refInFor?Array.isArray(s[t])?s[t].indexOf(a)<0&&s[t].push(a):s[t]=[a]:s[t]=a}}var Zt=new gn("",{},[]),nr=["create","activate","update","remove","destroy"];function er(n,e){return n.key===e.key&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||Jt(r)&&Jt(a)}(n,e)||s(n.isAsyncPlaceholder)&&n.asyncFactory===e.asyncFactory&&a(e.asyncFactory.error))}function tr(n,e,t){var r,a,s={};for(r=e;r<=t;++r)o(a=n[r].key)&&(s[a]=r);return s}var rr={create:ar,update:ar,destroy:function(n){ar(n,Zt)}};function ar(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===Zt,s=e===Zt,i=sr(n.data.directives,n.context),l=sr(e.data.directives,e.context),c=[],p=[];for(t in l)r=i[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,lr(a,"update",e,n),a.def&&a.def.componentUpdated&&p.push(a)):(lr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var u=function(){for(var t=0;t<c.length;t++)lr(c[t],"inserted",e,n)};o?le(e,"insert",u):u()}p.length&&le(e,"postpatch",(function(){for(var t=0;t<p.length;t++)lr(p[t],"componentUpdated",e,n)}));if(!o)for(t in i)l[t]||lr(i[t],"unbind",n,n,s)}(n,e)}var or=Object.create(null);function sr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=or),a[ir(r)]=r,r.def=Fn(e.$options,"directives",r.name);return a}function ir(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function lr(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Bn(r,t.context,"directive "+n.name+" "+e+" hook")}}var cr=[Yt,rr];function pr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,s,i=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in o(c.__ob__)&&(c=e.data.attrs=j({},c)),c)s=c[r],l[r]!==s&&ur(i,r,s);for(r in(J||Y)&&c.value!==l.value&&ur(i,"value",c.value),l)a(c[r])&&(Pt(r)?i.removeAttributeNS(Tt,Ft(r)):Qt(r)||i.removeAttribute(r))}}function ur(n,e,t){n.tagName.indexOf("-")>-1?dr(n,e,t):Ot(e)?Rt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Qt(e)?n.setAttribute(e,function(n,e){return Rt(e)||"false"===e?"false":"contenteditable"===n&&kt(e)?e:"true"}(e,t)):Pt(e)?Rt(t)?n.removeAttributeNS(Tt,Ft(e)):n.setAttributeNS(Tt,e,t):dr(n,e,t)}function dr(n,e,t){if(Rt(t))n.removeAttribute(e);else{if(J&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var mr={create:pr,update:pr};function fr(n,e){var t=e.elm,r=e.data,s=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(s)||a(s.staticClass)&&a(s.class)))){var i=Mt(e),l=t._transitionClasses;o(l)&&(i=Ut(i,Bt(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var gr,hr={create:fr,update:fr};function yr(n,e,t){var r=gr;return function a(){var o=e.apply(null,arguments);null!==o&&br(n,a,t,r)}}var vr=Hn&&!(Z&&Number(Z[1])<=53);function qr(n,e,t,r){if(vr){var a=it,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}gr.addEventListener(n,e,en?{capture:t,passive:r}:t)}function br(n,e,t,r){(r||gr).removeEventListener(n,e._wrapper||e,t)}function _r(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};gr=e.elm,function(n){if(o(n.__r)){var e=J?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ie(t,r,qr,br,yr,e.context),gr=void 0}}var Sr,Er={create:_r,update:_r};function xr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,s=e.elm,i=n.data.domProps||{},l=e.data.domProps||{};for(t in o(l.__ob__)&&(l=e.data.domProps=j({},l)),i)t in l||(s[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===i[t])continue;1===s.childNodes.length&&s.removeChild(s.childNodes[0])}if("value"===t&&"PROGRESS"!==s.tagName){s._value=r;var c=a(r)?"":String(r);Lr(s,c)&&(s.value=c)}else if("innerHTML"===t&&zt(s.tagName)&&a(s.innerHTML)){(Sr=Sr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var p=Sr.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;p.firstChild;)s.appendChild(p.firstChild)}else if(r!==i[t])try{s[t]=r}catch(n){}}}}function Lr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var wr={create:xr,update:xr},Ar=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Cr(n){var e=jr(n.style);return n.staticStyle?j(n.staticStyle,e):e}function jr(n){return Array.isArray(n)?I(n):"string"==typeof n?Ar(n):n}var Ir,Dr=/^--/,Nr=/\s*!important$/,Qr=function(n,e,t){if(Dr.test(e))n.style.setProperty(e,t);else if(Nr.test(t))n.style.setProperty(w(e),t.replace(Nr,""),"important");else{var r=Or(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},kr=["Webkit","Moz","ms"],Or=_((function(n){if(Ir=Ir||document.createElement("div").style,"filter"!==(n=E(n))&&n in Ir)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<kr.length;t++){var r=kr[t]+e;if(r in Ir)return r}}));function Tr(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var s,i,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},u=c||p,d=jr(e.data.style)||{};e.data.normalizedStyle=o(d.__ob__)?j({},d):d;var m=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Cr(a.data))&&j(r,t);(t=Cr(n.data))&&j(r,t);for(var o=n;o=o.parent;)o.data&&(t=Cr(o.data))&&j(r,t);return r}(e,!0);for(i in u)a(m[i])&&Qr(l,i,"");for(i in m)(s=m[i])!==u[i]&&Qr(l,i,null==s?"":s)}}var Pr={create:Tr,update:Tr},Fr=/\s+/;function Rr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Mr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function $r(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&j(e,Ur(n.name||"v")),j(e,n),e}return"string"==typeof n?Ur(n):void 0}}var Ur=_((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Br=G&&!K,Wr="transition",Gr="transitionend",zr="animation",Vr="animationend";Br&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Wr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(zr="WebkitAnimation",Vr="webkitAnimationEnd"));var Hr=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Jr(n){Hr((function(){Hr(n)}))}function Kr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Rr(n,e))}function Yr(n,e){n._transitionClasses&&v(n._transitionClasses,e),Mr(n,e)}function Xr(n,e,t){var r=na(n,e),a=r.type,o=r.timeout,s=r.propCount;if(!a)return t();var i="transition"===a?Gr:Vr,l=0,c=function(){n.removeEventListener(i,p),t()},p=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),o+1),n.addEventListener(i,p)}var Zr=/\b(transform|all)(,|$)/;function na(n,e){var t,r=window.getComputedStyle(n),a=(r[Wr+"Delay"]||"").split(", "),o=(r[Wr+"Duration"]||"").split(", "),s=ea(a,o),i=(r[zr+"Delay"]||"").split(", "),l=(r[zr+"Duration"]||"").split(", "),c=ea(i,l),p=0,u=0;return"transition"===e?s>0&&(t="transition",p=s,u=o.length):"animation"===e?c>0&&(t="animation",p=c,u=l.length):u=(t=(p=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:p,propCount:u,hasTransform:"transition"===t&&Zr.test(r[Wr+"Property"])}}function ea(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ta(e)+ta(n[t])})))}function ta(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ra(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=$r(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var s=r.css,i=r.type,c=r.enterClass,p=r.enterToClass,u=r.enterActiveClass,d=r.appearClass,m=r.appearToClass,f=r.appearActiveClass,h=r.beforeEnter,y=r.enter,v=r.afterEnter,q=r.enterCancelled,b=r.beforeAppear,_=r.appear,S=r.afterAppear,E=r.appearCancelled,x=r.duration,L=Ke,w=Ke.$vnode;w&&w.parent;)L=w.context,w=w.parent;var A=!L._isMounted||!n.isRootInsert;if(!A||_||""===_){var C=A&&d?d:c,j=A&&f?f:u,I=A&&m?m:p,D=A&&b||h,N=A&&"function"==typeof _?_:y,Q=A&&S||v,k=A&&E||q,O=g(l(x)?x.enter:x);0;var P=!1!==s&&!K,F=sa(N),R=t._enterCb=T((function(){P&&(Yr(t,I),Yr(t,j)),R.cancelled?(P&&Yr(t,C),k&&k(t)):Q&&Q(t),t._enterCb=null}));n.data.show||le(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),N&&N(t,R)})),D&&D(t),P&&(Kr(t,C),Kr(t,j),Jr((function(){Yr(t,C),R.cancelled||(Kr(t,I),F||(oa(O)?setTimeout(R,O):Xr(t,i,R)))}))),n.data.show&&(e&&e(),N&&N(t,R)),P||F||R()}}}function aa(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=$r(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var s=r.css,i=r.type,c=r.leaveClass,p=r.leaveToClass,u=r.leaveActiveClass,d=r.beforeLeave,m=r.leave,f=r.afterLeave,h=r.leaveCancelled,y=r.delayLeave,v=r.duration,q=!1!==s&&!K,b=sa(m),_=g(l(v)?v.leave:v);0;var S=t._leaveCb=T((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),q&&(Yr(t,p),Yr(t,u)),S.cancelled?(q&&Yr(t,c),h&&h(t)):(e(),f&&f(t)),t._leaveCb=null}));y?y(E):E()}function E(){S.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),q&&(Kr(t,c),Kr(t,u),Jr((function(){Yr(t,c),S.cancelled||(Kr(t,p),b||(oa(_)?setTimeout(S,_):Xr(t,i,S)))}))),m&&m(t,S),q||b||S())}}function oa(n){return"number"==typeof n&&!isNaN(n)}function sa(n){if(a(n))return!1;var e=n.fns;return o(e)?sa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ia(n,e){!0!==e.data.show&&ra(e)}var la=function(n){var e,t,r={},l=n.modules,c=n.nodeOps;for(e=0;e<nr.length;++e)for(r[nr[e]]=[],t=0;t<l.length;++t)o(l[t][nr[e]])&&r[nr[e]].push(l[t][nr[e]]);function p(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function u(n,e,t,a,i,l,p){if(o(n.elm)&&o(l)&&(n=l[p]=qn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return d(n,e),m(t,n.elm,a),s(l)&&function(n,e,t,a){var s,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,o(s=i.data)&&o(s=s.transition)){for(s=0;s<r.activate.length;++s)r.activate[s](Zt,i);e.push(i);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,g=n.children,h=n.tag;o(h)?(n.elm=n.ns?c.createElementNS(n.ns,h):c.createElement(h,n),v(n),f(n,g,e),o(u)&&y(n,e),m(t,n.elm,a)):s(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,a)):(n.elm=c.createTextNode(n.text),m(t,n.elm,a))}}function d(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(y(n,e),v(n)):(Xt(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function f(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else i(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function y(n,t){for(var a=0;a<r.create.length;++a)r.create[a](Zt,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Zt,n),o(e.insert)&&t.push(n))}function v(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Ke)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function q(n,e,t,r,a,o){for(;r<=a;++r)u(t[r],o,n,e,!1,t,r)}function b(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)b(n.children[t])}function _(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(S(r),b(r)):p(r.elm))}}function S(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&S(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else p(n.elm)}function E(n,e,t,r){for(var a=t;a<r;a++){var s=e[a];if(o(s)&&er(n,s))return a}}function x(n,e,t,i,l,p){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=qn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,f=e.data;o(f)&&o(m=f.hook)&&o(m=m.prepatch)&&m(n,e);var h=n.children,y=e.children;if(o(f)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=f.hook)&&o(m=m.update)&&m(n,e)}a(e.text)?o(h)&&o(y)?h!==y&&function(n,e,t,r,s){var i,l,p,d=0,m=0,f=e.length-1,g=e[0],h=e[f],y=t.length-1,v=t[0],b=t[y],S=!s;for(0;d<=f&&m<=y;)a(g)?g=e[++d]:a(h)?h=e[--f]:er(g,v)?(x(g,v,r,t,m),g=e[++d],v=t[++m]):er(h,b)?(x(h,b,r,t,y),h=e[--f],b=t[--y]):er(g,b)?(x(g,b,r,t,y),S&&c.insertBefore(n,g.elm,c.nextSibling(h.elm)),g=e[++d],b=t[--y]):er(h,v)?(x(h,v,r,t,m),S&&c.insertBefore(n,h.elm,g.elm),h=e[--f],v=t[++m]):(a(i)&&(i=tr(e,d,f)),a(l=o(v.key)?i[v.key]:E(v,e,d,f))?u(v,r,n,g.elm,!1,t,m):er(p=e[l],v)?(x(p,v,r,t,m),e[l]=void 0,S&&c.insertBefore(n,p.elm,g.elm)):u(v,r,n,g.elm,!1,t,m),v=t[++m]);d>f?q(n,a(t[y+1])?null:t[y+1].elm,t,m,y,r):m>y&&_(e,d,f)}(d,h,y,t,p):o(y)?(o(n.text)&&c.setTextContent(d,""),q(d,null,y,0,y.length-1,t)):o(h)?_(h,0,h.length-1):o(n.text)&&c.setTextContent(d,""):n.text!==e.text&&c.setTextContent(d,e.text),o(f)&&o(m=f.hook)&&o(m=m.postpatch)&&m(n,e)}}}function L(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var w=h("attrs,class,staticClass,staticStyle,key");function A(n,e,t,r){var a,i=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(a=l.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return d(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(a=l)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var p=!0,u=n.firstChild,m=0;m<c.length;m++){if(!u||!A(u,c[m],t,r)){p=!1;break}u=u.nextSibling}if(!p||u)return!1}else f(e,c,t);if(o(l)){var g=!1;for(var h in l)if(!w(h)){g=!0,y(e,t);break}!g&&l.class&&ae(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,p=!1,d=[];if(a(n))p=!0,u(e,d);else{var m=o(n.nodeType);if(!m&&er(n,e))x(n,e,d,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,d))return L(e,d,!0),n;l=n,n=new gn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,h=c.parentNode(f);if(u(e,d,f._leaveCb?null:h,c.nextSibling(f)),o(e.parent))for(var y=e.parent,v=g(e);y;){for(var q=0;q<r.destroy.length;++q)r.destroy[q](y);if(y.elm=e.elm,v){for(var S=0;S<r.create.length;++S)r.create[S](Zt,y);var E=y.data.hook.insert;if(E.merged)for(var w=1;w<E.fns.length;w++)E.fns[w]()}else Xt(y);y=y.parent}o(h)?_([n],0,0):o(n.tag)&&b(n)}}return L(e,d,p),e.elm}o(n)&&b(n)}}({nodeOps:Kt,modules:[mr,hr,Er,wr,Pr,G?{create:ia,activate:ia,remove:function(n,e){!0!==n.data.show?aa(n,e):e()}}:{}].concat(cr)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&ya(n,"input")}));var ca={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?le(t,"postpatch",(function(){ca.componentUpdated(n,e,t)})):pa(n,e,t.context),n._vOptions=[].map.call(n.options,ma)):("textarea"===t.tag||Jt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",fa),n.addEventListener("compositionend",ha),n.addEventListener("change",ha),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,ma);if(a.some((function(n,e){return!k(n,r[e])})))(n.multiple?e.value.some((function(n){return da(n,a)})):e.value!==e.oldValue&&da(e.value,a))&&ya(n,"change")}}};function pa(n,e,t){ua(n,e,t),(J||Y)&&setTimeout((function(){ua(n,e,t)}),0)}function ua(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,s,i=0,l=n.options.length;i<l;i++)if(s=n.options[i],a)o=O(r,ma(s))>-1,s.selected!==o&&(s.selected=o);else if(k(ma(s),r))return void(n.selectedIndex!==i&&(n.selectedIndex=i));a||(n.selectedIndex=-1)}}function da(n,e){return e.every((function(e){return!k(e,n)}))}function ma(n){return"_value"in n?n._value:n.value}function fa(n){n.target.composing=!0}function ha(n){n.target.composing&&(n.target.composing=!1,ya(n.target,"input"))}function ya(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function va(n){return!n.componentInstance||n.data&&n.data.transition?n:va(n.componentInstance._vnode)}var qa={model:ca,show:{bind:function(n,e,t){var r=e.value,a=(t=va(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,ra(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=va(t)).data&&t.data.transition?(t.data.show=!0,r?ra(t,(function(){n.style.display=n.__vOriginalDisplay})):aa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},ba={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function _a(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?_a(Ge(e.children)):n}function Sa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var o in a)e[E(o)]=a[o];return e}function Ea(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var xa=function(n){return n.tag||We(n)},La=function(n){return"show"===n.name},wa={name:"transition",props:ba,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(xa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=_a(a);if(!o)return a;if(this._leaving)return Ea(n,a);var s="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?s+"comment":s+o.tag:i(o.key)?0===String(o.key).indexOf(s)?o.key:s+o.key:o.key;var l=(o.data||(o.data={})).transition=Sa(this),c=this._vnode,p=_a(c);if(o.data.directives&&o.data.directives.some(La)&&(o.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,p)&&!We(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var u=p.data.transition=j({},l);if("out-in"===r)return this._leaving=!0,le(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ea(n,a);if("in-out"===r){if(We(o))return c;var d,m=function(){d()};le(l,"afterEnter",m),le(l,"enterCancelled",m),le(u,"delayLeave",(function(n){d=n}))}}return a}}},Aa=j({tag:String,moveClass:String},ba);function Ca(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function ja(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ia(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+a+"px)",o.transitionDuration="0s"}}delete Aa.mode;var Da={Transition:wa,TransitionGroup:{props:Aa,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],s=Sa(this),i=0;i<a.length;i++){var l=a[i];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))o.push(l),t[l.key]=l,(l.data||(l.data={})).transition=s;else;}if(r){for(var c=[],p=[],u=0;u<r.length;u++){var d=r[u];d.data.transition=s,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?c.push(d):p.push(d)}this.kept=n(e,null,c),this.removed=p}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ca),n.forEach(ja),n.forEach(Ia),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Kr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Gr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Gr,n),t._moveCb=null,Yr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Br)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Mr(t,n)})),Rr(t,e),t.style.display="none",this.$el.appendChild(t);var r=na(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Et.config.mustUseProp=function(n,e,t){return"value"===t&&Nt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Et.config.isReservedTag=Vt,Et.config.isReservedAttr=Dt,Et.config.getTagNamespace=function(n){return zt(n)?"svg":"math"===n?"math":void 0},Et.config.isUnknownElement=function(n){if(!G)return!0;if(Vt(n))return!1;if(n=n.toLowerCase(),null!=Ht[n])return Ht[n];var e=document.createElement(n);return n.indexOf("-")>-1?Ht[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Ht[n]=/HTMLUnknownElement/.test(e.toString())},j(Et.options.directives,qa),j(Et.options.components,Da),Et.prototype.__patch__=G?la:D,Et.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=yn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new dt(n,r,D,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){R.devtools&&an&&an.emit("init",Et)}),0);var Na=Et;
/*!
  * vue-router v3.4.9
  * (c) 2020 Evan You
  * @license MIT
  */function Qa(n,e){for(var t in e)n[t]=e[t];return n}var ka=/[!'()*]/g,Oa=function(n){return"%"+n.charCodeAt(0).toString(16)},Ta=/%2C/g,Pa=function(n){return encodeURIComponent(n).replace(ka,Oa).replace(Ta,",")};function Fa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ra=function(n){return null==n||"object"==typeof n?n:String(n)};function Ma(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Fa(t.shift()),a=t.length>0?Fa(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function $a(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Pa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Pa(e)):r.push(Pa(e)+"="+Pa(n)))})),r.join("&")}return Pa(e)+"="+Pa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ua=/\/?$/;function Ba(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=Wa(o)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:Va(e,a),matched:n?za(n):[]};return t&&(s.redirectedFrom=Va(t,a)),Object.freeze(s)}function Wa(n){if(Array.isArray(n))return n.map(Wa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Wa(n[t]);return e}return n}var Ga=Ba(null,{path:"/"});function za(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Va(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||$a)(r)+a}function Ha(n,e){return e===Ga?n===e:!!e&&(n.path&&e.path?n.path.replace(Ua,"")===e.path.replace(Ua,"")&&n.hash===e.hash&&Ja(n.query,e.query):!(!n.name||!e.name)&&(n.name===e.name&&n.hash===e.hash&&Ja(n.query,e.query)&&Ja(n.params,e.params)))}function Ja(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var s=e[t];return null==o||null==s?o===s:"object"==typeof o&&"object"==typeof s?Ja(o,s):String(o)===String(s)}))}function Ka(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var s=0;s<o.length;s++)a._isBeingDestroyed||o[s](a)}}}}var Ya={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var s=a.$createElement,i=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),p=0,u=!1;a&&a._routerRoot!==a;){var d=a.$vnode?a.$vnode.data:{};d.routerView&&p++,d.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(o.routerViewDepth=p,u){var m=c[i],f=m&&m.component;return f?(m.configProps&&Xa(f,o,m.route,m.configProps),s(f,o,r)):s()}var g=l.matched[p],h=g&&g.components[i];if(!g||!h)return c[i]=null,s();c[i]={component:h},o.registerRouteInstance=function(n,e){var t=g.instances[i];(e&&t!==n||!e&&t===n)&&(g.instances[i]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[i]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[i]&&(g.instances[i]=n.componentInstance),Ka(l)};var y=g.props&&g.props[i];return y&&(Qa(c[i],{route:l,configProps:y}),Xa(h,o,l,y)),s(h,o,r)}};function Xa(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=Qa({},a);var o=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(o[s]=a[s],delete a[s])}}function Za(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),s=0;s<o.length;s++){var i=o[s];".."===i?a.pop():"."!==i&&a.push(i)}return""!==a[0]&&a.unshift(""),a.join("/")}function no(n){return n.replace(/\/\//g,"/")}var eo=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},to=yo,ro=lo,ao=function(n,e){return po(lo(n,e),e)},oo=po,so=ho,io=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function lo(n,e){for(var t,r=[],a=0,o=0,s="",i=e&&e.delimiter||"/";null!=(t=io.exec(n));){var l=t[0],c=t[1],p=t.index;if(s+=n.slice(o,p),o=p+l.length,c)s+=c[1];else{var u=n[o],d=t[2],m=t[3],f=t[4],g=t[5],h=t[6],y=t[7];s&&(r.push(s),s="");var v=null!=d&&null!=u&&u!==d,q="+"===h||"*"===h,b="?"===h||"*"===h,_=t[2]||i,S=f||g;r.push({name:m||a++,prefix:d||"",delimiter:_,optional:b,repeat:q,partial:v,asterisk:!!y,pattern:S?mo(S):y?".*":"[^"+uo(_)+"]+?"})}}return o<n.length&&(s+=n.substr(o)),s&&r.push(s),r}function co(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function po(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",go(e)));return function(e,r){for(var a="",o=e||{},s=(r||{}).pretty?co:encodeURIComponent,i=0;i<n.length;i++){var l=n[i];if("string"!=typeof l){var c,p=o[l.name];if(null==p){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(eo(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<p.length;u++){if(c=s(p[u]),!t[i].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(p),!t[i].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function uo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function mo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fo(n,e){return n.keys=e,n}function go(n){return n&&n.sensitive?"":"i"}function ho(n,e,t){eo(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",s=0;s<n.length;s++){var i=n[s];if("string"==typeof i)o+=uo(i);else{var l=uo(i.prefix),c="(?:"+i.pattern+")";e.push(i),i.repeat&&(c+="(?:"+l+c+")*"),o+=c=i.optional?i.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=uo(t.delimiter||"/"),u=o.slice(-p.length)===p;return r||(o=(u?o.slice(0,-p.length):o)+"(?:"+p+"(?=$))?"),o+=a?"$":r&&u?"":"(?="+p+"|$)",fo(new RegExp("^"+o,go(t)),e)}function yo(n,e,t){return eo(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fo(n,e)}(n,e):eo(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(yo(n[a],e,t).source);return fo(new RegExp("(?:"+r.join("|")+")",go(t)),e)}(n,e,t):function(n,e,t){return ho(lo(n,t),e,t)}(n,e,t)}to.parse=ro,to.compile=ao,to.tokensToFunction=oo,to.tokensToRegExp=so;var vo=Object.create(null);function qo(n,e,t){e=e||{};try{var r=vo[n]||(vo[n]=to.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function bo(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=Qa({},n)).params;return o&&"object"==typeof o&&(a.params=Qa({},o)),a}if(!a.path&&a.params&&e){(a=Qa({},a))._normalized=!0;var s=Qa(Qa({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var i=e.matched[e.matched.length-1].path;a.path=qo(i,s,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",p=l.path?Za(l.path,c,t||a.append):c,u=function(n,e,t){void 0===e&&(e={});var r,a=t||Ma;try{r=a(n||"")}catch(n){r={}}for(var o in e){var s=e[o];r[o]=Array.isArray(s)?s.map(Ra):Ra(s)}return r}(l.query,a.query,r&&r.options.parseQuery),d=a.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:p,query:u,hash:d}}var _o,So=function(){},Eo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},exact:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,s=a.route,i=a.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,d=null==p?"router-link-exact-active":p,m=null==this.activeClass?u:this.activeClass,f=null==this.exactActiveClass?d:this.exactActiveClass,g=s.redirectedFrom?Ba(null,bo(s.redirectedFrom),null,t):s;l[f]=Ha(r,g),l[m]=this.exact?l[f]:function(n,e){return 0===n.path.replace(Ua,"/").indexOf(e.path.replace(Ua,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var h=l[f]?this.ariaCurrentValue:null,y=function(n){xo(n)&&(e.replace?t.replace(o,So):t.push(o,So))},v={click:xo};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=y})):v[this.event]=y;var q={class:l},b=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:i,route:s,navigate:y,isActive:l[m],isExactActive:l[f]});if(b){if(1===b.length)return b[0];if(b.length>1||!b.length)return 0===b.length?n():n("span",{},b)}if("a"===this.tag)q.on=v,q.attrs={href:i,"aria-current":h};else{var _=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(_){_.isStatic=!1;var S=_.data=Qa({},_.data);for(var E in S.on=S.on||{},S.on){var x=S.on[E];E in v&&(S.on[E]=Array.isArray(x)?x:[x])}for(var L in v)L in S.on?S.on[L].push(v[L]):S.on[L]=y;var w=_.data.attrs=Qa({},_.data.attrs);w.href=i,w["aria-current"]=h}else q.on=v}return n(this.tag,q,this.$slots.default)}};function xo(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Lo="undefined"!=typeof window;function wo(n,e,t,r){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,s){var i=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return no(e.path+"/"+n)}(i,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var u={path:p,regex:Ao(p,c),components:a.components||{default:a.component},instances:{},enteredCbs:{},name:l,parent:o,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=s?no(s+"/"+a.path):void 0;n(e,t,r,a,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var d=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<d.length;++m){0;var f={path:d[m],children:a.children};n(e,t,r,f,o,u.path||"/")}l&&(r[l]||(r[l]=u))}(a,o,s,n)}));for(var i=0,l=a.length;i<l;i++)"*"===a[i]&&(a.push(a.splice(i,1)[0]),l--,i--);return{pathList:a,pathMap:o,nameMap:s}}function Ao(n,e){return to(n,[],e)}function Co(n,e){var t=wo(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function s(n,t,s){var i=bo(n,t,!1,e),c=i.name;if(c){var p=o[c];if(!p)return l(null,i);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof i.params&&(i.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in i.params)&&u.indexOf(d)>-1&&(i.params[d]=t.params[d]);return i.path=qo(p.path,i.params),l(p,i,s)}if(i.path){i.params={};for(var m=0;m<r.length;m++){var f=r[m],g=a[f];if(jo(g.regex,i.path,i.params))return l(g,i,s)}}return l(null,i)}function i(n,t){var r=n.redirect,a="function"==typeof r?r(Ba(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var i=a,c=i.name,p=i.path,u=t.query,d=t.hash,m=t.params;if(u=i.hasOwnProperty("query")?i.query:u,d=i.hasOwnProperty("hash")?i.hash:d,m=i.hasOwnProperty("params")?i.params:m,c){o[c];return s({_normalized:!0,name:c,query:u,hash:d,params:m},void 0,t)}if(p){var f=function(n,e){return Za(n,e.parent?e.parent.path:"/",!0)}(p,n);return s({_normalized:!0,path:qo(f,m),query:u,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?i(n,r||t):n&&n.matchAs?function(n,e,t){var r=s({_normalized:!0,path:qo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):Ba(n,t,r,e)}return{match:s,addRoutes:function(n){wo(n,r,a,o)}}}function jo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var s=n.keys[a-1];s&&(t[s.name||"pathMatch"]="string"==typeof r[a]?Fa(r[a]):r[a])}return!0}var Io=Lo&&window.performance&&window.performance.now?window.performance:Date;function Do(){return Io.now().toFixed(3)}var No=Do();function Qo(){return No}function ko(n){return No=n}var Oo=Object.create(null);function To(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Qa({},window.history.state);return t.key=Qo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Ro),function(){window.removeEventListener("popstate",Ro)}}function Po(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=Qo();if(n)return Oo[n]}(),s=a.call(n,e,t,r?o:null);s&&("function"==typeof s.then?s.then((function(n){Wo(n,o)})).catch((function(n){0})):Wo(s,o))}))}}function Fo(){var n=Qo();n&&(Oo[n]={x:window.pageXOffset,y:window.pageYOffset})}function Ro(n){Fo(),n.state&&n.state.key&&ko(n.state.key)}function Mo(n){return Uo(n.x)||Uo(n.y)}function $o(n){return{x:Uo(n.x)?n.x:window.pageXOffset,y:Uo(n.y)?n.y:window.pageYOffset}}function Uo(n){return"number"==typeof n}var Bo=/^#\d/;function Wo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=Bo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:Uo((t=o).x)?t.x:0,y:Uo(t.y)?t.y:0})}else Mo(n)&&(e=$o(n))}else r&&Mo(n)&&(e=$o(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Go,zo=Lo&&((-1===(Go=window.navigator.userAgent).indexOf("Android 2.")&&-1===Go.indexOf("Android 4.0")||-1===Go.indexOf("Mobile Safari")||-1!==Go.indexOf("Chrome")||-1!==Go.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Vo(n,e){Fo();var t=window.history;try{if(e){var r=Qa({},t.state);r.key=Qo(),t.replaceState(r,"",n)}else t.pushState({key:ko(Do())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ho(n){Vo(n,!0)}function Jo(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var Ko={redirected:2,aborted:4,cancelled:8,duplicated:16};function Yo(n,e){return Zo(n,e,Ko.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ns.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Xo(n,e){return Zo(n,e,Ko.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Zo(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var ns=["params","query","hash"];function es(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ts(n,e){return es(n)&&n._isRouter&&(null==e||n.type===e)}function rs(n){return function(e,t,r){var a=!1,o=0,s=null;as(n,(function(n,e,t,i){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=is((function(e){var a;((a=e).__esModule||ss&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:_o.extend(e),t.components[i]=e,--o<=0&&r()})),p=is((function(n){var e="Failed to resolve async component "+i+": "+n;s||(s=es(n)?n:new Error(e),r(s))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,p)}}})),a||r()}}function as(n,e){return os(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function os(n){return Array.prototype.concat.apply([],n)}var ss="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function is(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var ls=function(n,e){this.router=n,this.base=function(n){if(!n)if(Lo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Ga,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function cs(n,e,t,r){var a=as(n,(function(n,r,a,o){var s=function(n,e){"function"!=typeof n&&(n=_o.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,r,a,o)})):t(s,r,a,o)}));return os(r?a.reverse():a)}function ps(n,e){if(e)return function(){return n.apply(e,arguments)}}ls.prototype.listen=function(n){this.cb=n},ls.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},ls.prototype.onError=function(n){this.errorCbs.push(n)},ls.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ts(n,Ko.redirected)&&o===Ga||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},ls.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,s,i=function(n){!ts(n)&&es(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(Ha(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),i(((s=Zo(o=a,n,Ko.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",s));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=p.updated,d=p.deactivated,m=p.activated,f=[].concat(function(n){return cs(n,"beforeRouteLeave",ps,!0)}(d),this.router.beforeHooks,function(n){return cs(n,"beforeRouteUpdate",ps)}(u),m.map((function(n){return n.beforeEnter})),rs(m)),g=function(e,t){if(r.pending!==n)return i(Xo(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),i(function(n,e){return Zo(n,e,Ko.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):es(e)?(r.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(Yo(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){i(n)}};Jo(f,g,(function(){Jo(function(n){return cs(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return i(Xo(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Ka(n)}))}))}))},ls.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},ls.prototype.setupListeners=function(){},ls.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Ga,this.pending=null};var us=function(n){function e(e,t){n.call(this,e,t),this._startLocation=ds(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=zo&&t;r&&this.listeners.push(To());var a=function(){var t=n.current,a=ds(n.base);n.current===Ga&&a===n._startLocation||n.transitionTo(a,(function(n){r&&Po(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Vo(no(r.base+n.fullPath)),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Ho(no(r.base+n.fullPath)),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(ds(this.base)!==this.current.fullPath){var e=no(this.base+this.current.fullPath);n?Vo(e):Ho(e)}},e.prototype.getCurrentLocation=function(){return ds(this.base)},e}(ls);function ds(n){var e=window.location.pathname;return n&&0===e.toLowerCase().indexOf(n.toLowerCase())&&(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var ms=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=ds(n);if(!/^\/#/.test(e))return window.location.replace(no(n+"/#"+e)),!0}(this.base)||fs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=zo&&e;t&&this.listeners.push(To());var r=function(){var e=n.current;fs()&&n.transitionTo(gs(),(function(r){t&&Po(n.router,r,e,!0),zo||vs(r.fullPath)}))},a=zo?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){ys(n.fullPath),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){vs(n.fullPath),Po(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;gs()!==e&&(n?ys(e):vs(e))},e.prototype.getCurrentLocation=function(){return gs()},e}(ls);function fs(){var n=gs();return"/"===n.charAt(0)||(vs("/"+n),!1)}function gs(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function hs(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function ys(n){zo?Vo(hs(n)):window.location.hash=n}function vs(n){zo?Ho(hs(n)):window.location.replace(hs(n))}var qs=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ts(n,Ko.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(ls),bs=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Co(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!zo&&!1!==n.fallback,this.fallback&&(e="hash"),Lo||(e="abstract"),this.mode=e,e){case"history":this.history=new us(this,n.base);break;case"hash":this.history=new ms(this,n.base,this.fallback);break;case"abstract":this.history=new qs(this,n.base);break;default:0}},_s={currentRoute:{configurable:!0}};function Ss(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}bs.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},_s.currentRoute.get=function(){return this.history&&this.history.current},bs.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof us||t instanceof ms){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;zo&&a&&"fullPath"in n&&Po(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},bs.prototype.beforeEach=function(n){return Ss(this.beforeHooks,n)},bs.prototype.beforeResolve=function(n){return Ss(this.resolveHooks,n)},bs.prototype.afterEach=function(n){return Ss(this.afterHooks,n)},bs.prototype.onReady=function(n,e){this.history.onReady(n,e)},bs.prototype.onError=function(n){this.history.onError(n)},bs.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},bs.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},bs.prototype.go=function(n){this.history.go(n)},bs.prototype.back=function(){this.go(-1)},bs.prototype.forward=function(){this.go(1)},bs.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},bs.prototype.resolve=function(n,e,t){var r=bo(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?no(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},bs.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Ga&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(bs.prototype,_s),bs.install=function n(e){if(!n.installed||_o!==e){n.installed=!0,_o=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ya),e.component("RouterLink",Eo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},bs.version="3.4.9",bs.isNavigationFailure=ts,bs.NavigationFailureType=Ko,Lo&&window.Vue&&window.Vue.use(bs);var Es=bs;var xs={NotFound:()=>t.e(9).then(t.bind(null,199)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,196))},Ls={"v-7353dea0":()=>t.e(13).then(t.bind(null,219)),"v-cfbe7920":()=>t.e(11).then(t.bind(null,220)),"v-ab678418":()=>t.e(12).then(t.bind(null,221)),"v-36dd9580":()=>t.e(15).then(t.bind(null,222)),"v-00442cab":()=>t.e(14).then(t.bind(null,223)),"v-df81072a":()=>t.e(16).then(t.bind(null,224)),"v-0b7b932a":()=>t.e(17).then(t.bind(null,218)),"v-2e849a2f":()=>t.e(18).then(t.bind(null,217)),"v-6053133c":()=>t.e(19).then(t.bind(null,216)),"v-76bd776b":()=>t.e(20).then(t.bind(null,215)),"v-610199ea":()=>t.e(21).then(t.bind(null,201)),"v-919e5336":()=>t.e(22).then(t.bind(null,213)),"v-78e55c2b":()=>t.e(24).then(t.bind(null,212)),"v-7608f377":()=>t.e(25).then(t.bind(null,211)),"v-381b576b":()=>t.e(23).then(t.bind(null,226)),"v-c0980c7c":()=>t.e(7).then(t.bind(null,209)),"v-4db41f02":()=>t.e(28).then(t.bind(null,208)),"v-ba42e200":()=>t.e(27).then(t.bind(null,207)),"v-0244eaea":()=>t.e(26).then(t.bind(null,206)),"v-07b9536a":()=>t.e(8).then(t.bind(null,210)),"v-7f98fc0c":()=>t.e(31).then(t.bind(null,205)),"v-9fe9d8ae":()=>t.e(30).then(t.bind(null,204)),"v-1dc275ea":()=>t.e(29).then(t.bind(null,203)),"v-39db5ec0":()=>t.e(32).then(t.bind(null,214)),"v-068e54e0":()=>t.e(3).then(t.bind(null,202))};function ws(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const As=/-(\w)/g,Cs=ws(n=>n.replace(As,(n,e)=>e?e.toUpperCase():"")),js=/\B([A-Z])/g,Is=ws(n=>n.replace(js,"-$1").toLowerCase()),Ds=ws(n=>n.charAt(0).toUpperCase()+n.slice(1));function Ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ds(Cs(e))):n(Ds(e))||n(Is(e))}const Qs=Object.assign({},xs,Ls),ks=n=>Qs[n],Os=n=>Ls[n],Ts=n=>xs[n],Ps=n=>Na.component(n);function Fs(n){return Ns(Os,n)}function Rs(n){return Ns(Ts,n)}function Ms(n){return Ns(ks,n)}function $s(n){return Ns(Ps,n)}function Us(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!$s(n)&&Ms(n)){const e=await Ms(n)();Na.component(n,e.default)}}))}function Bs(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Ws=t(46),Gs=t.n(Ws),zs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${n[t]}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=Hs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=Js(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Gs()([{name:"description",content:this.$description}],n,this.siteMeta,Ks)},updateCanonicalLink(){Vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Hs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){Js(null,this.currentMetaTags),Vs()}};function Vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Hs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function Js(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Ks(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Ys=t(47),Xs={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Ys)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],s=e[n+1],i=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(i&&l!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Zs=t(12),ni=t.n(Zs),ei=[zs,Xs,{mounted(){ni.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Na.component(n.name)||ni.a.start(),t()}),this.$router.afterEach(()=>{ni.a.done(),this.isSidebarOpen=!1})}}],ti={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Bs("layout",n),Na.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ri=t(3),ai=Object(ri.a)(ti,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(ai,"mixins",ei);const oi=[{name:"v-7353dea0",path:"/background/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-7353dea0").then(t)}},{path:"/background/index.html",redirect:"/background/"},{name:"v-cfbe7920",path:"/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-cfbe7920").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-ab678418",path:"/about/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-ab678418").then(t)}},{path:"/about/index.html",redirect:"/about/"},{name:"v-36dd9580",path:"/basics/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-36dd9580").then(t)}},{path:"/basics/index.html",redirect:"/basics/"},{name:"v-00442cab",path:"/background/el.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-00442cab").then(t)}},{name:"v-df81072a",path:"/basics/entity-api.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-df81072a").then(t)}},{name:"v-0b7b932a",path:"/basics/sql-file-api.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-0b7b932a").then(t)}},{name:"v-2e849a2f",path:"/basics/transaction.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-2e849a2f").then(t)}},{name:"v-6053133c",path:"/configuration/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-6053133c").then(t)}},{path:"/configuration/index.html",redirect:"/configuration/"},{name:"v-76bd776b",path:"/configuration/connection-supplier.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-76bd776b").then(t)}},{name:"v-610199ea",path:"/configuration/dialect.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-610199ea").then(t)}},{name:"v-919e5336",path:"/configuration/entity-handler.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-919e5336").then(t)}},{name:"v-78e55c2b",path:"/configuration/sql-context-factory.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-78e55c2b").then(t)}},{name:"v-7608f377",path:"/configuration/sql-filter-manager.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-7608f377").then(t)}},{name:"v-381b576b",path:"/configuration/sql-agent-factory.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-381b576b").then(t)}},{name:"v-c0980c7c",path:"/developer_tools/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-c0980c7c").then(t)}},{path:"/developer_tools/index.html",redirect:"/developer_tools/"},{name:"v-4db41f02",path:"/getting_started/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-4db41f02").then(t)}},{path:"/getting_started/index.html",redirect:"/getting_started/"},{name:"v-ba42e200",path:"/developer_guide/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-ba42e200").then(t)}},{path:"/developer_guide/index.html",redirect:"/developer_guide/"},{name:"v-0244eaea",path:"/configuration/sql-manager.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-0244eaea").then(t)}},{name:"v-07b9536a",path:"/getting_started/sql-file-access.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-07b9536a").then(t)}},{name:"v-7f98fc0c",path:"/license/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-7f98fc0c").then(t)}},{path:"/license/index.html",redirect:"/license/"},{name:"v-9fe9d8ae",path:"/getting_started/sql-repl.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-9fe9d8ae").then(t)}},{name:"v-1dc275ea",path:"/getting_started/entity-access.html",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-1dc275ea").then(t)}},{name:"v-39db5ec0",path:"/why_uroborosql/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-39db5ec0").then(t)}},{path:"/why_uroborosql/index.html",redirect:"/why_uroborosql/"},{name:"v-068e54e0",path:"/advanced/",component:ai,beforeEnter:(n,e,t)=>{Us("Layout","v-068e54e0").then(t)}},{path:"/advanced/index.html",redirect:"/advanced/"},{path:"*",component:ai}],si={title:"uroboroSQL",description:"uroboroSQLはJava製のシンプルなSQL実行ライブラリです",base:"/uroborosql-doc/",headTags:[["link",{rel:"icon",href:"/uroborosql-doc/favicon.ico"}],["meta",{name:"og:type",content:"website"}],["meta",{name:"og:description",content:"uroboroSQLDeveloper-oriented and SQL centric database access library."}],["meta",{name:"og:image",content:"https://future-architect.github.io/uroborosql-doc/images/logo.png"}]],pages:[{title:"2WaySQL",frontmatter:{meta:[{name:"og:title",content:"2WaySQL"},{name:"og:url",content:"/uroborosql-doc/background/"}]},regularPath:"/background/",relativePath:"background/README.md",key:"v-7353dea0",path:"/background/",headers:[{level:2,title:"2WaySQLとは",slug:"_2waysqlとは",charIndex:73},{level:2,title:"バインドパラメータ (/* */)",slug:"バインドパラメータ",charIndex:205},{level:3,title:"IN句の利用方法",slug:"in句の利用方法",charIndex:613},{level:3,title:"LIKE句の利用方法",slug:"like句の利用方法",charIndex:1038},{level:2,title:"バインド出来るパラメータの型",slug:"バインド出来るパラメータの型",charIndex:2108},{level:2,title:"置換文字列 (/*$ */ , /*# */)",slug:"置換文字列",charIndex:null},{level:2,title:"条件分岐 ( /*IF*/, /*ELIF*/, /*ELSE*/, /*END*/ )",slug:"条件分岐-if-elif-else-end",charIndex:null},{level:3,title:"記述方法",slug:"記述方法",charIndex:3636},{level:2,title:"範囲の有効化 ( /*BEGIN*/, /*END*/ )",slug:"範囲の有効化-begin-end",charIndex:null},{level:2,title:"不要なカンマの除去",slug:"不要なカンマの除去",charIndex:6277}],lastUpdated:"2020-3-8 21:44:34",headersStr:"2WaySQLとは バインドパラメータ (/* */) IN句の利用方法 LIKE句の利用方法 バインド出来るパラメータの型 置換文字列 (/*$ */ , /*# */) 条件分岐 ( /*IF*/, /*ELIF*/, /*ELSE*/, /*END*/ ) 記述方法 範囲の有効化 ( /*BEGIN*/, /*END*/ ) 不要なカンマの除去",content:"# 2WaySQL\nuroboroSQLの基本操作について説明する前にuroboroSQLを利用する上で必要になる項目について説明します。\n\n# 2WaySQLとは\n2WaySQLは普通のSQL文をファイルに保存したものです。そのままSQLクライアントツールで実行することもできますし、uroboroSQLで読み込んで実行することも出来ます。\n（２つの実行方法があることから2WaySQLと呼ばれます）\n\n# バインドパラメータ (/* */)\nSQLにバインドするパラメータを /*parameter name*/の形式で指定することができます。\n\nselect\n  *\nfrom\n  department\nwhere\n  dept_no    =  /*dept_no*/10\nAND  dept_name  =  /*dept_name*/'Sales'\n\n\n1\n2\n3\n4\n5\n6\n7\n上の例では、/*dept_no*/, /*dept_name*/ がバインドパラメータで、uroboroSQLから実行される際はこの部分が?に置き換わり、後ろの10や'Sales'が削除されます。\n\nselect\n  *\nfrom\n  department\nwhere\n  dept_no    =  ?/*dept_no*/\nand  dept_name  =  ?/*dept_name*/\n\n\n1\n2\n3\n4\n5\n6\n7\n# IN句の利用方法\nList型の値をIN句のバインドパラメータとして指定することもできます。\n\nWARNING\n\nIN句にバインドパラメータを指定する場合、バインドパラメータの後ろに()を記述する必要があります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*IF gender_list != null*/\nand  emp.gender  in  /*gender_list*/('M')\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n上の例にgender_listとして{\"M\", \"F\"}を指定すると以下のように変換されます。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*IF gender_list != null*/\nand  emp.gender  in  (?, ?)/*gender_list*/\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# LIKE句の利用方法\nLIKE句に対してバインドパラメータを使用する場合は、以下のようにStringFunctionを使って記述してください。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*IF first_name != null*/\nand  emp.first_name like /*SF.contains(first_name)*/'' escape /*#ESC_CHAR*/'$'\n/*END*/\n/*IF last_name != null*/\nand  emp.last_name  like /*SF.startsWith(last_name)*/'' escape /*#ESC_CHAR*/'$'\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n上の例で、バインドパラメータ first_nameにa, last_nameにDを指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n    emp.first_name like '%a%' escape '$'\nand emp.last_name  like 'D%' escape '$'\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n上の例で、ワイルドカードを含む例としてバインドパラメータ first_nameにa%, last_nameにD_を指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n    emp.first_name like '%a$%%' escape '$' -- %がエスケープされる\nand emp.last_name  like 'D$_%' escape '$'  -- _がエスケープされる\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nTIP\n\nワイルドカード（%や_）を含む文字列がバインドパラメータに指定された場合でも、StringFunctionを利用することで文字列のエスケープ処理が適切に行われます。\n\nWARNING\n\nエスケープキャラクタ（上記の例では$）はDB毎の設定（Dialect）によって変わります。\n現在の設定では、Oracleの場合は\\, その他のDBでは$となります。\n\\や$のかわりに/*#ESC_CHAR*/と記載することでDB毎の設定を気にせずにエスケープ文字を指定することができます。\n\n# バインド出来るパラメータの型\nバインドパラメータに指定できるJava型は以下になります。\n\n * プリミティブ型とそのラッパー型（ただし char と java.lang.Character は除く）\n * java.math.BigDecimal\n * java.math.BigInteger\n * java.lang.String\n * byte[]\n * java.sql.Date\n * java.sql.Time\n * java.sql.Timestamp\n * java.sql.Array\n * java.sql.Ref\n * java.sql.Blob\n * java.sql.Clob\n * java.sql.SQLXML\n * java.sql.Struct\n * 列挙型(enum)\n * java.util.Date\n * java.util.Optional\n * java.util.OptionalInt\n * java.util.OptionalLong\n * java.util.OptionalDouble\n * java.time.LocalDateTime\n * java.time.OffsetDateTime\n * java.time.ZonedDateTime\n * java.time.LocalDate\n * java.time.LocalTime\n * java.time.OffsetTime\n * java.time.Year\n * java.time.YearMonth\n * java.time.MonthDay\n * java.time.Month\n * java.time.DayOfWeek\n\n# 置換文字列 (/*$ */ , /*# */)\n置換文字列を使うとSQLを動的に変更することができます。\n\n置換文字列は /*$parameter name*/ もしくは /*#parameter name*/と記述します。\n/*#parameter name*/ と記述した場合は、置換文字列の前後を'(シングルクォート)で囲みます。\n\nselect\n  *\nfrom    /*$table_name*/\nwhere\n  gender  =  /*#gender*/\n\n\n1\n2\n3\n4\n5\n上の例では、table_nameやgenderに設定した値でSQLが置換されます。\n\n * table_nameにemployee, genderにMを設定した場合\n\nselect\n  *\nfrom  employee\nwhere\n  gender  =  'M'\n\n\n1\n2\n3\n4\n5\nという風に置換されたSQLが実行されることになります。\n\n注意\n\n置換文字列はSQLインジェクションなど脆弱性の原因となる可能性があります。十分に注意を払ったうえで利用してください\n\nTIP\n\n置換文字列はSQLインジェクションを防ぐため、変換の際にシングルクォート'を''にエスケープします\n\nWARNING\n\n置換文字列はバインドパラメータとしてではなく実行されるSQLを構築する時点で置換される点に注意してください。\nデータベースによってはSQL文が動的に変わることで解析結果のキャッシュが適用されず、\n解析処理が都度実行されることでCPUに負荷をかける可能性があります。\n\n# 条件分岐 ( /*IF*/, /*ELIF*/, /*ELSE*/, /*END*/ )\n/*IF*/, /*ELIF*/, /*ELSE*/, /*END*/ を使用してSQLを動的に変更することができます。\n\n# 記述方法\n/*IF [評価式]*/\n-- IFの評価式が真の場合に適用されるSQL\n/*ELIF [評価式]*/\n-- ELIFの評価式が真の場合に適用されるSQL\n/*ELSE*/\n-- IF,ELIFの評価式が偽の場合に適用されるSQL\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n/*IF*/, /*ELIF*/の評価式として式言語を利用します。 （ 式言語の説明はこちら )\nまた、標準でSF関数(String Function)を使うことができます。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*IF SF.isNotEmpty(birth_date_from) and SF.isNotEmpty(birth_date_to)*/\nand  emp.birth_date  between  /*birth_date_from*/'1990-01-01'  and  /*birth_date_to*/'1999-12-31'\n/*ELIF SF.isNotEmpty(birth_date_from)*/\nand  emp.birth_date  >=    /*birth_date_from*/'1990-01-01'\n/*ELIF SF.isNotEmpty(birth_date_to)*/\nand  emp.birth_date  <    /*birth_date_to*/'1999-12-31'\n/*ELSE*/\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n上の例ではIFの評価式としてSF.isNotEmpty()を使用してバインドパラメータがnullまたは\"\"でないことを評価しています。\n\nバインドパラメータとしてbirth_date_fromに2000-01-01, birth_date_toに2010-12-31を指定した場合、生成されるSQLは以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  emp.birth_date  between  ?/*birth_date_from*/  and  ?/*birth_date_to*/\n\n\n1\n2\n3\n4\n5\n6\n最後にバインドパラメータが評価され、実行されるSQLが以下になります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  emp.birth_date  between  '2000-01-01'/*birth_date_from*/  and  '2010-12-31'/*birth_date_to*/\n\n\n1\n2\n3\n4\n5\n6\nここでemp.birth_dateの前にあったandが消えていることに注目してください。\n\nTIP\n\nuroboroSQLでは動的SQLを生成する際、WHERE句の後ろにandやorが来る場合はそれを削除してSQL文として正しい状態にします\n\nただし、上の加工前SQLのようにSQL文として不正な状態になってしまうのでSQLクライアントツールからは実行できないという欠点もあります。\nこのようにSQL文として不正になることを防ぐために、WHERE句のあとに他に影響を与えない評価を入れる方法があります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  1        =    1  // <-- 必ずtrueとなる評価を入れる\n/*IF SF.isNotEmpty(birth_date_from) and SF.isNotEmpty(birth_date_to)*/\nand  emp.birth_date  between  /*birth_date_from*/'1990-01-01'  and  /*birth_date_to*/'1999-12-31'\n/*ELIF SF.isNotEmpty(birth_date_from)*/\nand  emp.birth_date  >=    /*birth_date_from*/'1990-01-01'\n/*ELIF SF.isNotEmpty(birth_date_to)*/\nand  emp.birth_date  <    /*birth_date_to*/'1999-12-31'\n/*ELSE*/\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 範囲の有効化 ( /*BEGIN*/, /*END*/ )\n/*BEGIN*/, /*END*/ で囲まれた範囲は、その中の/*IF*/, /*ELIF*/のうち、どれか1つでも真(true)になった場合に出力されます。\n範囲内の全ての評価式が偽（false）の場合、/*BEGIN*/, /*END*/ で囲まれた範囲は出力されません。\n\nselect\n  *\nfrom\n  employee  emp\n/*BEGIN*/\nwhere\n/*IF SF.isNotEmpty(first_name)*/\nand  emp.first_name  =  /*first_name*/'Bob'\n/*END*/\n/*IF SF.isNotEmpty(last_name)*/\nand  emp.last_name  =  /*last_name*/'Smith'\n/*END*/\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n上の例で、バインドパラメータ first_nameにWillson, last_nameにnullを指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  emp.first_name  =  ?/*first_name*/\n\n\n1\n2\n3\n4\n5\n6\nバインドパラメータ first_name, last_nameともにnullを指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\n\n\n1\n2\n3\n4\n/*BEGIN*/,/*END*/で囲まれたwhereが出力されていないことがわかります。\n\n# 不要なカンマの除去\nIF分岐を使って動的なSQLを構築する場合、カンマの有無が問題になる場合があります。\n以下のSQLを例として説明します。\n\nselect\n/*IF detail*/\n,  first_name\n,  last_name\n,  birth_date\n,  gender\n/*END*/\n,  emp_no\nfrom\n  employee  emp\norder by\n/*IF detail*/\n,  birth_date\n/*END*/\n,  emp_no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nここでバインドパラメータdetailにtrueを指定した場合、生成されるSQLは以下になります。\n\nselect\n,  first_name\n,  last_name\n,  birth_date\n,  gender\n,  emp_no\nfrom\n  employee  emp\norder by\n,  birth_date\n,  emp_no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nこのSQLではselectの直後やorder byの直後にカンマが出現しておりSQL文として不正であるため、SQLの実行に失敗します。\nこれを避けるためuroboroSQLでは、生成後のSQLに含まれる不要なカンマを除去するようになっています。\n\n実際に生成されるSQLは以下になります。\n\nselect\n  first_name     -- 先頭のカンマが除去される\n,  last_name\n,  birth_date\n,  gender\n,  emp_no\nfrom\n  employee  emp\norder by\n  birth_date     -- 先頭のカンマが除去される\n,  emp_no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nカンマが除去されるのは、以下の予約語の直後にカンマが出現した場合です（大文字小文字の区別無し）。\n\n * SELECT\n * ORDER BY\n * GROUP BY\n * (\n * SET",contentLowercase:"# 2waysql\nuroborosqlの基本操作について説明する前にuroborosqlを利用する上で必要になる項目について説明します。\n\n# 2waysqlとは\n2waysqlは普通のsql文をファイルに保存したものです。そのままsqlクライアントツールで実行することもできますし、uroborosqlで読み込んで実行することも出来ます。\n（２つの実行方法があることから2waysqlと呼ばれます）\n\n# バインドパラメータ (/* */)\nsqlにバインドするパラメータを /*parameter name*/の形式で指定することができます。\n\nselect\n  *\nfrom\n  department\nwhere\n  dept_no    =  /*dept_no*/10\nand  dept_name  =  /*dept_name*/'sales'\n\n\n1\n2\n3\n4\n5\n6\n7\n上の例では、/*dept_no*/, /*dept_name*/ がバインドパラメータで、uroborosqlから実行される際はこの部分が?に置き換わり、後ろの10や'sales'が削除されます。\n\nselect\n  *\nfrom\n  department\nwhere\n  dept_no    =  ?/*dept_no*/\nand  dept_name  =  ?/*dept_name*/\n\n\n1\n2\n3\n4\n5\n6\n7\n# in句の利用方法\nlist型の値をin句のバインドパラメータとして指定することもできます。\n\nwarning\n\nin句にバインドパラメータを指定する場合、バインドパラメータの後ろに()を記述する必要があります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*if gender_list != null*/\nand  emp.gender  in  /*gender_list*/('m')\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n上の例にgender_listとして{\"m\", \"f\"}を指定すると以下のように変換されます。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*if gender_list != null*/\nand  emp.gender  in  (?, ?)/*gender_list*/\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# like句の利用方法\nlike句に対してバインドパラメータを使用する場合は、以下のようにstringfunctionを使って記述してください。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*if first_name != null*/\nand  emp.first_name like /*sf.contains(first_name)*/'' escape /*#esc_char*/'$'\n/*end*/\n/*if last_name != null*/\nand  emp.last_name  like /*sf.startswith(last_name)*/'' escape /*#esc_char*/'$'\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n上の例で、バインドパラメータ first_nameにa, last_nameにdを指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n    emp.first_name like '%a%' escape '$'\nand emp.last_name  like 'd%' escape '$'\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n上の例で、ワイルドカードを含む例としてバインドパラメータ first_nameにa%, last_nameにd_を指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n    emp.first_name like '%a$%%' escape '$' -- %がエスケープされる\nand emp.last_name  like 'd$_%' escape '$'  -- _がエスケープされる\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\ntip\n\nワイルドカード（%や_）を含む文字列がバインドパラメータに指定された場合でも、stringfunctionを利用することで文字列のエスケープ処理が適切に行われます。\n\nwarning\n\nエスケープキャラクタ（上記の例では$）はdb毎の設定（dialect）によって変わります。\n現在の設定では、oracleの場合は\\, その他のdbでは$となります。\n\\や$のかわりに/*#esc_char*/と記載することでdb毎の設定を気にせずにエスケープ文字を指定することができます。\n\n# バインド出来るパラメータの型\nバインドパラメータに指定できるjava型は以下になります。\n\n * プリミティブ型とそのラッパー型（ただし char と java.lang.character は除く）\n * java.math.bigdecimal\n * java.math.biginteger\n * java.lang.string\n * byte[]\n * java.sql.date\n * java.sql.time\n * java.sql.timestamp\n * java.sql.array\n * java.sql.ref\n * java.sql.blob\n * java.sql.clob\n * java.sql.sqlxml\n * java.sql.struct\n * 列挙型(enum)\n * java.util.date\n * java.util.optional\n * java.util.optionalint\n * java.util.optionallong\n * java.util.optionaldouble\n * java.time.localdatetime\n * java.time.offsetdatetime\n * java.time.zoneddatetime\n * java.time.localdate\n * java.time.localtime\n * java.time.offsettime\n * java.time.year\n * java.time.yearmonth\n * java.time.monthday\n * java.time.month\n * java.time.dayofweek\n\n# 置換文字列 (/*$ */ , /*# */)\n置換文字列を使うとsqlを動的に変更することができます。\n\n置換文字列は /*$parameter name*/ もしくは /*#parameter name*/と記述します。\n/*#parameter name*/ と記述した場合は、置換文字列の前後を'(シングルクォート)で囲みます。\n\nselect\n  *\nfrom    /*$table_name*/\nwhere\n  gender  =  /*#gender*/\n\n\n1\n2\n3\n4\n5\n上の例では、table_nameやgenderに設定した値でsqlが置換されます。\n\n * table_nameにemployee, genderにmを設定した場合\n\nselect\n  *\nfrom  employee\nwhere\n  gender  =  'm'\n\n\n1\n2\n3\n4\n5\nという風に置換されたsqlが実行されることになります。\n\n注意\n\n置換文字列はsqlインジェクションなど脆弱性の原因となる可能性があります。十分に注意を払ったうえで利用してください\n\ntip\n\n置換文字列はsqlインジェクションを防ぐため、変換の際にシングルクォート'を''にエスケープします\n\nwarning\n\n置換文字列はバインドパラメータとしてではなく実行されるsqlを構築する時点で置換される点に注意してください。\nデータベースによってはsql文が動的に変わることで解析結果のキャッシュが適用されず、\n解析処理が都度実行されることでcpuに負荷をかける可能性があります。\n\n# 条件分岐 ( /*if*/, /*elif*/, /*else*/, /*end*/ )\n/*if*/, /*elif*/, /*else*/, /*end*/ を使用してsqlを動的に変更することができます。\n\n# 記述方法\n/*if [評価式]*/\n-- ifの評価式が真の場合に適用されるsql\n/*elif [評価式]*/\n-- elifの評価式が真の場合に適用されるsql\n/*else*/\n-- if,elifの評価式が偽の場合に適用されるsql\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n/*if*/, /*elif*/の評価式として式言語を利用します。 （ 式言語の説明はこちら )\nまた、標準でsf関数(string function)を使うことができます。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n/*if sf.isnotempty(birth_date_from) and sf.isnotempty(birth_date_to)*/\nand  emp.birth_date  between  /*birth_date_from*/'1990-01-01'  and  /*birth_date_to*/'1999-12-31'\n/*elif sf.isnotempty(birth_date_from)*/\nand  emp.birth_date  >=    /*birth_date_from*/'1990-01-01'\n/*elif sf.isnotempty(birth_date_to)*/\nand  emp.birth_date  <    /*birth_date_to*/'1999-12-31'\n/*else*/\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n上の例ではifの評価式としてsf.isnotempty()を使用してバインドパラメータがnullまたは\"\"でないことを評価しています。\n\nバインドパラメータとしてbirth_date_fromに2000-01-01, birth_date_toに2010-12-31を指定した場合、生成されるsqlは以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  emp.birth_date  between  ?/*birth_date_from*/  and  ?/*birth_date_to*/\n\n\n1\n2\n3\n4\n5\n6\n最後にバインドパラメータが評価され、実行されるsqlが以下になります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  emp.birth_date  between  '2000-01-01'/*birth_date_from*/  and  '2010-12-31'/*birth_date_to*/\n\n\n1\n2\n3\n4\n5\n6\nここでemp.birth_dateの前にあったandが消えていることに注目してください。\n\ntip\n\nuroborosqlでは動的sqlを生成する際、where句の後ろにandやorが来る場合はそれを削除してsql文として正しい状態にします\n\nただし、上の加工前sqlのようにsql文として不正な状態になってしまうのでsqlクライアントツールからは実行できないという欠点もあります。\nこのようにsql文として不正になることを防ぐために、where句のあとに他に影響を与えない評価を入れる方法があります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  1        =    1  // <-- 必ずtrueとなる評価を入れる\n/*if sf.isnotempty(birth_date_from) and sf.isnotempty(birth_date_to)*/\nand  emp.birth_date  between  /*birth_date_from*/'1990-01-01'  and  /*birth_date_to*/'1999-12-31'\n/*elif sf.isnotempty(birth_date_from)*/\nand  emp.birth_date  >=    /*birth_date_from*/'1990-01-01'\n/*elif sf.isnotempty(birth_date_to)*/\nand  emp.birth_date  <    /*birth_date_to*/'1999-12-31'\n/*else*/\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 範囲の有効化 ( /*begin*/, /*end*/ )\n/*begin*/, /*end*/ で囲まれた範囲は、その中の/*if*/, /*elif*/のうち、どれか1つでも真(true)になった場合に出力されます。\n範囲内の全ての評価式が偽（false）の場合、/*begin*/, /*end*/ で囲まれた範囲は出力されません。\n\nselect\n  *\nfrom\n  employee  emp\n/*begin*/\nwhere\n/*if sf.isnotempty(first_name)*/\nand  emp.first_name  =  /*first_name*/'bob'\n/*end*/\n/*if sf.isnotempty(last_name)*/\nand  emp.last_name  =  /*last_name*/'smith'\n/*end*/\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n上の例で、バインドパラメータ first_nameにwillson, last_nameにnullを指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\nwhere\n  emp.first_name  =  ?/*first_name*/\n\n\n1\n2\n3\n4\n5\n6\nバインドパラメータ first_name, last_nameともにnullを指定した場合は以下のようになります。\n\nselect\n  *\nfrom\n  employee  emp\n\n\n1\n2\n3\n4\n/*begin*/,/*end*/で囲まれたwhereが出力されていないことがわかります。\n\n# 不要なカンマの除去\nif分岐を使って動的なsqlを構築する場合、カンマの有無が問題になる場合があります。\n以下のsqlを例として説明します。\n\nselect\n/*if detail*/\n,  first_name\n,  last_name\n,  birth_date\n,  gender\n/*end*/\n,  emp_no\nfrom\n  employee  emp\norder by\n/*if detail*/\n,  birth_date\n/*end*/\n,  emp_no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nここでバインドパラメータdetailにtrueを指定した場合、生成されるsqlは以下になります。\n\nselect\n,  first_name\n,  last_name\n,  birth_date\n,  gender\n,  emp_no\nfrom\n  employee  emp\norder by\n,  birth_date\n,  emp_no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nこのsqlではselectの直後やorder byの直後にカンマが出現しておりsql文として不正であるため、sqlの実行に失敗します。\nこれを避けるためuroborosqlでは、生成後のsqlに含まれる不要なカンマを除去するようになっています。\n\n実際に生成されるsqlは以下になります。\n\nselect\n  first_name     -- 先頭のカンマが除去される\n,  last_name\n,  birth_date\n,  gender\n,  emp_no\nfrom\n  employee  emp\norder by\n  birth_date     -- 先頭のカンマが除去される\n,  emp_no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nカンマが除去されるのは、以下の予約語の直後にカンマが出現した場合です（大文字小文字の区別無し）。\n\n * select\n * order by\n * group by\n * (\n * set",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroImage:"/images/logo.png",actionText:"Why uroboroSQL",actionLink:"/why_uroborosql/",features:[{title:"2Way-SQL with Coverage",details:"ORマッパー、クエリビルダならJavaコードでカバレッジが取れるのに、2Way-SQLで分岐を使った場合にはカバレッジが取れず本番環境で意図しないSQLが・・・。uroboroSQLではテスト実行時にカバレッジ取得用のログを出力・解析することにより、カバレッジレポートを出力することが可能です。"},{title:"REPL搭載",details:"SQLファイルを修正するたびにコンパイルしてテスト実行するのに時間がかかる・・・。他のORマッパーやSQLフレームワークでイライラしていた経験はありませんか？uroboroSQLではREPLを搭載。SQLを修正してすぐにIDE等のコンソールからコマンドでコンパイルなしで実行、即デバッグができます。"},{title:"区分値サポート",details:"2Way-SQLのライブラリを使用していると、それぞれのSQLで区分値や定数などをいちいちパラメータに指定するのがわずらわしいと思ったことはありませんか？エンタープライズで使われてOSS化したuroboroSQLでは、SQLファイルの中で定数クラスや列挙体を指定することにより、呼び出し時の実装をシンプルにします。"}],footer:"MIT Licensed | ©2018-2019 Future Corporation. All rights reserved.",meta:[{name:"og:title",content:"uroboroSQL"},{name:"og:url",content:"/uroborosql-doc/"}]},regularPath:"/",relativePath:"README.md",key:"v-cfbe7920",path:"/",lastUpdated:"2019-9-23 23:53:45",headersStr:null,content:"",contentLowercase:"",charsets:{}},{title:"uroboroSQLについて",frontmatter:{meta:[{name:"og:title",content:"uroboroSQLについて"},{name:"og:url",content:"/uroborosql-doc/about/"}]},regularPath:"/about/",relativePath:"about/README.md",key:"v-ab678418",path:"/about/",headers:[{level:2,title:"GitHub",slug:"github",charIndex:19},{level:2,title:"リリースノート",slug:"リリースノート",charIndex:76}],lastUpdated:"2020-11-19 23:55:38",headersStr:"GitHub リリースノート",content:"# uroboroSQLについて\n# GitHub\nhttps://github.com/future-architect/uroborosql\n\n# リリースノート\nバージョン     リリース日        概要                                                                                                                               \nv0.20.2   2020/10/29   バグフィックス                                                                                                                          \nv0.20.1   2020/09/17   バグフィックス                                                                                                                          \nv0.20.0   2020/08/25   バグフィックス                                                                                                                          \nv0.19.0   2020/05/17   日付・時刻を文字列型のカラムで保持する場合のマッパーを追加 / 複数DB接続を考慮したAPIの改善 / InsertsTypeのデフォルトをBATCHへ変更                                                   \nv0.18.2   2020/03/29   悲観的ロック例外時に、SQLExceptionの代わりに専用のPessimisticLockExceptionをスローするように変更                                                               \nv0.17.1   2020/03/16   バグフィックス (v0.18.1 の修正を v0.17.0へバックポート)                                                                                            \nv0.18.1   2020/03/15   バグフィックス                                                                                                                          \nv0.18.0   2020/03/08   SqlAgent#savepointScopeメソッド追加 / SqlEntityQuery#selectメソッド, hintメソッド追加 / 式言語としてSpring Expression Language(SpEL)を利用可能に / バグフィックス   \nv0.17.0   2019/12/22   SqlAgent#truncateメソッドを追加                                                                                                         \nv0.16.0   2019/12/13   @VersionアノテーションでOptimisticLockSupplierを指定可能に / バグフィックス                                                                           \nv0.15.2   2019/12/13   バグフィックス                                                                                                                          \nv0.15.1   2019/10/16   バグフィックス                                                                                                                          \nv0.15.0   2019/10/11   SqlEntityUpdateによる条件指定の複数更新サポート / SqlAgent#updates, SqlAgent#updatesAndReturnの追加による一括更新追加 / バグフィックス                              \nv0.14.0   2019/09/17   SqlEntityQueryで悲観ロックのサポート / SqlQuery#one,findOneの追加 / バグフィックス                                                                    \nv0.13.0   2019/04/26   REPLで使用しているjLineのバージョンを v2 から v3に変更。また依存関係をオプションに変更 / バグフィックス                                                                    \nv0.12.1   2019/04/12   バグフィックス                                                                                                                          \nv0.12.0   2019/04/09   自動採番カラムを持つエンティティの挿入に対応 / エンティティによる検索で集約関数を提供 / バグフィックス                                                                           \nv0.11.1   2019/03/12   バグフィックス                                                                                                                          \nv0.11.0   2019/03/11   エンティティによる検索で抽出条件の指定を可能に                                                                                                          \nv0.10.1   2019/02/07   SqlFluentにsqlIdとparam(String, Supplier)を追加 / バグフィックス                                                                             \nv0.10.0   2019/01/16   SqlAgent#insertsによる一括INSERT / バグフィックス                                                                                            \nv0.9.0    2019/01/07   NioSqlManagerのファイル監視を設定可能に / バグフィックス                                                                                             \nv0.8.2    2018/05/26   バグフィックス                                                                                                                          \nv0.8.1    2018/04/26   バグフィックス                                                                                                                          \nv0.8.0    2018/04/16   DialectによるDB製品対応 / CLOB/BLOB対応 / NioSqlMager追加 / etc.                                                                            \nv0.7.0    2018/03/10   バグフィックス                                                                                                                          \nv0.6.1    2018/02/05   バグフィックス                                                                                                                          \nv0.6.0    2018/01/31   自動パラメータバインド関数 API追加 / バグフィックス                                                                                                    \nv0.5.0    2017/12/13   Stream batch API追加 / SQL内の不要なカンマの除去                                                                                              \nv0.4.0    2017/11/17   UroboroSQL ビルダーAPI追加 / CaseFormat初期値設定の追加 / etc.                                                                                 \nv0.3.3    2017/10/31   バグフィックス                                                                                                                          \nv0.3.2    2017/10/10   バグフィックス                                                                                                                          \nv0.3.1    2017/10/02   バグフィックス                                                                                                                          \nv0.3.0    2017/09/08   リファクタリング API                                                                                                                     \nv0.2.0    2017/05/26   カバレッジレポート拡張 / SQL-REPL機能拡張 / ORMapper API 追加                                                                                     \nv0.1.0    2017/03/09   初版リリース                                                                                                                           \n\nSee more info. Github releases",contentLowercase:"# uroborosqlについて\n# github\nhttps://github.com/future-architect/uroborosql\n\n# リリースノート\nバージョン     リリース日        概要                                                                                                                               \nv0.20.2   2020/10/29   バグフィックス                                                                                                                          \nv0.20.1   2020/09/17   バグフィックス                                                                                                                          \nv0.20.0   2020/08/25   バグフィックス                                                                                                                          \nv0.19.0   2020/05/17   日付・時刻を文字列型のカラムで保持する場合のマッパーを追加 / 複数db接続を考慮したapiの改善 / insertstypeのデフォルトをbatchへ変更                                                   \nv0.18.2   2020/03/29   悲観的ロック例外時に、sqlexceptionの代わりに専用のpessimisticlockexceptionをスローするように変更                                                               \nv0.17.1   2020/03/16   バグフィックス (v0.18.1 の修正を v0.17.0へバックポート)                                                                                            \nv0.18.1   2020/03/15   バグフィックス                                                                                                                          \nv0.18.0   2020/03/08   sqlagent#savepointscopeメソッド追加 / sqlentityquery#selectメソッド, hintメソッド追加 / 式言語としてspring expression language(spel)を利用可能に / バグフィックス   \nv0.17.0   2019/12/22   sqlagent#truncateメソッドを追加                                                                                                         \nv0.16.0   2019/12/13   @versionアノテーションでoptimisticlocksupplierを指定可能に / バグフィックス                                                                           \nv0.15.2   2019/12/13   バグフィックス                                                                                                                          \nv0.15.1   2019/10/16   バグフィックス                                                                                                                          \nv0.15.0   2019/10/11   sqlentityupdateによる条件指定の複数更新サポート / sqlagent#updates, sqlagent#updatesandreturnの追加による一括更新追加 / バグフィックス                              \nv0.14.0   2019/09/17   sqlentityqueryで悲観ロックのサポート / sqlquery#one,findoneの追加 / バグフィックス                                                                    \nv0.13.0   2019/04/26   replで使用しているjlineのバージョンを v2 から v3に変更。また依存関係をオプションに変更 / バグフィックス                                                                    \nv0.12.1   2019/04/12   バグフィックス                                                                                                                          \nv0.12.0   2019/04/09   自動採番カラムを持つエンティティの挿入に対応 / エンティティによる検索で集約関数を提供 / バグフィックス                                                                           \nv0.11.1   2019/03/12   バグフィックス                                                                                                                          \nv0.11.0   2019/03/11   エンティティによる検索で抽出条件の指定を可能に                                                                                                          \nv0.10.1   2019/02/07   sqlfluentにsqlidとparam(string, supplier)を追加 / バグフィックス                                                                             \nv0.10.0   2019/01/16   sqlagent#insertsによる一括insert / バグフィックス                                                                                            \nv0.9.0    2019/01/07   niosqlmanagerのファイル監視を設定可能に / バグフィックス                                                                                             \nv0.8.2    2018/05/26   バグフィックス                                                                                                                          \nv0.8.1    2018/04/26   バグフィックス                                                                                                                          \nv0.8.0    2018/04/16   dialectによるdb製品対応 / clob/blob対応 / niosqlmager追加 / etc.                                                                            \nv0.7.0    2018/03/10   バグフィックス                                                                                                                          \nv0.6.1    2018/02/05   バグフィックス                                                                                                                          \nv0.6.0    2018/01/31   自動パラメータバインド関数 api追加 / バグフィックス                                                                                                    \nv0.5.0    2017/12/13   stream batch api追加 / sql内の不要なカンマの除去                                                                                              \nv0.4.0    2017/11/17   uroborosql ビルダーapi追加 / caseformat初期値設定の追加 / etc.                                                                                 \nv0.3.3    2017/10/31   バグフィックス                                                                                                                          \nv0.3.2    2017/10/10   バグフィックス                                                                                                                          \nv0.3.1    2017/10/02   バグフィックス                                                                                                                          \nv0.3.0    2017/09/08   リファクタリング api                                                                                                                     \nv0.2.0    2017/05/26   カバレッジレポート拡張 / sql-repl機能拡張 / ormapper api 追加                                                                                     \nv0.1.0    2017/03/09   初版リリース                                                                                                                           \n\nsee more info. github releases",charsets:{cjk:!0}},{title:"事前準備",frontmatter:{meta:[{name:"og:title",content:"事前準備"},{name:"og:url",content:"/uroborosql-doc/basics/"}]},regularPath:"/basics/",relativePath:"basics/README.md",key:"v-36dd9580",path:"/basics/",headers:[{level:2,title:"DB接続",slug:"db接続",charIndex:41},{level:2,title:"SqlAgentインスタンスの取得",slug:"sqlagentインスタンスの取得",charIndex:854},{level:2,title:"SQLファイルの配置",slug:"sqlファイルの配置",charIndex:1200},{level:3,title:"SQL名",slug:"sql名",charIndex:1795},{level:3,title:"共通API",slug:"共通api",charIndex:2289}],lastUpdated:"2019-9-23 23:39:17",headersStr:"DB接続 SqlAgentインスタンスの取得 SQLファイルの配置 SQL名 共通API",content:'# 事前準備\nuroboroSQLを利用した基本的なDB操作を説明します。\n\n# DB接続\nまず最初にSQLを実行するDBへの接続を行います。\nDBに接続するためにはSqlConfigインタフェースのインスタンスを生成する必要があります。\n\nSqlConfigインスタンスはUroboroSQLクラスのビルダーメソッドを使用して生成します。\n\n// JDBC接続を行うSqlConfigの生成\n// SqlConfig config = UroboroSQL.builder(url, user, password).build();\nSqlConfig config = UroboroSQL.builder("jdbc:h2:mem:uroborosql", "sa", "").build();\n\n// DataSourceを使用したDB接続を行うSqlConfigの生成\n// SqlConfig config = UroboroSQL.builder(datasource).build();\nContext context = new InitialContext();\nDataSource dataSource = context.lookup("java:comp/env/jdbc/datasource");\nSqlConfig config = UroboroSQL.builder(dataSource).build();\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nUroboroSQLクラスを使ってSqlConfigインスタンスを生成する際、uroboroSQLの挙動を変更する各種の設定も合わせて行うことができます。\n設定の詳細については設定を参照してください。\n\nWARNING\n\nSqlConfigインスタンスはアプリケーション内で接続先毎に１つ保持するようにしてください。 SQL実行の都度生成すると、不要なインスタンスの生成やSQLロード処理が実行されます。\n\n# SqlAgentインスタンスの取得\n次にすべての操作の基点となるSqlAgentインタフェースのインスタンスを取得します。\n\ntry (SqlAgent agent = config.agent()) {\n  // この中でSQLの操作を行う\n}\n\n\n1\n2\n3\nSQLの操作はすべてこのSqlAgentインスタンスを使って行うことになります。\n\nTIP\n\nSqlAgentインタフェースはjava.lang.AutoClosableインタフェースを実装しており、try-with-resourcesで記述することで終了時に自動的にclose処理が呼び出され、中で保持しているConnectionやPreparedStatementなどのリソースオブジェクトも正しくクローズされます。\n\n# SQLファイルの配置\nuroboroSQLではSQL文の書かれたファイルのパスを指定してSQLを実行することができます。\nその際、SQLファイルはクラスパスから参照できる場所に配置されている必要があります。\n\nsrc\n    └─main\n        └─resources\n            └─sql\n                ├─department\n                │    ├─insert_department.sql\n                │    └─select_department.sql\n                └─employee\n                     ├─insert_employee.sql\n                     └─select_employee.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n上のようなフォルダ構成の場合で、src/main/resources/をクラスパスに指定すれば、 その下のsqlフォルダをルートフォルダとした相対パスでSQLファイルを指定することができます。\n\nTIP\n\nSQLファイルのルートフォルダ（初期値：sql)は変更することができます。\n変更方法の詳細は SQLファイルルートフォルダの設定 を参照してください。\n\n# SQL名\nSQLファイルの指定する際のファイルパスをSQL名といいます。\n上記フォルダ構成の場合、それぞれのSQLファイルは以下のようなSQL名となります。\n\nSQLファイルパス（SQLルートフォルダから）            SQL名                           \ndepartment/insert_department.sql   department/insert_department   \ndepartment/select_department.sql   department/select_department   \nemployee/insert_employee.sql       employee/insert_employee       \nemployee/select_employee.sql       employee/select_employee       \n\nSQLファイルの配置は設定によりカスタマイズが可能です。SQLファイル配置のカスタマイズについては SQLファイルの解決ルール を参照してください。\n\n# 共通API\n検索(SqlQuery)、更新(SqlUpdate)、バッチ更新(SqlBatch)、ストアドプロシージャ実行(Procedure)を行うクラスは、バインドパラメータや置換文字列の設定を行うためのAPI(SqlFluent)を実装しています。\n\nバインドパラメータや置換文字列の設定はこのAPIを利用して設定を行ってください。\n流れるAPI(Fluent API)を採用しているため、値の設定は連続して行うことができるようになっています。\n\nパラメータ設定例\n\nMap<String, Object> department = agent.query("department/select_department")\n  .param("dept_no", 1)\n  .param("dept_name", "sales")\n  .first();\n\n\n1\n2\n3\n4\n主なメソッド                                                  説明                                                                    \n<V> SqlFluent#param(String key, V value)                バインドパラメータや置換文字列として使用するキーと値のセットを設定する                                   \n<V> SqlFluent#param(String key, Supplier<V> supplier)   supplierの評価結果をキーの値としてパラメータに設定する                                       \n<V> SqlFluent#paramList(String key, V... value)         IN句のバインドパラメータに使用するキーと値のセットを設定する。                                      \n                                                        から非推奨。かわりにparam()にArrays.asList()もしくはList.of()を使ってList型に詰めて設定してください   \nSqlFluent#paramMap(Map<String, ?> paramMap)             引数のMapのKey/Valueのセットをパラメータに設定する                                       \n<V> SqlFluent#paramBean(V bean)                         引数として渡されたbeanのフィールド名と値のセットをパラメータに設定する                                 \n\n他にもパラメータの型に応じたパラメータ設定メソッドが提供されています。',contentLowercase:'# 事前準備\nuroborosqlを利用した基本的なdb操作を説明します。\n\n# db接続\nまず最初にsqlを実行するdbへの接続を行います。\ndbに接続するためにはsqlconfigインタフェースのインスタンスを生成する必要があります。\n\nsqlconfigインスタンスはuroborosqlクラスのビルダーメソッドを使用して生成します。\n\n// jdbc接続を行うsqlconfigの生成\n// sqlconfig config = uroborosql.builder(url, user, password).build();\nsqlconfig config = uroborosql.builder("jdbc:h2:mem:uroborosql", "sa", "").build();\n\n// datasourceを使用したdb接続を行うsqlconfigの生成\n// sqlconfig config = uroborosql.builder(datasource).build();\ncontext context = new initialcontext();\ndatasource datasource = context.lookup("java:comp/env/jdbc/datasource");\nsqlconfig config = uroborosql.builder(datasource).build();\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nuroborosqlクラスを使ってsqlconfigインスタンスを生成する際、uroborosqlの挙動を変更する各種の設定も合わせて行うことができます。\n設定の詳細については設定を参照してください。\n\nwarning\n\nsqlconfigインスタンスはアプリケーション内で接続先毎に１つ保持するようにしてください。 sql実行の都度生成すると、不要なインスタンスの生成やsqlロード処理が実行されます。\n\n# sqlagentインスタンスの取得\n次にすべての操作の基点となるsqlagentインタフェースのインスタンスを取得します。\n\ntry (sqlagent agent = config.agent()) {\n  // この中でsqlの操作を行う\n}\n\n\n1\n2\n3\nsqlの操作はすべてこのsqlagentインスタンスを使って行うことになります。\n\ntip\n\nsqlagentインタフェースはjava.lang.autoclosableインタフェースを実装しており、try-with-resourcesで記述することで終了時に自動的にclose処理が呼び出され、中で保持しているconnectionやpreparedstatementなどのリソースオブジェクトも正しくクローズされます。\n\n# sqlファイルの配置\nuroborosqlではsql文の書かれたファイルのパスを指定してsqlを実行することができます。\nその際、sqlファイルはクラスパスから参照できる場所に配置されている必要があります。\n\nsrc\n    └─main\n        └─resources\n            └─sql\n                ├─department\n                │    ├─insert_department.sql\n                │    └─select_department.sql\n                └─employee\n                     ├─insert_employee.sql\n                     └─select_employee.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n上のようなフォルダ構成の場合で、src/main/resources/をクラスパスに指定すれば、 その下のsqlフォルダをルートフォルダとした相対パスでsqlファイルを指定することができます。\n\ntip\n\nsqlファイルのルートフォルダ（初期値：sql)は変更することができます。\n変更方法の詳細は sqlファイルルートフォルダの設定 を参照してください。\n\n# sql名\nsqlファイルの指定する際のファイルパスをsql名といいます。\n上記フォルダ構成の場合、それぞれのsqlファイルは以下のようなsql名となります。\n\nsqlファイルパス（sqlルートフォルダから）            sql名                           \ndepartment/insert_department.sql   department/insert_department   \ndepartment/select_department.sql   department/select_department   \nemployee/insert_employee.sql       employee/insert_employee       \nemployee/select_employee.sql       employee/select_employee       \n\nsqlファイルの配置は設定によりカスタマイズが可能です。sqlファイル配置のカスタマイズについては sqlファイルの解決ルール を参照してください。\n\n# 共通api\n検索(sqlquery)、更新(sqlupdate)、バッチ更新(sqlbatch)、ストアドプロシージャ実行(procedure)を行うクラスは、バインドパラメータや置換文字列の設定を行うためのapi(sqlfluent)を実装しています。\n\nバインドパラメータや置換文字列の設定はこのapiを利用して設定を行ってください。\n流れるapi(fluent api)を採用しているため、値の設定は連続して行うことができるようになっています。\n\nパラメータ設定例\n\nmap<string, object> department = agent.query("department/select_department")\n  .param("dept_no", 1)\n  .param("dept_name", "sales")\n  .first();\n\n\n1\n2\n3\n4\n主なメソッド                                                  説明                                                                    \n<v> sqlfluent#param(string key, v value)                バインドパラメータや置換文字列として使用するキーと値のセットを設定する                                   \n<v> sqlfluent#param(string key, supplier<v> supplier)   supplierの評価結果をキーの値としてパラメータに設定する                                       \n<v> sqlfluent#paramlist(string key, v... value)         in句のバインドパラメータに使用するキーと値のセットを設定する。                                      \n                                                        から非推奨。かわりにparam()にarrays.aslist()もしくはlist.of()を使ってlist型に詰めて設定してください   \nsqlfluent#parammap(map<string, ?> parammap)             引数のmapのkey/valueのセットをパラメータに設定する                                       \n<v> sqlfluent#parambean(v bean)                         引数として渡されたbeanのフィールド名と値のセットをパラメータに設定する                                 \n\n他にもパラメータの型に応じたパラメータ設定メソッドが提供されています。',charsets:{cjk:!0}},{title:"式言語",frontmatter:{meta:[{name:"og:title",content:"式言語"},{name:"og:url",content:"/uroborosql-doc/background/el.html"}]},regularPath:"/background/el.html",relativePath:"background/el.md",key:"v-00442cab",path:"/background/el.html",headers:[{level:2,title:"OGNL",slug:"ognl",charIndex:66},{level:3,title:"リテラル(OGNL)",slug:"リテラル-ognl",charIndex:299},{level:3,title:"演算子(OGNL)",slug:"演算子-ognl",charIndex:511},{level:3,title:"算術演算子(OGNL)",slug:"算術演算子-ognl",charIndex:539},{level:3,title:"比較演算子(OGNL)",slug:"比較演算子-ognl",charIndex:638},{level:3,title:"論理演算子(OGNL)",slug:"論理演算子-ognl",charIndex:1017},{level:3,title:"連結演算子(OGNL)",slug:"連結演算子-ognl",charIndex:1110},{level:3,title:"メソッド・フィールドの呼び出し(OGNL)",slug:"メソッド・フィールドの呼び出し-ognl",charIndex:1144},{level:2,title:"Spring Expression Language(SpEL)",slug:"spring-expression-language-spel",charIndex:74},{level:3,title:"リテラル(SpEL)",slug:"リテラル-spel",charIndex:1376},{level:3,title:"演算子(SpEL)",slug:"演算子-spel",charIndex:1485},{level:3,title:"算術演算子(SpEL)",slug:"算術演算子-spel",charIndex:1513},{level:3,title:"比較演算子(SpEL)",slug:"比較演算子-spel",charIndex:1634},{level:3,title:"論理演算子(SpEL)",slug:"論理演算子-spel",charIndex:2010},{level:3,title:"連結演算子(SpEL)",slug:"連結演算子-spel",charIndex:2083},{level:3,title:"その他の演算子(SpEL)",slug:"その他の演算子-spel",charIndex:2117},{level:3,title:"メソッド・フィールドの呼び出し(SpEL)",slug:"メソッド・フィールドの呼び出し-spel",charIndex:2285},{level:2,title:"StringFunction(SF)",slug:"stringfunction-sf",charIndex:2444}],lastUpdated:"2020-3-8 21:44:34",headersStr:"OGNL リテラル(OGNL) 演算子(OGNL) 算術演算子(OGNL) 比較演算子(OGNL) 論理演算子(OGNL) 連結演算子(OGNL) メソッド・フィールドの呼び出し(OGNL) Spring Expression Language(SpEL) リテラル(SpEL) 演算子(SpEL) 算術演算子(SpEL) 比較演算子(SpEL) 論理演算子(SpEL) 連結演算子(SpEL) その他の演算子(SpEL) メソッド・フィールドの呼び出し(SpEL) StringFunction(SF)",content:"# 式言語\nuroboroSQLでは、条件分岐に式言語を利用することができます。\n利用可能な式言語は以下の２つになります。\n\n * OGNL\n * Spring Expression Language(SpEL) \n\n利用する式言語の切替は依存関係ライブラリの指定により行ってください。\n依存関係ライブラリの指定については環境設定を参照してください。\n\n条件分岐の評価式として使用する場合、評価結果が真偽値(true/false)になるように記述してください。\n\n# OGNL\n以下に式言語としてOGNLを利用する場合の基本文法を提示します。\nOGNL文法の詳細はこちらを参照してください。\n\n# リテラル(OGNL)\n以下のリテラルが使用できます。\n\n * “a”(java.lang.String)\n * 'a'(char)\n * 1(int)\n * 1L(long)\n * 0.1F(float)\n * 0.1D(double)\n * 0.1B(java.math.BigDecimal)\n * 1H(java.math.BigInteger)\n * true, false(Boolean)\n * null\n\n# 演算子(OGNL)\n以下の演算子が使用できます。\n\n# 算術演算子(OGNL)\n * e1 + e2 (足し算)\n * e1 - e2 (引き算)\n * e1 * e2 (掛け算)\n * e1 / e2 (割り算)\n * e1 % e2 (余り)\n\n# 比較演算子(OGNL)\n * e1 eq e2, e1 == e2 (等しい) * e1・e2のいずれかがnullの場合、両方ともnullの時のみe1とe2は等しい\n    * e1・e2が同じオブジェクトの場合、またはequals()メソッドにより等しいと判断される場合、e1とe2は等しい\n    * e1・e2が数値の場合、倍精度浮動小数点数が等しい時のみe1とe2は等しい\n    * その以外の場合、e1とe2は等しくない\n   \n   \n * e1 neq e2, e1 != e2 (等しくない)\n * e1 lt e2, e1 < e2 (小なり)\n * e1 lte e2, e1 <= e2 (小なりイコール)\n * e1 gt e2, e1 > e2 (大なり)\n * e1 gte e2, e1 >= e2 (大なりイコール)\n\n# 論理演算子(OGNL)\n * e1 or e2, e1 || e2 (論理和)\n * e1 and e2, e1 && e2 (論理積)\n * not e, ! e (論理否定)\n\n# 連結演算子(OGNL)\n * e1 + e2 (文字列連結)\n\n# メソッド・フィールドの呼び出し(OGNL)\n以下のようにメソッド・フィールドの呼び出しができます。\n\n * e.method(args) (メソッドの呼び出し)\n * e.property (フィールドの呼び出し)\n\n# Spring Expression Language(SpEL)\n以下に式言語としてSpring Expression Language(SpEL)を利用する場合の基本文法を提示します。\nSpEL文法の詳細はこちらを参照してください。\n\n# リテラル(SpEL)\n以下のリテラルが使用できます。\n\n * 文字列はシングルクォートで囲む。シングルクォート自体を使用する場合はシングルクォートを２つ重ねる('')\n * 数字や真偽値、nullはそのまま記述\n\n# 演算子(SpEL)\n以下の演算子が使用できます。\n\n# 算術演算子(SpEL)\n * e1 + e2 (足し算)\n * e1 - e2 (引き算)\n * e1 * e2 (掛け算)\n * e1 / e2, e1 div e2 (割り算)\n * e1 % e2, e1 mod e2 (余り)\n\n# 比較演算子(SpEL)\n * e1 eq e2, e1 == e2 (等しい) * e1・e2のいずれかがnullの場合、両方ともnullの時のみe1とe2は等しい\n    * e1・e2が同じオブジェクトの場合、またはequals()メソッドにより等しいと判断される場合、e1とe2は等しい\n    * e1・e2が数値の場合、倍精度浮動小数点数が等しい時のみe1とe2は等しい\n    * その以外の場合、e1とe2は等しくない\n   \n   \n * e1 ne e2, e1 != e2 (等しくない)\n * e1 lt e2, e1 < e2 (小なり)\n * e1 le e2, e1 <= e2 (小なりイコール)\n * e1 gt e2, e1 > e2 (大なり)\n * e1 ge e2, e1 >= e2 (大なりイコール)\n\n# 論理演算子(SpEL)\n * e1 or e2 (論理和)\n * e1 and e2 (論理積)\n * not e, ! e (論理否定)\n\n# 連結演算子(SpEL)\n * e1 + e2 (文字列連結)\n\n# その他の演算子(SpEL)\n * instanceof (型判定) * ex) 'xyz' instanceof T(int) // false T() はタイプ（型）を表す\n   \n   \n * matches (正規表現) * ex) '5.00' matches '^[0-9]{2}$' // false\n   \n   \n\n# メソッド・フィールドの呼び出し(SpEL)\n以下のようにメソッド・フィールドの呼び出しができます。\n\n * e.method(args) (メソッドの呼び出し)\n * e.property (フィールドの呼び出し)\n * T(type).staticMethod(args) (staticメソッドの呼び出し)\n\n# StringFunction(SF)\nuroboroSQLでは評価式を利用する際、標準でStringFunction（SF）を使用することができます。 評価式と合わせてStringFunctionクラスのメソッドを呼び出すことができます。\n\n * 評価式で使用する場合\n\n/*IF SF.isNotEmpty(emp_no)*/\n  -- emp_noが null または \"\" でない場合に処理される\n/*END*/\n\n\n1\n2\n3\n * バインドパラメータと合わせて使用する場合\n\nemp_name like /*SF.contains(emp_name)*/'' escape '$'\n-- emp_name=Bobの場合、 emp_name like %Bob% escape '$' となる\n\n\n1\n2\n * StringFunctionが提供するメソッドの一覧\n\nメソッド名                                                  戻り値        説明                                                   \nSF.isEmpty(String str)                                 booean     対象文字列が空文字であること判定する                                   \nSF.isNotEmpty(String str)                              boolean    対象文字列が空文字でないことを判定する                                  \nSF.isBlank(String str)                                 boolean    対象文字列が空文字、もしくは空白であること判定する                            \nSF.isNotBlank(String str)                              boolean    対象文字列が空文字、もしくは空白でないこと判定する                            \nSF.trim(String str)                                    String     文字列の前後の空白を除去する。nullを渡した場合は結果もnullとなる                 \nSF.trimToEmpty(String str)                             String     文字列の前後の空白を除去する。nullを渡した場合は空文字となる                     \nSF.left(String str, int len)                           String     文字列の先頭から指定した文字数の文字列を取得する                             \nSF.right(String str, int len)                          String     文字列の最後から指定した文字数の文字列を取得する                             \nSF.mid(String str, int pos, int len)                   String     文字列の指定した位置から指定した文字数の文字列を取得する                         \nSF.rightPad(String str, int size)                      String     文字列の末尾に空白を埋めて指定された長さにする                              \nSF.rightPad(String str, int size, char padChar)        String     文字列の末尾に指定した埋め込み文字を埋めて指定された長さにする                      \nSF.leftPad(String str, int size)                       String     文字列の先頭に空白を埋めて指定された長さにする                              \nSF.leftPad(String str, int size, char padChar)         String     文字列の先頭に指定した埋め込み文字を埋めて指定された長さにする                      \nSF.split(String str)                                   String[]   文字列を空白で区切って配列に格納する。nullが入力された場合はnullを返す              \nSF.split(String str, char separatorChar)               String[]   文字列を指定した区切り文字で区切って配列に格納する。nullが入力された場合はnullを返す       \nSF.split(String str, String separatorChars, int max)   String[]   文字列を指定した区切り文字で区切って配列に格納する。nullが入力された場合はnullを返す       \nSF.capitalize(String str)                              String     文字列の先頭文字を大文字にする                                      \nSF.uncapitalize(String str)                            String     文字列の先頭を小文字にする                                        \nSF.startsWith(CharSequence text)                       String     指定されたテキストで始まるLIKE句用の検索文字列を生成する。引数のテキストはエスケープ処理される    \nSF.contains(CharSequence text)                         String     指定されたテキストを含むLIKE句用の検索文字列を生成する。引数のテキストはエスケープ処理される     \nSF.endsWith(CharSequence text)                         String     指定されたテキストで終わるLIKE句用の検索文字列を生成する。数のテキストはエスケープ処理される",contentLowercase:"# 式言語\nuroborosqlでは、条件分岐に式言語を利用することができます。\n利用可能な式言語は以下の２つになります。\n\n * ognl\n * spring expression language(spel) \n\n利用する式言語の切替は依存関係ライブラリの指定により行ってください。\n依存関係ライブラリの指定については環境設定を参照してください。\n\n条件分岐の評価式として使用する場合、評価結果が真偽値(true/false)になるように記述してください。\n\n# ognl\n以下に式言語としてognlを利用する場合の基本文法を提示します。\nognl文法の詳細はこちらを参照してください。\n\n# リテラル(ognl)\n以下のリテラルが使用できます。\n\n * “a”(java.lang.string)\n * 'a'(char)\n * 1(int)\n * 1l(long)\n * 0.1f(float)\n * 0.1d(double)\n * 0.1b(java.math.bigdecimal)\n * 1h(java.math.biginteger)\n * true, false(boolean)\n * null\n\n# 演算子(ognl)\n以下の演算子が使用できます。\n\n# 算術演算子(ognl)\n * e1 + e2 (足し算)\n * e1 - e2 (引き算)\n * e1 * e2 (掛け算)\n * e1 / e2 (割り算)\n * e1 % e2 (余り)\n\n# 比較演算子(ognl)\n * e1 eq e2, e1 == e2 (等しい) * e1・e2のいずれかがnullの場合、両方ともnullの時のみe1とe2は等しい\n    * e1・e2が同じオブジェクトの場合、またはequals()メソッドにより等しいと判断される場合、e1とe2は等しい\n    * e1・e2が数値の場合、倍精度浮動小数点数が等しい時のみe1とe2は等しい\n    * その以外の場合、e1とe2は等しくない\n   \n   \n * e1 neq e2, e1 != e2 (等しくない)\n * e1 lt e2, e1 < e2 (小なり)\n * e1 lte e2, e1 <= e2 (小なりイコール)\n * e1 gt e2, e1 > e2 (大なり)\n * e1 gte e2, e1 >= e2 (大なりイコール)\n\n# 論理演算子(ognl)\n * e1 or e2, e1 || e2 (論理和)\n * e1 and e2, e1 && e2 (論理積)\n * not e, ! e (論理否定)\n\n# 連結演算子(ognl)\n * e1 + e2 (文字列連結)\n\n# メソッド・フィールドの呼び出し(ognl)\n以下のようにメソッド・フィールドの呼び出しができます。\n\n * e.method(args) (メソッドの呼び出し)\n * e.property (フィールドの呼び出し)\n\n# spring expression language(spel)\n以下に式言語としてspring expression language(spel)を利用する場合の基本文法を提示します。\nspel文法の詳細はこちらを参照してください。\n\n# リテラル(spel)\n以下のリテラルが使用できます。\n\n * 文字列はシングルクォートで囲む。シングルクォート自体を使用する場合はシングルクォートを２つ重ねる('')\n * 数字や真偽値、nullはそのまま記述\n\n# 演算子(spel)\n以下の演算子が使用できます。\n\n# 算術演算子(spel)\n * e1 + e2 (足し算)\n * e1 - e2 (引き算)\n * e1 * e2 (掛け算)\n * e1 / e2, e1 div e2 (割り算)\n * e1 % e2, e1 mod e2 (余り)\n\n# 比較演算子(spel)\n * e1 eq e2, e1 == e2 (等しい) * e1・e2のいずれかがnullの場合、両方ともnullの時のみe1とe2は等しい\n    * e1・e2が同じオブジェクトの場合、またはequals()メソッドにより等しいと判断される場合、e1とe2は等しい\n    * e1・e2が数値の場合、倍精度浮動小数点数が等しい時のみe1とe2は等しい\n    * その以外の場合、e1とe2は等しくない\n   \n   \n * e1 ne e2, e1 != e2 (等しくない)\n * e1 lt e2, e1 < e2 (小なり)\n * e1 le e2, e1 <= e2 (小なりイコール)\n * e1 gt e2, e1 > e2 (大なり)\n * e1 ge e2, e1 >= e2 (大なりイコール)\n\n# 論理演算子(spel)\n * e1 or e2 (論理和)\n * e1 and e2 (論理積)\n * not e, ! e (論理否定)\n\n# 連結演算子(spel)\n * e1 + e2 (文字列連結)\n\n# その他の演算子(spel)\n * instanceof (型判定) * ex) 'xyz' instanceof t(int) // false t() はタイプ（型）を表す\n   \n   \n * matches (正規表現) * ex) '5.00' matches '^[0-9]{2}$' // false\n   \n   \n\n# メソッド・フィールドの呼び出し(spel)\n以下のようにメソッド・フィールドの呼び出しができます。\n\n * e.method(args) (メソッドの呼び出し)\n * e.property (フィールドの呼び出し)\n * t(type).staticmethod(args) (staticメソッドの呼び出し)\n\n# stringfunction(sf)\nuroborosqlでは評価式を利用する際、標準でstringfunction（sf）を使用することができます。 評価式と合わせてstringfunctionクラスのメソッドを呼び出すことができます。\n\n * 評価式で使用する場合\n\n/*if sf.isnotempty(emp_no)*/\n  -- emp_noが null または \"\" でない場合に処理される\n/*end*/\n\n\n1\n2\n3\n * バインドパラメータと合わせて使用する場合\n\nemp_name like /*sf.contains(emp_name)*/'' escape '$'\n-- emp_name=bobの場合、 emp_name like %bob% escape '$' となる\n\n\n1\n2\n * stringfunctionが提供するメソッドの一覧\n\nメソッド名                                                  戻り値        説明                                                   \nsf.isempty(string str)                                 booean     対象文字列が空文字であること判定する                                   \nsf.isnotempty(string str)                              boolean    対象文字列が空文字でないことを判定する                                  \nsf.isblank(string str)                                 boolean    対象文字列が空文字、もしくは空白であること判定する                            \nsf.isnotblank(string str)                              boolean    対象文字列が空文字、もしくは空白でないこと判定する                            \nsf.trim(string str)                                    string     文字列の前後の空白を除去する。nullを渡した場合は結果もnullとなる                 \nsf.trimtoempty(string str)                             string     文字列の前後の空白を除去する。nullを渡した場合は空文字となる                     \nsf.left(string str, int len)                           string     文字列の先頭から指定した文字数の文字列を取得する                             \nsf.right(string str, int len)                          string     文字列の最後から指定した文字数の文字列を取得する                             \nsf.mid(string str, int pos, int len)                   string     文字列の指定した位置から指定した文字数の文字列を取得する                         \nsf.rightpad(string str, int size)                      string     文字列の末尾に空白を埋めて指定された長さにする                              \nsf.rightpad(string str, int size, char padchar)        string     文字列の末尾に指定した埋め込み文字を埋めて指定された長さにする                      \nsf.leftpad(string str, int size)                       string     文字列の先頭に空白を埋めて指定された長さにする                              \nsf.leftpad(string str, int size, char padchar)         string     文字列の先頭に指定した埋め込み文字を埋めて指定された長さにする                      \nsf.split(string str)                                   string[]   文字列を空白で区切って配列に格納する。nullが入力された場合はnullを返す              \nsf.split(string str, char separatorchar)               string[]   文字列を指定した区切り文字で区切って配列に格納する。nullが入力された場合はnullを返す       \nsf.split(string str, string separatorchars, int max)   string[]   文字列を指定した区切り文字で区切って配列に格納する。nullが入力された場合はnullを返す       \nsf.capitalize(string str)                              string     文字列の先頭文字を大文字にする                                      \nsf.uncapitalize(string str)                            string     文字列の先頭を小文字にする                                        \nsf.startswith(charsequence text)                       string     指定されたテキストで始まるlike句用の検索文字列を生成する。引数のテキストはエスケープ処理される    \nsf.contains(charsequence text)                         string     指定されたテキストを含むlike句用の検索文字列を生成する。引数のテキストはエスケープ処理される     \nsf.endswith(charsequence text)                         string     指定されたテキストで終わるlike句用の検索文字列を生成する。数のテキストはエスケープ処理される",charsets:{cjk:!0}},{title:"DAOインタフェース",frontmatter:{meta:[{name:"og:title",content:"DAOインタフェース"},{name:"og:url",content:"/uroborosql-doc/basics/entity-api.html"}]},regularPath:"/basics/entity-api.html",relativePath:"basics/entity-api.md",key:"v-df81072a",path:"/basics/entity-api.html",headers:[{level:2,title:"エンティティクラスの検索",slug:"エンティティクラスの検索",charIndex:986},{level:3,title:"キーを指定した１件取得(SqlAgent#find)",slug:"キーを指定した1件取得-sqlagent-find",charIndex:1001},{level:3,title:"条件指定検索(SqlAgent#query)",slug:"条件指定検索-sqlagent-query",charIndex:1289},{level:3,title:"抽出条件の指定(SqlEntityQuery#equal /#notEqual /#greaterThan /#lessThan /#greaterEqual /#lessEqual /#in /#notIn /#like /#startsWith /#endsWith /#contains /#notLike /#notStartsWith /#notEndsWith /#notContains /#between /#isNull /#isNotNull /#where)",slug:"抽出条件の指定-sqlentityquery-equal-notequal-greaterthan-lessthan-greaterequal-lessequal-in-notin-like-startswith-endswith-contains-notlike-notstartswith-notendswith-notcontains-between-isnull-isnotnull-where",charIndex:1520},{level:3,title:"ソート順(SqlEntityQuery#asc /#desc)や取得データの件数(#limit)、開始位置(#offset)、悲観ロック(#forUpdate /#forUpdateNoWait /#forUpdateWait)の指定",slug:"ソート順-sqlentityquery-asc-desc-や取得データの件数-limit-、開始位置-offset-、悲観ロック-forupdate-forupdatenowait-forupdatewait-の指定",charIndex:6260},{level:3,title:"オプティマイザーヒントの指定(SqlEntityQuery#hint)",slug:"オプティマイザーヒントの指定-sqlentityquery-hint",charIndex:8258},{level:3,title:"検索結果の取得(SqlEntityQury#collect /#first /#one /#select /#stream)",slug:"検索結果の取得-sqlentityqury-collect-first-one-select-stream",charIndex:8636},{level:3,title:"集約関数(SqlEntityQuery#count /#sum /#sum /#min /#max /#exists /#notExists)",slug:"集約関数-sqlentityquery-count-sum-sum-min-max-exists-notexists",charIndex:9722},{level:2,title:"エンティティの挿入",slug:"エンティティの挿入",charIndex:10925},{level:3,title:"1件の挿入(SqlAgent#insert/#insertAndReturn)",slug:"_1件の挿入-sqlagent-insert-insertandreturn",charIndex:10937},{level:3,title:"複数件の挿入(SqlAgent#inserts /#insertsAndReturn)",slug:"複数件の挿入-sqlagent-inserts-insertsandreturn",charIndex:11752},{level:3,title:"挿入方法（InsertsType）の指定",slug:"挿入方法-insertstype-の指定",charIndex:14747},{level:3,title:"挿入条件（InsertsCondition）の指定",slug:"挿入条件-insertscondition-の指定",charIndex:15418},{level:2,title:"エンティティの更新",slug:"エンティティの更新",charIndex:15823},{level:3,title:"1件の更新(SqlAgent#update /#updateAndReturn)",slug:"_1件の更新-sqlagent-update-updateandreturn",charIndex:15835},{level:3,title:"条件指定による複数件の更新(SqlAgent#update)",slug:"条件指定による複数件の更新-sqlagent-update",charIndex:16615},{level:3,title:"複数件の更新(SqlAgent#updates /#updatesAndReturn)",slug:"複数件の更新-sqlagent-updates-updatesandreturn",charIndex:17023},{level:3,title:"更新条件（UpdatesCondition）の指定",slug:"更新条件-updatescondition-の指定",charIndex:18528},{level:2,title:"エンティティの削除",slug:"エンティティの削除",charIndex:18974},{level:3,title:"1件の削除(SqlAgent#delete /#deleteAndReturn)",slug:"_1件の削除-sqlagent-delete-deleteandreturn",charIndex:18986},{level:3,title:"PKを指定した複数件の削除(SqlAgent#delete)",slug:"pkを指定した複数件の削除-sqlagent-delete",charIndex:19386},{level:3,title:"条件指定による複数件の削除(SqlAgent#delete)",slug:"条件指定による複数件の削除-sqlagent-delete",charIndex:19613},{level:3,title:"全ての行を削除（SqlAgent#truncate）",slug:"全ての行を削除-sqlagent-truncate",charIndex:19939},{level:2,title:"Entityアノテーション",slug:"entityアノテーション",charIndex:20495},{level:3,title:"@Table",slug:"table",charIndex:20585},{level:3,title:"@Column",slug:"column",charIndex:21158},{level:3,title:"@Domain",slug:"domain",charIndex:21605},{level:3,title:"@Transient",slug:"transient",charIndex:22773},{level:3,title:"@Version",slug:"version",charIndex:16053},{level:3,title:"@Id /@GeneratedValue /@SequenceGenerator",slug:"id-generatedvalue-sequencegenerator",charIndex:25121}],lastUpdated:"2020-3-8 21:44:34",headersStr:"エンティティクラスの検索 キーを指定した１件取得(SqlAgent#find) 条件指定検索(SqlAgent#query) 抽出条件の指定(SqlEntityQuery#equal /#notEqual /#greaterThan /#lessThan /#greaterEqual /#lessEqual /#in /#notIn /#like /#startsWith /#endsWith /#contains /#notLike /#notStartsWith /#notEndsWith /#notContains /#between /#isNull /#isNotNull /#where) ソート順(SqlEntityQuery#asc /#desc)や取得データの件数(#limit)、開始位置(#offset)、悲観ロック(#forUpdate /#forUpdateNoWait /#forUpdateWait)の指定 オプティマイザーヒントの指定(SqlEntityQuery#hint) 検索結果の取得(SqlEntityQury#collect /#first /#one /#select /#stream) 集約関数(SqlEntityQuery#count /#sum /#sum /#min /#max /#exists /#notExists) エンティティの挿入 1件の挿入(SqlAgent#insert/#insertAndReturn) 複数件の挿入(SqlAgent#inserts /#insertsAndReturn) 挿入方法（InsertsType）の指定 挿入条件（InsertsCondition）の指定 エンティティの更新 1件の更新(SqlAgent#update /#updateAndReturn) 条件指定による複数件の更新(SqlAgent#update) 複数件の更新(SqlAgent#updates /#updatesAndReturn) 更新条件（UpdatesCondition）の指定 エンティティの削除 1件の削除(SqlAgent#delete /#deleteAndReturn) PKを指定した複数件の削除(SqlAgent#delete) 条件指定による複数件の削除(SqlAgent#delete) 全ての行を削除（SqlAgent#truncate） Entityアノテーション @Table @Column @Domain @Transient @Version @Id /@GeneratedValue /@SequenceGenerator",content:'# DAOインタフェース\nuroboroSQLはDAO(Data Access Object)を用いた単一テーブルへのCRUDに対応しています。\n\n下記のテーブルとそれに対応するエンティティクラスを例として説明します。\n\n-- MySQLの場合\ncreate table employee (\n  emp_no number(6) not null auto_increment\n  , first_name varchar(20) not null\n  , last_name varchar(20) not null\n  , birth_date date not null\n  , gender char(1) not null\n  , lock_version number(10) not null\n  , constraint employee_PKC primary key (emp_no)\n)\n\n-- Postgresqlの場合\ncreate table employee (\n  emp_no serial not null\n  , first_name varchar(20) not null\n  , last_name varchar(20) not null\n  , birth_date date not null\n  , gender char(1) not null\n  , lock_version number(10) not null\n  , constraint employee_PKC primary key (emp_no)\n) ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\npublic class Employee {\n  private long empNo;\n  private String firstName;\n  private String lastName;\n  private LocalDate birthDate;\n  private Gender gender;\n  private long lockVersion = 0;\n\n  // 中略 getter/setter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# エンティティクラスの検索\n# キーを指定した１件取得(SqlAgent#find)\nメソッド名                                戻り値の型         \nSqlAgent#find(Class<E>, Object...)   Optional<E>   \n\n主キーを指定してエンティティを取得します。PKカラムの数と引数に指定するキーの数は合わせる必要があります。\n\n// emp_no = 1 のレコードをエンティティとして取得\nOptional<Employee> employee = agent.find(Employee.class, 1);\n\n\n1\n2\n# 条件指定検索(SqlAgent#query) \nメソッド名                      戻り値の型               \nSqlAgent#query(Class<E>)   SqlEntityQuery<E>   \n\nエンティティクラスを利用した検索を行うためのオブジェクト（SqlEntityQuery)を取得します。\nSqlEntityQueryに対して抽出条件の指定を行い、抽出条件に該当するエンティティを取得します。\n\n\n\n\n# 抽出条件の指定(SqlEntityQuery#equal /#notEqual /#greaterThan /#lessThan /#greaterEqual /#lessEqual /#in /#notIn /#like /#startsWith /#endsWith /#contains /#notLike /#notStartsWith /#notEndsWith /#notContains /#between /#isNull /#isNotNull /#where)\n抽出条件指定メソッド記述例                                                             生成されるwhere句の条件式                        補足説明                                  \nequal("col", "value")                                                     col = \'value\'                                                                \nnotEqual("col", "value")                                                  col != \'value\'                                                               \ngreaterThan("col", 1)                                                     col > 1                                                                      \nlessThan("col", 1)                                                        col < 1                                                                      \ngreaterEqual("col", 1)                                                    col >= 1                                                                     \nlessEqual("col", 1)                                                       col <= 1                                                                     \nin("col", "val1", "val2")                                                 col in (\'val1\', \'val2\')                                                      \nin("col", List.of("val1", "val2"))                                        col in (\'val1\', \'val2\')                                                      \nnotIn("col", "val1", "val2")                                              col not in (\'val1\', \'val2\')                                                  \nnotIn("col", List.of("val1", "val2"))                                     col not in (\'val1\', \'val2\')                                                  \nlike("col", "%val%")                                                      like \'%val%\'                           valはエスケープされない                         \nstartsWith("col", "val")                                                  like \'val%\'                            valはエスケープされる                          \nendsWith("col", "val")                                                    like \'%val\'                            valはエスケープされる                          \ncontains("col", "val")                                                    like \'%val%\'                           valはエスケープされる                          \nnotLike("col", "%val%")                                                   not like \'%val%\'                       valはエスケープされない                         \nnotStartsWith("col", "val")                                               not like \'val%\'                        valはエスケープされる                          \nnotEndsWith("col", "val")                                                 not like \'%val\'                        valはエスケープされる                          \nnotContains("col", "val")                                                 not like \'%val%\'                       valはエスケープされる                          \nbetween("col", 1, 2)                                                      col between 1 and 2                                                          \nisNull("col")                                                             col is null                                                                  \nisNotNull("col")                                                          col is not null                                                              \nwhere("col = 1 or col = 2")                                               (col = 1 or col = 2)                   もし複数回where()が呼び出された場合は条件を AND で結合する   \nwhere("col = /*col1*/", "col1", 1)                                        (col = 1/*col1*/)                      パラメータの指定（1件）付き                        \nwhere("col = /*col1*/ or col = /*col2*/", Map.of("col1", 1, "col2", 2))   (col = 1/*col1*/ or col = 2/*col2*/)   パラメータの指定（複数件）付き                       \n\n// emp_no = 1 のレコードをList<Employee>で取得\nagent.query(Employee.class).equal("emp_no", 1).collect();\n\n// emp_no = 10 又は 20 のレコードをList<Employee>で取得\nagent.query(Employee.class).in("emp_no", 10, 20).collect();\n\n// first_name like \'%Bob%\' のレコードをList<Employee>で取得\nagent.query(Employee.class).contains("first_name", "Bob").collect();\n\n// where句を直接記述(first_name = \'Bob\' and last_name = \'Smith\')した結果をList<Employee>で取得\nagent.query(Employee.class).where("first_name =\'\'/*firstName*/", "firstName", "Bob").where("last_name = \'\'/*lastName*/", "lastName", "Smith").collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n注意\n\nSqlEntityQueryに対して抽出条件を指定する場合paramメソッドは使用しないでください。SqlEntityQuery#param()には@Deprecatedが付与されており、将来削除される予定です。\n\n# ソート順(SqlEntityQuery#asc /#desc)や取得データの件数(#limit)、開始位置(#offset)、悲観ロック(#forUpdate /#forUpdateNoWait /#forUpdateWait)の指定 \nSqlEntityQueryでは抽出条件に加えて検索結果のソート順や取得件数の制限、開始位置の指定、明示的なロック指定が行えます。\n\n条件指定メソッド記述例                 生成されるSQL                         補足説明                                                                     \nasc("col1", "col2")         order by col1 asc, col2 asc      NULLSが有効な場合はNULLS LASTが出力される                                             \nasc("col1", Nulls.FIRST)    order by col1 asc NULLS FIRST    複数回asc()が呼び出された場合は呼び出し順に並べる                                              \ndesc("col1", "col2")        order by col1 desc, col2 desc    NULLSが有効な場合はNULLS LASTが出力される                                             \ndesc("col1", Nulls.FIRST)   order by col1 desc NULLS FIRST   複数回asc()が呼び出された場合は呼び出し順に並べる                                              \nlimit(10)                   LIMIT 10                         接続しているDBでlimit句が使用できない場合はUroborosqlRuntimeExceptionがスローされる               \noffset(10)                  OFFSET 10                        接続しているDBでoffset句が使用できない場合はUroborosqlRuntimeExceptionがスローされる              \nforUpdate()                 FOR UPDATE                       接続しているDBでFOR UPDATE句が使用できない場合はUroborosqlRuntimeExceptionがスローされる          \nforUpdateNoWait()           FOR UPDATE NOWAIT                接続しているDBでFOR UPDATE NOWAIT句が使用できない場合はUroborosqlRuntimeExceptionがスローされる   \nforUpdateWait()             FOR UPDATE WAIT 10               接続しているDBでFOR UPDATE WAIT句が使用できない場合はUroborosqlRuntimeExceptionがスローされる     \nforUpdateWait(30)           FOR UPDATE WAIT 30               接続しているDBでFOR UPDATE WAIT句が使用できない場合はUroborosqlRuntimeExceptionがスローされる     \n\n// birth_dateの降順、first_nameの昇順でソートした結果を List<Employee>で取得\nagent.query(Employee.class).desc("birth_date").asc("first_name").collect();\n\n// emp_no の昇順でソートした結果の3行目から5件取得\nagent.query(Employee.class).asc("emp_no").offset(3).limit(5).collect();\n\n// 明示的な行ロックを行う\nagent.query(Employee.class).forUpdate().collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# オプティマイザーヒントの指定(SqlEntityQuery#hint) \nSqlEntityQuery#hint()を使用することで、SQLに対してオプティマイザーヒントを指定することができます。\n\nSqlAgent agent = ...\nagent.query(User.class).hint("ORDERED").lessThan("age", 30).collect();\n\n\n1\n2\n出力されるSQL(Oracleの場合)\n\nselect /*+ ORDERED */ id, name, age, ... from user where age < 30\n\n\n1\n注意\n\nオプティマイザーヒントの指定は、利用するDBがオプティマイザーヒントをサポートしている場合に有効になります。\nまた、指定可能なヒント句は利用するDBに依存します。\n\n# 検索結果の取得(SqlEntityQury#collect /#first /#one /#select /#stream)\nSqlEntityQueryから抽出条件に該当するエンティティを取得します。\n\nメソッド                                           説明                                                       \ncollect()                                      検索結果をエンティティのリストとして取得する                                   \nfirst()                                        検索結果の先頭行を取得する                                            \none()                                          検索結果の先頭行を取得する。検索結果が2件以上の場合DataNonUniqueExceptionをスローする   \nStream<C> select(String col, Class<C> type)    検索結果の指定したカラムの値をjava.util.stream.Streamとして取得する。           \nstream()                                       検索結果をjava.util.stream.Streamとして取得する                      \n\n// List<Employee>で取得\nList<Enployee> employees = agent.query(Employee.class).collect();\n\n// 検索結果の先頭行を取得\nOptional<Enployee> employee = agent.query(Employee.class).first();\n\n// 検索結果（カラム値）の取得\nString employeeName = agent.query(Employee.class)\n    .equal("employeeId", 1)\n    .select("employeeName", String.class).findFirst().get();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 集約関数(SqlEntityQuery#count /#sum /#sum /#min /#max /#exists /#notExists) \nSqlEntityQueryではエンティティを取得する他に結果の集計を行うこともできます。\n\nメソッド                           説明                                    \ncount()                        検索結果の件数を取得する                          \ncount(String col)              検索結果のうち、引数で指定したカラムがNULLでない行の件数を取得する   \nsum(String col)                検索結果のうち、引数で指定したカラムの合計値を取得する           \nmin(String col)                検索結果のうち、引数で指定したカラムの最小値を取得する           \nmax(String col)                検索結果のうち、引数で指定したカラムの最大値を取得する           \nexists(Runnable runnable)      検索結果が1件以上ある場合に引数で渡した関数を実行する           \nnotExists(Runnable runnable)   検索結果が0件の場合に引数で渡した関数を実行する              \n\n// 検索結果の件数を取得\nlong count = agent.query(Employee.class).count();\n\n// 検索結果が1件以上の場合にログを出力する\nagent.query(Employee.class).greaterThan("emp_no", 10).exists(() -> {\n  log.info("Employee(emp_no > 10) exists.");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\nTIP\n\n集約関数を使用すると、検索結果からEntityオブジェクトを生成しないためメモリ効率が良くなります。 以下２つの処理結果は同じですが、メモリの使い方が違います。\n\n// collect()を使用すると、検索結果がエンティティに変換されるためメモリを使用する\nlong count = agent.query(Employee.class).collect().size();\n\n// count()を使用すると件数のみ取得できる（エンティティは生成されない）\nlong count = agent.query(Employee.class).count();\n\n\n1\n2\n3\n4\n5\n# エンティティの挿入\n# 1件の挿入(SqlAgent#insert/#insertAndReturn)\nメソッド名                              戻り値の型   \n<E> SqlAgent#insert(E)             int     \n<E> SqlAgent#insertAndReturn(E)    E       \n\nエンティティクラスのインスタンスを使って１レコードの挿入を行います。\n\n * @Idアノテーションの指定があるフィールド\n * 対するカラムが自動採番となっているフィールド\n\nの型がprimitive型の場合、もしくはフィールドの値がnullの場合、カラムの値は挿入時に自動採番されます。\nまた、挿入により採番された値がエンティティの該当フィールドにも設定されます。\nフィールドに値を指定した場合は自動採番カラムであっても指定した値が挿入されます。\n\nAndReturnが付くメソッドでは、挿入したエンティティオブジェクトを戻り値として取得できるため、 エンティティの挿入に続けて処理を行う場合に便利です。\n\nEmployee employee = new Employee();\nemployee.setFirstName("Susan");\nemployee.setLastName("Davis");\nemployee.setBirthDate(LocalDate.of(1969, 2, 10));\nemployee.setGender(Gender.FEMALE); // MALE("M"), FEMALE("F"), OTHER("O")\n\n// 1件の挿入\nagent.insert(employee);\nSystem.out.println(employee.getEmpNo()); // 自動採番された値が出力される\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 複数件の挿入(SqlAgent#inserts /#insertsAndReturn) \nメソッド名                                                                                       戻り値の型       \nSqlAgent#inserts(Stream<E>)                                                                 int         \nSqlAgent#inserts(Stream<E>, InsertsType)                                                    int         \nSqlAgent#inserts(Stream<E>, InsertsCondition<? super E>)                                    int         \nSqlAgent#inserts(Stream<E>, InsertsCondition<? super E>, InsertsType)                       int         \nSqlAgent#insertsAndReturn(Stream<E>)                                                        Stream<E>   \nSqlAgent#insertsAndReturn(Stream<E>, InsertsType)                                           Stream<E>   \nSqlAgent#insertsAndReturn(Stream<E>, InsertsCondition<? super E>)                           Stream<E>   \nSqlAgent#insertsAndReturn(Stream<E>, InsertsCondition<? super E>, InsertsType)              Stream<E>   \nSqlAgent#inserts(Class<E>, Stream<E>)                                                       int         \nSqlAgent#inserts(Class<E>, Stream<E>, InsertsType)                                          int         \nSqlAgent#inserts(Class<E>, Stream<E>, InsertsCondition<? super E>)                          int         \nSqlAgent#inserts(Class<E>, Stream<E>, InsertsCondition<? super E>, InsertsType)             int         \nSqlAgent#insertsAndReturn(Class<E>, Stream<E>)                                              Stream<E>   \nSqlAgent#insertsAndReturn(Class<E>, Stream<E>, InsertsType)                                 Stream<E>   \nSqlAgent#insertsAndReturn(Class<E>, Stream<E>, InsertsCondition<? super E>)                 Stream<E>   \nSqlAgent#insertsAndReturn(Class<E>, Stream<E>, InsertsCondition<? super E>, InsertsType)    Stream<E>   \n\njava.util.stream.Stream経由で渡される複数のエンティティインスタンスを挿入します。\n\n * @Idアノテーションの指定があるフィールド\n * 対するカラムが自動採番となっているフィールド\n\nの型がprimitive型の場合、もしくはフィールドの値がnullの場合、カラムの値は挿入時に自動採番されます。\nまた、挿入により採番された値がエンティティの該当フィールドにも設定されます。\nフィールドに値を指定した場合は自動採番カラムであっても指定した値が挿入されます。\n\n注意\n\n複数件の挿入で生成されるSQLでは、行毎のフィールドの値の有無を変更することができません。\n最初に挿入するエンティティで@Idの指定があるフィールドや自動採番カラムに対するフィールドに値を設定する場合は、 2件目以降のエンティティにも必ず値を設定するようにしてください。\nまた、最初に挿入するエンティティで@Idの指定があるフィールドや自動採番カラムに対するフィールドの値にnullを設定する場合は、 2件目以降のエンティティで値を設定していても無視されて自動採番されます。\n\nAndReturnが付くメソッドでは、挿入したエンティティオブジェクトのjava.util.stream.Streamを戻り値として取得できるため、 エンティティの挿入に続けて処理を行う場合に便利です。\n\n注意\n\nAndReturnの戻り値となるStream<E>を生成する際、挿入したエンティティを全件メモリ上に保持します。 大量データの挿入を行うとOOMEが発生する場合があるので、insertsAndReturnを使用する場合は挿入する データの件数に気をつけてください。件数が多い場合は一度insertsで挿入した後に、再度検索するといった方法を検討してください。\n\n// 1件の挿入\nDepartment dept = new Department();\ndept.setDeptName("sales");\nagent.insert(dept);\n\n// 複数件の挿入(EmployeeとDeptEmpの挿入)\nagent.inserts(agent.insertsAndReturn(agent.query(Employee.class).stream())\n  .map(e -> {\n    DepEmp deptEmp = new DeptEmp();\n    deptEmp.setEmpNo(e.getEmpNo());\n    deptEmp.setDepNo(dept.getDepNo());\n    return deptEmp;\n  })\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 挿入方法（InsertsType）の指定\nInsertsTypeを指定することで実行される挿入用のSQLを変更することが出来ます。\n\nInsertsType   説明                                                                            \nBULK          insert into ... values ( ... ), ( ... )という風にvaluesに複数行の値を出力し一度に複数レコードを挿入する。   \n              DBがこの記法をサポートしている場合に指定可能。DBが未サポートの場合、指定してもBATCHとして実行される。                       \nBATCH         java.sql.PreparedStatement#executeBatch()を使用したバッチSQL実行                        \n\nStream<Employee> employees = agent.query(Employee.class)\n  .stream()\n  .map(e -> e.setEmpNo(e.getEmpNo() + 1000));\n  \n// 複数件の挿入(バッチ実行)\nagent.inserts(employees, InsertsType.BATCH);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\nTIP\n\nInsertsTypeは、初期値設定が可能です。\n\n# 挿入条件（InsertsCondition）の指定\n挿入用SQLの実行条件を指定します。\nInsertsCondition<E>#test(SqlContext ctx, int count, E entity)の戻り値がtrueの場合に挿入用SQLを実行します。\nInsertsConditionはFunctionalInterfaceのためlambda式が利用できます。\n\nStream<Employee> employees = agent.query(Employee.class)\n  .stream()\n  .map(e -> e.setEmpNo(e.getEmpNo() + 1000));\n  \n// 複数件の挿入（10件毎に挿入）\nagent.inserts(employees, (ctx, count, entity) -> count == 10);\n\n\n1\n2\n3\n4\n5\n6\n# エンティティの更新\n# 1件の更新(SqlAgent#update /#updateAndReturn)\nメソッド名                              戻り値の型   \n<E> SqlAgent#update(E)             int     \n<E> SqlAgent#updateAndReturn(E)    E       \n\nエンティティクラスのインスタンスを使って１レコードの更新を行います。\n\nレコード更新時、@Versionアノテーションの指定があるフィールドに対するカラムはカウントアップされます。\nまた、更新された値がエンティティの該当フィールドにも設定されます。\n\n補足\n\nエンティティクラスのインスタンスを使った１レコードの更新では、@Idを指定したフィールドに対するカラムや自動採番カラムは更新できません。\n@Idを指定したフィールドに対するカラムや自動採番カラムを更新する場合は、後述する条件指定による複数件の更新を使用してください。\n\nAndReturnが付くメソッドでは、更新したエンティティオブジェクトを戻り値として取得できるため、 エンティティの更新に続けて処理を行う場合に便利です。\n\nagent.find(Employee.class, 1).ifPresent(employee -> {\n  employee.setLastName("Wilson");\n  System.out.println(employee.getLockVersion()); // 1\n\n  // エンティティの更新\n  agent.update(employee);\n  System.out.println(employee.getLockVersion()); // 2\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 条件指定による複数件の更新(SqlAgent#update) \nメソッド名                                 戻り値の型                \nSqlAgent#update(Class<? extends E>)   SqlEntityUpdate<E>   \n\n更新対象のレコードを抽出する条件を指定して更新を行います。\n抽出条件の指定方法は 抽出条件の指定 を参照してください。\nまた、set()メソッドで更新対象のフィールドと値を指定することができます。\n\n// first_name に \'Bob\' を含むエンティティの性別を更新\nagent.update(Employee.class)\n  .contains("firstName", "Bob")\n  .set("gender", Gender.MALE)\n  .count();\n\n\n1\n2\n3\n4\n5\n# 複数件の更新(SqlAgent#updates /#updatesAndReturn) \nメソッド名                                                                         戻り値の型       \nSqlAgent#updates(Stream<E>)                                                   int         \nSqlAgent#updates(Stream<E>, UpdatesCondition<? super E>)                      int         \nSqlAgent#updatesAndReturn(Stream<E>)                                          Stream<E>   \nSqlAgent#updatesAndReturn(Stream<E>, UpdatesCondition<? super E>)             Stream<E>   \nSqlAgent#updates(Class<E>, Stream<E>)                                         int         \nSqlAgent#updates(Class<E>, Stream<E>, UpdatesCondition<? super E>)            int         \nSqlAgent#updatesAndReturn(Class<E>, Stream<E>)                                Stream<E>   \nSqlAgent#updatesAndReturn(Class<E>, Stream<E>, UpdatesCondition<? super E>)   Stream<E>   \n\njava.util.stream.Stream経由で渡される複数のエンティティインスタンスを使って更新します。\n\nTIP\n\ninsertsと違い必ずバッチSQL実行になります。\n\nレコード更新時、@Versionアノテーションの指定があるフィールドに対するカラムはカウントアップされます。\nまた、更新された値がエンティティの該当フィールドにも設定されます。\n\nAndReturnが付くメソッドでは、更新したエンティティオブジェクトのjava.util.stream.Streamを戻り値として取得できるため、 エンティティの更新に続けて処理を行う場合に便利です。\n\nWARNING\n\nAndReturnの戻り値となるStream<E>を生成する際、更新したエンティティを全件メモリ上に保持します。 大量データの更新を行うとOOMEが発生する場合があるので、updatesAndReturnを使用する場合は更新する データの件数に気をつけてください。件数が多い場合は一度updatesで更新した後に、再度検索するといった方法を検討してください。\n\n// 複数件の更新\nagent.updates(agent.query(Employee.class)\n  .stream()\n  .map(e -> {\n    e.setFirstName(e.getFirstName() + "_new");\n    return e;\n  })\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 更新条件（UpdatesCondition）の指定\n更新用SQLの実行条件を指定します。\nUpdatesCondition<E>#test(SqlContext ctx, int count, E entity)の戻り値がtrueの場合に更新用SQLを実行します。\nUpdatesConditionはFunctionalInterfaceのためlambda式が利用できます。\n\nStream<Employee> employees = agent.query(Employee.class)\n  .stream()\n  .map(e -> {\n    e.setFirstName(e.getFirstName() + "_new");\n    return e;\n  });\n  \n// 複数件の更新（10件毎に挿入）\nagent.updates(employees, (ctx, count, entity) -> count == 10);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# エンティティの削除\n# 1件の削除(SqlAgent#delete /#deleteAndReturn)\nメソッド名                              戻り値の型   \n<E> SqlAgent#delete(E)             int     \n<E> SqlAgent#deleteAndReturn(E)    E       \n\nエンティティクラスのインスタンスを使って１レコードの削除を行います。\n\nAndReturnが付くメソッドでは、削除したエンティティオブジェクトを戻り値として取得できるため、 エンティティの削除に続けて処理を行う場合に便利です。\n\nagent.find(Employee.class, 1).ifPresent(employee -> {\n  // エンティティの削除\n  agent.delete(employee);\n});\n\n\n1\n2\n3\n4\n# PKを指定した複数件の削除(SqlAgent#delete) \nメソッド名                                            戻り値の型   \nSqlAgent#delete(Class<? extends E>, Object...)   int     \n\n// PK(emp_no) = 1 or 2 のエンティティの削除\nagent.delete(Employee.class, 1, 2);\n\n\n1\n2\n# 条件指定による複数件の削除(SqlAgent#delete) \nメソッド名                                 戻り値の型                \nSqlAgent#delete(Class<? extends E>)   SqlEntityDelete<E>   \n\n削除対象のレコードを抽出する条件を指定して削除を行います。\n抽出条件の指定方法は 抽出条件の指定 を参照してください。\n\n// first_name = \'Bob\' に該当するエンティティの削除\nagent.delete(Employee.class).contains("firstName", "Bob").count();\n\n\n1\n2\n# 全ての行を削除（SqlAgent#truncate） \nメソッド名                                   戻り値の型      \nSqlAgent#truncate(Class<? extends E>)   SqlAgent   \n\nエンティティクラスとマッピングされているテーブルの全てのレコードをTRUNCATE文により削除します。 一般的に大量レコードの削除は、TRUNCATE文による削除のほうが性能上有利ですが、DBMSによってはロールバックできませんので、注意してください。\n\nTIP\n\nPostgreSQLは、TRUNCATE文のロールバック可能です。\n\nSqlAgent#truncateは、SqlAgentを戻り値として返すため、SqlAgent#truncateに続けて、SqlAgent#insertsをつなげることにより、 テーブルの洗い替えを実装することが可能です。\n\n// 全てのレコードを削除\nagent.truncate(Employee.class);\n\n// テーブルの洗い替え\nagent.truncate(Employee.class)\n     .inserts(employees.stream());\n\n\n1\n2\n3\n4\n5\n6\n# Entityアノテーション\nDAOインタフェースで利用するエンティティクラスではテーブルとのマッピングやカラムの属性を指定するためにアノテーションを利用することができます。\n\n# @Table\nエンティティクラスに紐づけるテーブル名を指定します。\nテーブル名と名前が一致しないエンティティクラスにマッピングしたい場合に利用します。\n\n属性名      型        必須   説明                                                 初期値   \nname     String   -    マッピングするテーブル名。指定しない場合はクラス名をスネークケースにしたテーブルとマッピングする   なし    \nschema   String   -    マッピングするテーブルの所属するスキーマ名                              なし    \n\nimport jp.co.future.uroborosql.mapping.annotations.Table;\n\n// name指定なし (departmentテーブルにマッピング)\n@Table\npublic class Department {\n  // 以下略\n}\n\n// name指定あり\n@Table(name = "employee")\npublic class CustomEmployee {\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# @Column\nフィールドに紐づけるカラム名を指定します。\nカラム名と名前が一致しないフィールドにマッピングしたい場合に利用します。\n\n属性名    型        必須   説明            初期値   \nname   String   〇    マッピングするカラム名   なし    \n\nimport jp.co.future.uroborosql.mapping.annotations.Table;\nimport jp.co.future.uroborosql.mapping.annotations.Column;\n\n@Table(name = "employee")\npublic class Employee {\n  @Column(name = "emp_no")\n  private long employeeNo;\n\n  private String firstName;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# @Domain\n独自に作成した型(ドメインクラス)のフィールドにカラムをマッピングする場合に指定します。\n\n属性名             型          必須   説明                                             初期値          \nvalueType       Class<?>   〇    ドメインクラスを生成するのに必要な値の型                           なし           \nfactoryMethod   String     -    ドメインクラスを生成・取得するメソッド名。指定しない場合はコンストラクタが呼び出される。   ""           \ntoJdbcMethod    String     -    JDBCが受け付けられる値に変換するメソッド名                        "getValue"   \nnullable        boolean    -    null可かどうかの指定                                   false        \n\n例\n\nimport jp.co.future.uroborosql.mapping.annotations.Table;\nimport jp.co.future.uroborosql.mapping.annotations.Domain;\n\n@Domain(valueType = String.class, factoryMethod = "of", toJdbcMethod = "getName", nullable = true)\npublic static class NameDomain {\n  private String name;\n\n  private NameDomain(String name) {\n    this.name = name;\n  }\n\n  public static NameDomain of(String name) {\n    return new NameDomain(name);\n  }\n\n  public String getName() {\n    return name;\n  }\n}\n\n@Table\npublic class Employee {\n  private long empNo;\n  private NameDomain firstName;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# @Transient\nフィールドとカラムのマッピング対象から除外します。\n\nTIP\n\n例えば、エンタープライズシステムの設計でしばしば利用される最終登録日時や最終更新日時など、 INSERT/UPDATEの対象から除外したいケースで利用します。\n\n属性名      型         必須   説明                                               初期値    \ninsert   boolean   -    agent#insert()実行時にフィールドを無視するかどうか。trueの場合は無視する。   true   \nupdate   boolean   -    agent#update()実行時にフィールドを無視するかどうか。trueの場合は無視する。   true   \n\n例\n\nimport jp.co.future.uroborosql.mapping.annotations.Table;\nimport jp.co.future.uroborosql.mapping.annotations.Transient;\n\n@Table\npublic class Employee {\n\n  // 途中略\n\n  @Transient\n  private String memo; // 常に無視\n\n  @Transient(insert = false, update = true)\n  private LocalDate creationDate; // insert時は対象、update時は無視\n\n  @Transient(insert = true, update = false)\n  private LocalDate updateDate;  // insert時は無視、update時は対象\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# @Version\nこのアノテーションが付与されたフィールドは楽観ロック用のバージョン情報を保持するフィールドになります。\nデフォルト(LockVersionOptimisticLockSupplier)ではUPDATE時にはSET句で+1され、WHERE句の検索条件に追加されてSQLを実行し更新件数が0の場合にはOptimisticLockExceptionをスローします。\n\nWARNING\n\n@Versionを付与するフィールドにマッピングされるDBカラムの型は数値型でなければなりません。\n\n属性名        型                        必須   説明           初期値                                 \nsupplier   OptimisticLockSupplier   -    バージョン情報カラム   LockVersionOptimisticLockSupplier   \n\n# サプライヤの種類\nサプライヤ型                                    概要              説明                                                         \nLockVersionOptimisticLockSupplier         ロックバージョン        UPDATEのSET句で+1がセットされます。                                    \nCyclicLockVersionOptimisticLockSupplier   循環式ロックバージョン     UPDATEのSET句でバージョン情報カラム名 % 数値カラムの最大値 + 1がセットされます。           \nTimestampOptimisticLockSupplier           タイムスタンプ         UPDATEのSET句でタイムスタンプ(System.currentTimeMillis())がセットされます。   \nFieldIncrementOptimisticLockSupplier      フィールド値インクリメント   UPDATEのSET句で2WaySQLのバインド変数を利用して、バージョン情報カラム名＋1がセットされます。     \n\n例\n\nimport jp.co.future.uroborosql.mapping.annotations.Table;\nimport jp.co.future.uroborosql.mapping.annotations.Version;\nimport jp.co.future.uroborosql.mapping.TimestampOptimisticLockSupplier;\n\n@Table\npublic class Employee {\n  private long empNo;\n  private String firstName;\n  private String lastName;\n\n　　// 途中略\n\n  @Version(supplier = TimestampOptimisticLockSupplier.class)\n  private long lockVersion = 0;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# @Id /@GeneratedValue /@SequenceGenerator \nこれらのアノテーションが付与されたフィールドは自動採番フィールドになります。\n@Idと@GeneratedValueは必ずセットでフィールドに付与する必要があります。\n@GeneratedValueのstrategy属性がGenerationType.SEQUENCEの場合に@SequenceGeneratorを付与してシーケンスの生成方法を指定する必要があります。\n\nアノテーション              説明                            \n@Id                  エンティティの主キーを識別するアノテーション        \n@GeneratedValue      主キーの値の生成戦略を指定するアノテーション        \n@SequenceGenerator   SEQUENCEによるID生成を設定するアノテーション   \n\nアノテーション              属性名        型                必須   説明                                                                   初期値                       \n@Id                  なし         -                -    -                                                                    -                         \n@GeneratedValue      strategy   GenerationType   -    主キー生成戦略の型。GenerationType.IDENTITY, GenerationType.SEQUENCEのいずれかを指定   GenerationType.IDENTITY   \n@SequenceGenerator   sequence   String           〇    シーケンス名                                                               なし                        \n@SequenceGenerator   catalog    String           -    シーケンスが所属するカタログ名                                                      ""                        \n@SequenceGenerator   schema     String           -    シーケンスが所属するスキーマ名                                                      ""                        \n\nimport jp.co.future.uroborosql.mapping.annotations.Table;\nimport jp.co.future.uroborosql.mapping.annotations.Id;\nimport jp.co.future.uroborosql.mapping.annotations.GeneratedValue;\nimport jp.co.future.uroborosql.mapping.annotations.SequenceGenerator;\n\n@Table\npublic class Employee {\n  @Id\n  @GeneratedValue(strategy = GenerationType.SEQUENCE)\n  @SequenceGenerator(sequence = \'employee_emp_id_seq\')\n  private long empNo;\n\n  private String firstName;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16',contentLowercase:'# daoインタフェース\nuroborosqlはdao(data access object)を用いた単一テーブルへのcrudに対応しています。\n\n下記のテーブルとそれに対応するエンティティクラスを例として説明します。\n\n-- mysqlの場合\ncreate table employee (\n  emp_no number(6) not null auto_increment\n  , first_name varchar(20) not null\n  , last_name varchar(20) not null\n  , birth_date date not null\n  , gender char(1) not null\n  , lock_version number(10) not null\n  , constraint employee_pkc primary key (emp_no)\n)\n\n-- postgresqlの場合\ncreate table employee (\n  emp_no serial not null\n  , first_name varchar(20) not null\n  , last_name varchar(20) not null\n  , birth_date date not null\n  , gender char(1) not null\n  , lock_version number(10) not null\n  , constraint employee_pkc primary key (emp_no)\n) ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\npublic class employee {\n  private long empno;\n  private string firstname;\n  private string lastname;\n  private localdate birthdate;\n  private gender gender;\n  private long lockversion = 0;\n\n  // 中略 getter/setter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# エンティティクラスの検索\n# キーを指定した１件取得(sqlagent#find)\nメソッド名                                戻り値の型         \nsqlagent#find(class<e>, object...)   optional<e>   \n\n主キーを指定してエンティティを取得します。pkカラムの数と引数に指定するキーの数は合わせる必要があります。\n\n// emp_no = 1 のレコードをエンティティとして取得\noptional<employee> employee = agent.find(employee.class, 1);\n\n\n1\n2\n# 条件指定検索(sqlagent#query) \nメソッド名                      戻り値の型               \nsqlagent#query(class<e>)   sqlentityquery<e>   \n\nエンティティクラスを利用した検索を行うためのオブジェクト（sqlentityquery)を取得します。\nsqlentityqueryに対して抽出条件の指定を行い、抽出条件に該当するエンティティを取得します。\n\n\n\n\n# 抽出条件の指定(sqlentityquery#equal /#notequal /#greaterthan /#lessthan /#greaterequal /#lessequal /#in /#notin /#like /#startswith /#endswith /#contains /#notlike /#notstartswith /#notendswith /#notcontains /#between /#isnull /#isnotnull /#where)\n抽出条件指定メソッド記述例                                                             生成されるwhere句の条件式                        補足説明                                  \nequal("col", "value")                                                     col = \'value\'                                                                \nnotequal("col", "value")                                                  col != \'value\'                                                               \ngreaterthan("col", 1)                                                     col > 1                                                                      \nlessthan("col", 1)                                                        col < 1                                                                      \ngreaterequal("col", 1)                                                    col >= 1                                                                     \nlessequal("col", 1)                                                       col <= 1                                                                     \nin("col", "val1", "val2")                                                 col in (\'val1\', \'val2\')                                                      \nin("col", list.of("val1", "val2"))                                        col in (\'val1\', \'val2\')                                                      \nnotin("col", "val1", "val2")                                              col not in (\'val1\', \'val2\')                                                  \nnotin("col", list.of("val1", "val2"))                                     col not in (\'val1\', \'val2\')                                                  \nlike("col", "%val%")                                                      like \'%val%\'                           valはエスケープされない                         \nstartswith("col", "val")                                                  like \'val%\'                            valはエスケープされる                          \nendswith("col", "val")                                                    like \'%val\'                            valはエスケープされる                          \ncontains("col", "val")                                                    like \'%val%\'                           valはエスケープされる                          \nnotlike("col", "%val%")                                                   not like \'%val%\'                       valはエスケープされない                         \nnotstartswith("col", "val")                                               not like \'val%\'                        valはエスケープされる                          \nnotendswith("col", "val")                                                 not like \'%val\'                        valはエスケープされる                          \nnotcontains("col", "val")                                                 not like \'%val%\'                       valはエスケープされる                          \nbetween("col", 1, 2)                                                      col between 1 and 2                                                          \nisnull("col")                                                             col is null                                                                  \nisnotnull("col")                                                          col is not null                                                              \nwhere("col = 1 or col = 2")                                               (col = 1 or col = 2)                   もし複数回where()が呼び出された場合は条件を and で結合する   \nwhere("col = /*col1*/", "col1", 1)                                        (col = 1/*col1*/)                      パラメータの指定（1件）付き                        \nwhere("col = /*col1*/ or col = /*col2*/", map.of("col1", 1, "col2", 2))   (col = 1/*col1*/ or col = 2/*col2*/)   パラメータの指定（複数件）付き                       \n\n// emp_no = 1 のレコードをlist<employee>で取得\nagent.query(employee.class).equal("emp_no", 1).collect();\n\n// emp_no = 10 又は 20 のレコードをlist<employee>で取得\nagent.query(employee.class).in("emp_no", 10, 20).collect();\n\n// first_name like \'%bob%\' のレコードをlist<employee>で取得\nagent.query(employee.class).contains("first_name", "bob").collect();\n\n// where句を直接記述(first_name = \'bob\' and last_name = \'smith\')した結果をlist<employee>で取得\nagent.query(employee.class).where("first_name =\'\'/*firstname*/", "firstname", "bob").where("last_name = \'\'/*lastname*/", "lastname", "smith").collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n注意\n\nsqlentityqueryに対して抽出条件を指定する場合paramメソッドは使用しないでください。sqlentityquery#param()には@deprecatedが付与されており、将来削除される予定です。\n\n# ソート順(sqlentityquery#asc /#desc)や取得データの件数(#limit)、開始位置(#offset)、悲観ロック(#forupdate /#forupdatenowait /#forupdatewait)の指定 \nsqlentityqueryでは抽出条件に加えて検索結果のソート順や取得件数の制限、開始位置の指定、明示的なロック指定が行えます。\n\n条件指定メソッド記述例                 生成されるsql                         補足説明                                                                     \nasc("col1", "col2")         order by col1 asc, col2 asc      nullsが有効な場合はnulls lastが出力される                                             \nasc("col1", nulls.first)    order by col1 asc nulls first    複数回asc()が呼び出された場合は呼び出し順に並べる                                              \ndesc("col1", "col2")        order by col1 desc, col2 desc    nullsが有効な場合はnulls lastが出力される                                             \ndesc("col1", nulls.first)   order by col1 desc nulls first   複数回asc()が呼び出された場合は呼び出し順に並べる                                              \nlimit(10)                   limit 10                         接続しているdbでlimit句が使用できない場合はuroborosqlruntimeexceptionがスローされる               \noffset(10)                  offset 10                        接続しているdbでoffset句が使用できない場合はuroborosqlruntimeexceptionがスローされる              \nforupdate()                 for update                       接続しているdbでfor update句が使用できない場合はuroborosqlruntimeexceptionがスローされる          \nforupdatenowait()           for update nowait                接続しているdbでfor update nowait句が使用できない場合はuroborosqlruntimeexceptionがスローされる   \nforupdatewait()             for update wait 10               接続しているdbでfor update wait句が使用できない場合はuroborosqlruntimeexceptionがスローされる     \nforupdatewait(30)           for update wait 30               接続しているdbでfor update wait句が使用できない場合はuroborosqlruntimeexceptionがスローされる     \n\n// birth_dateの降順、first_nameの昇順でソートした結果を list<employee>で取得\nagent.query(employee.class).desc("birth_date").asc("first_name").collect();\n\n// emp_no の昇順でソートした結果の3行目から5件取得\nagent.query(employee.class).asc("emp_no").offset(3).limit(5).collect();\n\n// 明示的な行ロックを行う\nagent.query(employee.class).forupdate().collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# オプティマイザーヒントの指定(sqlentityquery#hint) \nsqlentityquery#hint()を使用することで、sqlに対してオプティマイザーヒントを指定することができます。\n\nsqlagent agent = ...\nagent.query(user.class).hint("ordered").lessthan("age", 30).collect();\n\n\n1\n2\n出力されるsql(oracleの場合)\n\nselect /*+ ordered */ id, name, age, ... from user where age < 30\n\n\n1\n注意\n\nオプティマイザーヒントの指定は、利用するdbがオプティマイザーヒントをサポートしている場合に有効になります。\nまた、指定可能なヒント句は利用するdbに依存します。\n\n# 検索結果の取得(sqlentityqury#collect /#first /#one /#select /#stream)\nsqlentityqueryから抽出条件に該当するエンティティを取得します。\n\nメソッド                                           説明                                                       \ncollect()                                      検索結果をエンティティのリストとして取得する                                   \nfirst()                                        検索結果の先頭行を取得する                                            \none()                                          検索結果の先頭行を取得する。検索結果が2件以上の場合datanonuniqueexceptionをスローする   \nstream<c> select(string col, class<c> type)    検索結果の指定したカラムの値をjava.util.stream.streamとして取得する。           \nstream()                                       検索結果をjava.util.stream.streamとして取得する                      \n\n// list<employee>で取得\nlist<enployee> employees = agent.query(employee.class).collect();\n\n// 検索結果の先頭行を取得\noptional<enployee> employee = agent.query(employee.class).first();\n\n// 検索結果（カラム値）の取得\nstring employeename = agent.query(employee.class)\n    .equal("employeeid", 1)\n    .select("employeename", string.class).findfirst().get();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 集約関数(sqlentityquery#count /#sum /#sum /#min /#max /#exists /#notexists) \nsqlentityqueryではエンティティを取得する他に結果の集計を行うこともできます。\n\nメソッド                           説明                                    \ncount()                        検索結果の件数を取得する                          \ncount(string col)              検索結果のうち、引数で指定したカラムがnullでない行の件数を取得する   \nsum(string col)                検索結果のうち、引数で指定したカラムの合計値を取得する           \nmin(string col)                検索結果のうち、引数で指定したカラムの最小値を取得する           \nmax(string col)                検索結果のうち、引数で指定したカラムの最大値を取得する           \nexists(runnable runnable)      検索結果が1件以上ある場合に引数で渡した関数を実行する           \nnotexists(runnable runnable)   検索結果が0件の場合に引数で渡した関数を実行する              \n\n// 検索結果の件数を取得\nlong count = agent.query(employee.class).count();\n\n// 検索結果が1件以上の場合にログを出力する\nagent.query(employee.class).greaterthan("emp_no", 10).exists(() -> {\n  log.info("employee(emp_no > 10) exists.");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\ntip\n\n集約関数を使用すると、検索結果からentityオブジェクトを生成しないためメモリ効率が良くなります。 以下２つの処理結果は同じですが、メモリの使い方が違います。\n\n// collect()を使用すると、検索結果がエンティティに変換されるためメモリを使用する\nlong count = agent.query(employee.class).collect().size();\n\n// count()を使用すると件数のみ取得できる（エンティティは生成されない）\nlong count = agent.query(employee.class).count();\n\n\n1\n2\n3\n4\n5\n# エンティティの挿入\n# 1件の挿入(sqlagent#insert/#insertandreturn)\nメソッド名                              戻り値の型   \n<e> sqlagent#insert(e)             int     \n<e> sqlagent#insertandreturn(e)    e       \n\nエンティティクラスのインスタンスを使って１レコードの挿入を行います。\n\n * @idアノテーションの指定があるフィールド\n * 対するカラムが自動採番となっているフィールド\n\nの型がprimitive型の場合、もしくはフィールドの値がnullの場合、カラムの値は挿入時に自動採番されます。\nまた、挿入により採番された値がエンティティの該当フィールドにも設定されます。\nフィールドに値を指定した場合は自動採番カラムであっても指定した値が挿入されます。\n\nandreturnが付くメソッドでは、挿入したエンティティオブジェクトを戻り値として取得できるため、 エンティティの挿入に続けて処理を行う場合に便利です。\n\nemployee employee = new employee();\nemployee.setfirstname("susan");\nemployee.setlastname("davis");\nemployee.setbirthdate(localdate.of(1969, 2, 10));\nemployee.setgender(gender.female); // male("m"), female("f"), other("o")\n\n// 1件の挿入\nagent.insert(employee);\nsystem.out.println(employee.getempno()); // 自動採番された値が出力される\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 複数件の挿入(sqlagent#inserts /#insertsandreturn) \nメソッド名                                                                                       戻り値の型       \nsqlagent#inserts(stream<e>)                                                                 int         \nsqlagent#inserts(stream<e>, insertstype)                                                    int         \nsqlagent#inserts(stream<e>, insertscondition<? super e>)                                    int         \nsqlagent#inserts(stream<e>, insertscondition<? super e>, insertstype)                       int         \nsqlagent#insertsandreturn(stream<e>)                                                        stream<e>   \nsqlagent#insertsandreturn(stream<e>, insertstype)                                           stream<e>   \nsqlagent#insertsandreturn(stream<e>, insertscondition<? super e>)                           stream<e>   \nsqlagent#insertsandreturn(stream<e>, insertscondition<? super e>, insertstype)              stream<e>   \nsqlagent#inserts(class<e>, stream<e>)                                                       int         \nsqlagent#inserts(class<e>, stream<e>, insertstype)                                          int         \nsqlagent#inserts(class<e>, stream<e>, insertscondition<? super e>)                          int         \nsqlagent#inserts(class<e>, stream<e>, insertscondition<? super e>, insertstype)             int         \nsqlagent#insertsandreturn(class<e>, stream<e>)                                              stream<e>   \nsqlagent#insertsandreturn(class<e>, stream<e>, insertstype)                                 stream<e>   \nsqlagent#insertsandreturn(class<e>, stream<e>, insertscondition<? super e>)                 stream<e>   \nsqlagent#insertsandreturn(class<e>, stream<e>, insertscondition<? super e>, insertstype)    stream<e>   \n\njava.util.stream.stream経由で渡される複数のエンティティインスタンスを挿入します。\n\n * @idアノテーションの指定があるフィールド\n * 対するカラムが自動採番となっているフィールド\n\nの型がprimitive型の場合、もしくはフィールドの値がnullの場合、カラムの値は挿入時に自動採番されます。\nまた、挿入により採番された値がエンティティの該当フィールドにも設定されます。\nフィールドに値を指定した場合は自動採番カラムであっても指定した値が挿入されます。\n\n注意\n\n複数件の挿入で生成されるsqlでは、行毎のフィールドの値の有無を変更することができません。\n最初に挿入するエンティティで@idの指定があるフィールドや自動採番カラムに対するフィールドに値を設定する場合は、 2件目以降のエンティティにも必ず値を設定するようにしてください。\nまた、最初に挿入するエンティティで@idの指定があるフィールドや自動採番カラムに対するフィールドの値にnullを設定する場合は、 2件目以降のエンティティで値を設定していても無視されて自動採番されます。\n\nandreturnが付くメソッドでは、挿入したエンティティオブジェクトのjava.util.stream.streamを戻り値として取得できるため、 エンティティの挿入に続けて処理を行う場合に便利です。\n\n注意\n\nandreturnの戻り値となるstream<e>を生成する際、挿入したエンティティを全件メモリ上に保持します。 大量データの挿入を行うとoomeが発生する場合があるので、insertsandreturnを使用する場合は挿入する データの件数に気をつけてください。件数が多い場合は一度insertsで挿入した後に、再度検索するといった方法を検討してください。\n\n// 1件の挿入\ndepartment dept = new department();\ndept.setdeptname("sales");\nagent.insert(dept);\n\n// 複数件の挿入(employeeとdeptempの挿入)\nagent.inserts(agent.insertsandreturn(agent.query(employee.class).stream())\n  .map(e -> {\n    depemp deptemp = new deptemp();\n    deptemp.setempno(e.getempno());\n    deptemp.setdepno(dept.getdepno());\n    return deptemp;\n  })\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 挿入方法（insertstype）の指定\ninsertstypeを指定することで実行される挿入用のsqlを変更することが出来ます。\n\ninsertstype   説明                                                                            \nbulk          insert into ... values ( ... ), ( ... )という風にvaluesに複数行の値を出力し一度に複数レコードを挿入する。   \n              dbがこの記法をサポートしている場合に指定可能。dbが未サポートの場合、指定してもbatchとして実行される。                       \nbatch         java.sql.preparedstatement#executebatch()を使用したバッチsql実行                        \n\nstream<employee> employees = agent.query(employee.class)\n  .stream()\n  .map(e -> e.setempno(e.getempno() + 1000));\n  \n// 複数件の挿入(バッチ実行)\nagent.inserts(employees, insertstype.batch);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\ntip\n\ninsertstypeは、初期値設定が可能です。\n\n# 挿入条件（insertscondition）の指定\n挿入用sqlの実行条件を指定します。\ninsertscondition<e>#test(sqlcontext ctx, int count, e entity)の戻り値がtrueの場合に挿入用sqlを実行します。\ninsertsconditionはfunctionalinterfaceのためlambda式が利用できます。\n\nstream<employee> employees = agent.query(employee.class)\n  .stream()\n  .map(e -> e.setempno(e.getempno() + 1000));\n  \n// 複数件の挿入（10件毎に挿入）\nagent.inserts(employees, (ctx, count, entity) -> count == 10);\n\n\n1\n2\n3\n4\n5\n6\n# エンティティの更新\n# 1件の更新(sqlagent#update /#updateandreturn)\nメソッド名                              戻り値の型   \n<e> sqlagent#update(e)             int     \n<e> sqlagent#updateandreturn(e)    e       \n\nエンティティクラスのインスタンスを使って１レコードの更新を行います。\n\nレコード更新時、@versionアノテーションの指定があるフィールドに対するカラムはカウントアップされます。\nまた、更新された値がエンティティの該当フィールドにも設定されます。\n\n補足\n\nエンティティクラスのインスタンスを使った１レコードの更新では、@idを指定したフィールドに対するカラムや自動採番カラムは更新できません。\n@idを指定したフィールドに対するカラムや自動採番カラムを更新する場合は、後述する条件指定による複数件の更新を使用してください。\n\nandreturnが付くメソッドでは、更新したエンティティオブジェクトを戻り値として取得できるため、 エンティティの更新に続けて処理を行う場合に便利です。\n\nagent.find(employee.class, 1).ifpresent(employee -> {\n  employee.setlastname("wilson");\n  system.out.println(employee.getlockversion()); // 1\n\n  // エンティティの更新\n  agent.update(employee);\n  system.out.println(employee.getlockversion()); // 2\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 条件指定による複数件の更新(sqlagent#update) \nメソッド名                                 戻り値の型                \nsqlagent#update(class<? extends e>)   sqlentityupdate<e>   \n\n更新対象のレコードを抽出する条件を指定して更新を行います。\n抽出条件の指定方法は 抽出条件の指定 を参照してください。\nまた、set()メソッドで更新対象のフィールドと値を指定することができます。\n\n// first_name に \'bob\' を含むエンティティの性別を更新\nagent.update(employee.class)\n  .contains("firstname", "bob")\n  .set("gender", gender.male)\n  .count();\n\n\n1\n2\n3\n4\n5\n# 複数件の更新(sqlagent#updates /#updatesandreturn) \nメソッド名                                                                         戻り値の型       \nsqlagent#updates(stream<e>)                                                   int         \nsqlagent#updates(stream<e>, updatescondition<? super e>)                      int         \nsqlagent#updatesandreturn(stream<e>)                                          stream<e>   \nsqlagent#updatesandreturn(stream<e>, updatescondition<? super e>)             stream<e>   \nsqlagent#updates(class<e>, stream<e>)                                         int         \nsqlagent#updates(class<e>, stream<e>, updatescondition<? super e>)            int         \nsqlagent#updatesandreturn(class<e>, stream<e>)                                stream<e>   \nsqlagent#updatesandreturn(class<e>, stream<e>, updatescondition<? super e>)   stream<e>   \n\njava.util.stream.stream経由で渡される複数のエンティティインスタンスを使って更新します。\n\ntip\n\ninsertsと違い必ずバッチsql実行になります。\n\nレコード更新時、@versionアノテーションの指定があるフィールドに対するカラムはカウントアップされます。\nまた、更新された値がエンティティの該当フィールドにも設定されます。\n\nandreturnが付くメソッドでは、更新したエンティティオブジェクトのjava.util.stream.streamを戻り値として取得できるため、 エンティティの更新に続けて処理を行う場合に便利です。\n\nwarning\n\nandreturnの戻り値となるstream<e>を生成する際、更新したエンティティを全件メモリ上に保持します。 大量データの更新を行うとoomeが発生する場合があるので、updatesandreturnを使用する場合は更新する データの件数に気をつけてください。件数が多い場合は一度updatesで更新した後に、再度検索するといった方法を検討してください。\n\n// 複数件の更新\nagent.updates(agent.query(employee.class)\n  .stream()\n  .map(e -> {\n    e.setfirstname(e.getfirstname() + "_new");\n    return e;\n  })\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 更新条件（updatescondition）の指定\n更新用sqlの実行条件を指定します。\nupdatescondition<e>#test(sqlcontext ctx, int count, e entity)の戻り値がtrueの場合に更新用sqlを実行します。\nupdatesconditionはfunctionalinterfaceのためlambda式が利用できます。\n\nstream<employee> employees = agent.query(employee.class)\n  .stream()\n  .map(e -> {\n    e.setfirstname(e.getfirstname() + "_new");\n    return e;\n  });\n  \n// 複数件の更新（10件毎に挿入）\nagent.updates(employees, (ctx, count, entity) -> count == 10);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# エンティティの削除\n# 1件の削除(sqlagent#delete /#deleteandreturn)\nメソッド名                              戻り値の型   \n<e> sqlagent#delete(e)             int     \n<e> sqlagent#deleteandreturn(e)    e       \n\nエンティティクラスのインスタンスを使って１レコードの削除を行います。\n\nandreturnが付くメソッドでは、削除したエンティティオブジェクトを戻り値として取得できるため、 エンティティの削除に続けて処理を行う場合に便利です。\n\nagent.find(employee.class, 1).ifpresent(employee -> {\n  // エンティティの削除\n  agent.delete(employee);\n});\n\n\n1\n2\n3\n4\n# pkを指定した複数件の削除(sqlagent#delete) \nメソッド名                                            戻り値の型   \nsqlagent#delete(class<? extends e>, object...)   int     \n\n// pk(emp_no) = 1 or 2 のエンティティの削除\nagent.delete(employee.class, 1, 2);\n\n\n1\n2\n# 条件指定による複数件の削除(sqlagent#delete) \nメソッド名                                 戻り値の型                \nsqlagent#delete(class<? extends e>)   sqlentitydelete<e>   \n\n削除対象のレコードを抽出する条件を指定して削除を行います。\n抽出条件の指定方法は 抽出条件の指定 を参照してください。\n\n// first_name = \'bob\' に該当するエンティティの削除\nagent.delete(employee.class).contains("firstname", "bob").count();\n\n\n1\n2\n# 全ての行を削除（sqlagent#truncate） \nメソッド名                                   戻り値の型      \nsqlagent#truncate(class<? extends e>)   sqlagent   \n\nエンティティクラスとマッピングされているテーブルの全てのレコードをtruncate文により削除します。 一般的に大量レコードの削除は、truncate文による削除のほうが性能上有利ですが、dbmsによってはロールバックできませんので、注意してください。\n\ntip\n\npostgresqlは、truncate文のロールバック可能です。\n\nsqlagent#truncateは、sqlagentを戻り値として返すため、sqlagent#truncateに続けて、sqlagent#insertsをつなげることにより、 テーブルの洗い替えを実装することが可能です。\n\n// 全てのレコードを削除\nagent.truncate(employee.class);\n\n// テーブルの洗い替え\nagent.truncate(employee.class)\n     .inserts(employees.stream());\n\n\n1\n2\n3\n4\n5\n6\n# entityアノテーション\ndaoインタフェースで利用するエンティティクラスではテーブルとのマッピングやカラムの属性を指定するためにアノテーションを利用することができます。\n\n# @table\nエンティティクラスに紐づけるテーブル名を指定します。\nテーブル名と名前が一致しないエンティティクラスにマッピングしたい場合に利用します。\n\n属性名      型        必須   説明                                                 初期値   \nname     string   -    マッピングするテーブル名。指定しない場合はクラス名をスネークケースにしたテーブルとマッピングする   なし    \nschema   string   -    マッピングするテーブルの所属するスキーマ名                              なし    \n\nimport jp.co.future.uroborosql.mapping.annotations.table;\n\n// name指定なし (departmentテーブルにマッピング)\n@table\npublic class department {\n  // 以下略\n}\n\n// name指定あり\n@table(name = "employee")\npublic class customemployee {\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# @column\nフィールドに紐づけるカラム名を指定します。\nカラム名と名前が一致しないフィールドにマッピングしたい場合に利用します。\n\n属性名    型        必須   説明            初期値   \nname   string   〇    マッピングするカラム名   なし    \n\nimport jp.co.future.uroborosql.mapping.annotations.table;\nimport jp.co.future.uroborosql.mapping.annotations.column;\n\n@table(name = "employee")\npublic class employee {\n  @column(name = "emp_no")\n  private long employeeno;\n\n  private string firstname;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# @domain\n独自に作成した型(ドメインクラス)のフィールドにカラムをマッピングする場合に指定します。\n\n属性名             型          必須   説明                                             初期値          \nvaluetype       class<?>   〇    ドメインクラスを生成するのに必要な値の型                           なし           \nfactorymethod   string     -    ドメインクラスを生成・取得するメソッド名。指定しない場合はコンストラクタが呼び出される。   ""           \ntojdbcmethod    string     -    jdbcが受け付けられる値に変換するメソッド名                        "getvalue"   \nnullable        boolean    -    null可かどうかの指定                                   false        \n\n例\n\nimport jp.co.future.uroborosql.mapping.annotations.table;\nimport jp.co.future.uroborosql.mapping.annotations.domain;\n\n@domain(valuetype = string.class, factorymethod = "of", tojdbcmethod = "getname", nullable = true)\npublic static class namedomain {\n  private string name;\n\n  private namedomain(string name) {\n    this.name = name;\n  }\n\n  public static namedomain of(string name) {\n    return new namedomain(name);\n  }\n\n  public string getname() {\n    return name;\n  }\n}\n\n@table\npublic class employee {\n  private long empno;\n  private namedomain firstname;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# @transient\nフィールドとカラムのマッピング対象から除外します。\n\ntip\n\n例えば、エンタープライズシステムの設計でしばしば利用される最終登録日時や最終更新日時など、 insert/updateの対象から除外したいケースで利用します。\n\n属性名      型         必須   説明                                               初期値    \ninsert   boolean   -    agent#insert()実行時にフィールドを無視するかどうか。trueの場合は無視する。   true   \nupdate   boolean   -    agent#update()実行時にフィールドを無視するかどうか。trueの場合は無視する。   true   \n\n例\n\nimport jp.co.future.uroborosql.mapping.annotations.table;\nimport jp.co.future.uroborosql.mapping.annotations.transient;\n\n@table\npublic class employee {\n\n  // 途中略\n\n  @transient\n  private string memo; // 常に無視\n\n  @transient(insert = false, update = true)\n  private localdate creationdate; // insert時は対象、update時は無視\n\n  @transient(insert = true, update = false)\n  private localdate updatedate;  // insert時は無視、update時は対象\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# @version\nこのアノテーションが付与されたフィールドは楽観ロック用のバージョン情報を保持するフィールドになります。\nデフォルト(lockversionoptimisticlocksupplier)ではupdate時にはset句で+1され、where句の検索条件に追加されてsqlを実行し更新件数が0の場合にはoptimisticlockexceptionをスローします。\n\nwarning\n\n@versionを付与するフィールドにマッピングされるdbカラムの型は数値型でなければなりません。\n\n属性名        型                        必須   説明           初期値                                 \nsupplier   optimisticlocksupplier   -    バージョン情報カラム   lockversionoptimisticlocksupplier   \n\n# サプライヤの種類\nサプライヤ型                                    概要              説明                                                         \nlockversionoptimisticlocksupplier         ロックバージョン        updateのset句で+1がセットされます。                                    \ncycliclockversionoptimisticlocksupplier   循環式ロックバージョン     updateのset句でバージョン情報カラム名 % 数値カラムの最大値 + 1がセットされます。           \ntimestampoptimisticlocksupplier           タイムスタンプ         updateのset句でタイムスタンプ(system.currenttimemillis())がセットされます。   \nfieldincrementoptimisticlocksupplier      フィールド値インクリメント   updateのset句で2waysqlのバインド変数を利用して、バージョン情報カラム名＋1がセットされます。     \n\n例\n\nimport jp.co.future.uroborosql.mapping.annotations.table;\nimport jp.co.future.uroborosql.mapping.annotations.version;\nimport jp.co.future.uroborosql.mapping.timestampoptimisticlocksupplier;\n\n@table\npublic class employee {\n  private long empno;\n  private string firstname;\n  private string lastname;\n\n　　// 途中略\n\n  @version(supplier = timestampoptimisticlocksupplier.class)\n  private long lockversion = 0;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# @id /@generatedvalue /@sequencegenerator \nこれらのアノテーションが付与されたフィールドは自動採番フィールドになります。\n@idと@generatedvalueは必ずセットでフィールドに付与する必要があります。\n@generatedvalueのstrategy属性がgenerationtype.sequenceの場合に@sequencegeneratorを付与してシーケンスの生成方法を指定する必要があります。\n\nアノテーション              説明                            \n@id                  エンティティの主キーを識別するアノテーション        \n@generatedvalue      主キーの値の生成戦略を指定するアノテーション        \n@sequencegenerator   sequenceによるid生成を設定するアノテーション   \n\nアノテーション              属性名        型                必須   説明                                                                   初期値                       \n@id                  なし         -                -    -                                                                    -                         \n@generatedvalue      strategy   generationtype   -    主キー生成戦略の型。generationtype.identity, generationtype.sequenceのいずれかを指定   generationtype.identity   \n@sequencegenerator   sequence   string           〇    シーケンス名                                                               なし                        \n@sequencegenerator   catalog    string           -    シーケンスが所属するカタログ名                                                      ""                        \n@sequencegenerator   schema     string           -    シーケンスが所属するスキーマ名                                                      ""                        \n\nimport jp.co.future.uroborosql.mapping.annotations.table;\nimport jp.co.future.uroborosql.mapping.annotations.id;\nimport jp.co.future.uroborosql.mapping.annotations.generatedvalue;\nimport jp.co.future.uroborosql.mapping.annotations.sequencegenerator;\n\n@table\npublic class employee {\n  @id\n  @generatedvalue(strategy = generationtype.sequence)\n  @sequencegenerator(sequence = \'employee_emp_id_seq\')\n  private long empno;\n\n  private string firstname;\n\n  // 以下略\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16',charsets:{cjk:!0}},{title:"SQLファイルインタフェース",frontmatter:{meta:[{name:"og:title",content:"SQLファイルインタフェース"},{name:"og:url",content:"/uroborosql-doc/basics/sql-file-api.html"}]},regularPath:"/basics/sql-file-api.html",relativePath:"basics/sql-file-api.md",key:"v-0b7b932a",path:"/basics/sql-file-api.html",headers:[{level:2,title:"SQLによる検索(SqlAgent#query /#queryWith)",slug:"sqlによる検索-sqlagent-query-querywith",charIndex:19},{level:3,title:"検索結果の取得",slug:"検索結果の取得",charIndex:465},{level:3,title:"リスト取得(SqlQuery#collect)",slug:"リスト取得-sqlquery-collect",charIndex:904},{level:3,title:"先頭取得（SqlQuery#first)",slug:"先頭取得-sqlquery-first",charIndex:3005},{level:3,title:"先頭取得（SqlQuery#findFirst)",slug:"先頭取得-sqlquery-findfirst",charIndex:4359},{level:3,title:"先頭１件取得（SqlQuery#one)",slug:"先頭1件取得-sqlquery-one",charIndex:5541},{level:3,title:"先頭１件取得（SqlQuery#findOne)",slug:"先頭1件取得-sqlquery-findone",charIndex:7079},{level:3,title:"Stream取得(SqlQuery#stream)",slug:"stream取得-sqlquery-stream",charIndex:8526},{level:3,title:"ResultSet取得(SqlQuery#resultSet)",slug:"resultset取得-sqlquery-resultset",charIndex:11533},{level:2,title:"SQLによる更新(SqlAgent#update /#updateWith)",slug:"sqlによる更新-sqlagent-update-updatewith",charIndex:12292},{level:3,title:"更新の実行(SqlUpdate#count)",slug:"更新の実行-sqlupdate-count",charIndex:13171},{level:2,title:"SQLによるバッチ更新(SqlBatch#batch /#batchWith)",slug:"sqlによるバッチ更新-sqlbatch-batch-batchwith",charIndex:13725},{level:3,title:"バッチ更新の実行(SqlBatch#count)",slug:"バッチ更新の実行-sqlbatch-count",charIndex:14620},{level:3,title:"バッチSQL実行動作のカスタマイズ",slug:"バッチsql実行動作のカスタマイズ",charIndex:16256},{level:2,title:"ストアドプロシージャの実行(SqlAgent#proc /#procWith)",slug:"ストアドプロシージャの実行-sqlagent-proc-procwith",charIndex:17484},{level:3,title:"Procedureインタフェース",slug:"procedureインタフェース",charIndex:17772}],lastUpdated:"2020-3-8 21:44:34",headersStr:"SQLによる検索(SqlAgent#query /#queryWith) 検索結果の取得 リスト取得(SqlQuery#collect) 先頭取得（SqlQuery#first) 先頭取得（SqlQuery#findFirst) 先頭１件取得（SqlQuery#one) 先頭１件取得（SqlQuery#findOne) Stream取得(SqlQuery#stream) ResultSet取得(SqlQuery#resultSet) SQLによる更新(SqlAgent#update /#updateWith) 更新の実行(SqlUpdate#count) SQLによるバッチ更新(SqlBatch#batch /#batchWith) バッチ更新の実行(SqlBatch#count) バッチSQL実行動作のカスタマイズ ストアドプロシージャの実行(SqlAgent#proc /#procWith) Procedureインタフェース",content:'# SQLファイルインタフェース\n# SQLによる検索(SqlAgent#query /#queryWith)\nSQLを検索する方法は2つあります。\n\n利用メソッド                           説明                 \nSqlAgent#query("[SQL名]")         SQL名で説明したSQL名を指定   \nSqlAgent#queryWith("[SQL文字列]")   SQL文字列を直接指定        \n\n上記２つのメソッドは検索を行うためのSqlQueryインタフェースのインスタンスを返却します。\n\n// SQL名を指定\nSqlQuery query1 = agent.query("employee/select_employee");\n\n// SQL文字列を指定\nSqlQuery query2 = agent.queryWith("select first_name, last_name where employee");\n\n\n1\n2\n3\n4\n5\n# 検索結果の取得\nSqlAgentから取得したSQLQueryを使用していろいろな形式で検索結果を取得することが出来ます。\n下記のSQLを例に説明します。\n\n-- department/select_department.sql\nselect /* _SQL_ID_ */\n  dept.dept_no  as  dept_no\n,  dept.dept_name  as  dept_name\nfrom\n  department  dept\nwhere\n  1        =  1\n/*IF SF.isNotEmpty(dept_no)*/\nand  dept.dept_no  =  /*dept_no*/1\n/*END*/\n/*IF SF.isNotEmpty(dept_name)*/\nand  dept.dept_name  =  /*dept_name*/\'sample\'\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# リスト取得(SqlQuery#collect)\nメソッド名                          戻り値の型                       \nSqlQuery#collect()             List<Map<String, Object>>   \nSqlQuery#collect(CaseFormat)   List<Map<String, Object>>   \nSqlQuery#collect(Class<T>)     List<Class<T>>              \n\n検索結果をMapやエンティティクラスのListとして取得します。\nMapにはキー：カラムラベル名、値：カラムの値の形で1行分のデータが格納されます。\n\nWARNING\n\nSqlQuery#collect()では検索結果をすべてメモリ上に格納します。大量データの検索を行う場合は後述のSqlQuery#strem()の利用を検討してください。\n\n引数なし\n\ntry (SqlAgent agent = config.agent()) {\n  List<Map<String, Object>> departments =\n    agent.query("department/select_department").collect();\n}\n// 結果(departments)\n[\n {"DEPT_NO"=1, "DEPT_NAME"="sales"},\n {"DEPT_NO"=2, "DEPT_NAME"="export"},\n {"DEPT_NO"=3, "DEPT_NAME"="accounting"},\n {"DEPT_NO"=4, "DEPT_NAME"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n引数にjp.co.future.uroborosql.utils.CaseFormatを指定することで、Mapのキー名に対する書式を変更することができます。\n\nCaseFormat.CAMEL_CASE指定\n\ntry (SqlAgent agent = config.agent()) {\n  List<Map<String, Object>> departments =\n    agent.query("department/select_department").collect(CaseFormat.CAMEL_CASE);\n}\n// 結果(departments) のキーが"deptNo", "deptName"となる\n[\n {"deptNo"=1, "deptName"="sales"},\n {"deptNo"=2, "deptName"="export"},\n {"deptNo"=3, "deptName"="accounting"},\n {"deptNo"=4, "deptName"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nCaseFormatの指定がない場合はデフォルトのCaseFormat（初期設定ではUPPER_SNAKE_CASE）で加工した値になります。\nデフォルトのCaseFormatはSqlConfig生成時に変更することができます。 デフォルトCaseFormatの設定の詳細は CaseFormatの初期値設定 を参照してください\n\n引数にエンティティクラスを指定すると、検索結果をMapの代わりにエンティティクラスのインスタンスのListで取得することができます。\n\nエンティティクラス\n\n/**\n * Entity that can be mapped to department table\n */\npublic class Department {\n  private long deptNo;\n  private String deptName;\n\n  public long getDeptNo() {　return this.deptNo;　}\n  public void setDeptNo(long deptNo) {　this.deptNo = deptNo;　}\n  public String getDeptName() {　return this.deptName;　}\n  public void setDeptName(String deptName) {　this.deptName = deptName;　}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\ntry (SqlAgent agent = config.agent()) {\n  List<Department> departments =\n    agent.query("department/select_department").collect(Department.class);\n}\n\n\n1\n2\n3\n4\n# 先頭取得（SqlQuery#first)\nメソッド名                        戻り値の型                 \nSqlQuery#first()             Map<String, Object>   \nSqlQuery#first(CaseFormat)   Map<String, Object>   \nSqlQuery#first(Class<T>)     T                     \n\n検索結果の1件目を取得します。\n結果を取得できない（検索結果が0件）場合、jp.co.future.uroborosql.exception.DataNotFoundExceptionをスローします。\n\nTIP\n\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (SqlAgent agent = config.agent()) {\n  Map<String, Object> department =\n    agent.query("department/select_department").first();\n} catch (DataNotFoundException ex) {\n  ex.printStackTrace();\n}\n\n// 結果(department)\n {"DEPT_NO"=1, "DEPT_NAME"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にjp.co.future.uroborosql.utils.CaseFormatを指定することで、Mapのキー名に対する書式を変更することができます。\n\nCaseFormat.CAMEL_CASE指定\n\ntry (SqlAgent agent = config.agent()) {\n  Map<String, Object> department =\n    agent.query("department/select_department").first(CaseFormat.CAMEL_CASE);\n} catch (DataNotFoundException ex) {\n  ex.printStackTrace();\n}\n// 結果(department)\n {"deptNo"=1, "deptName"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (SqlAgent agent = config.agent()) {\n  Department department =\n    agent.query("department/select_department").first(Department.class);\n} catch (DataNotFoundException ex) {\n  ex.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n# 先頭取得（SqlQuery#findFirst)\nメソッド名                            戻り値の型                           \nSqlQuery#findFirst()             Optional<Map<String, Object>>   \nSqlQuery#findFirst(CaseFormat)   Optional<Map<String, Object>>   \nSqlQuery#findFirst(Class<T>)     Optional<T>                     \n\n検索結果の1件目をOptionalの形式で取得します。\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (SqlAgent agent = config.agent()) {\n  Optional<Map<String, Object>> department =\n    agent.query("department/select_department").findFirst();\n}\n// 結果(department)\n {"DEPT_NO"=1, "DEPT_NAME"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n引数にjp.co.future.uroborosql.utils.CaseFormatを指定することで、Mapのキー名に対する書式を変更することができます。\n\nCaseFormat.CAMEL_CASE指定\n\ntry (SqlAgent agent = config.agent()) {\n  Optional<Map<String, Object>> department =\n    agent.query("department/select_department").findFirst(CaseFormat.CAMEL_CASE);\n}\n// 結果(department)\n {"deptNo"=1, "deptName"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (SqlAgent agent = config.agent()) {\n  Department department =\n    agent.query("department/select_department").findFirst(Department.class).orElse(null);\n}\n\n\n1\n2\n3\n4\n# 先頭１件取得（SqlQuery#one)\nメソッド名                      戻り値の型                 \nSqlQuery#one()             Map<String, Object>   \nSqlQuery#one(CaseFormat)   Map<String, Object>   \nSqlQuery#one(Class<T>)     T                     \n\n検索結果の1件目を取得します。find()と違い、実行するSQLで複数件の検索結果を返す場合は例外をスローします。\n結果を取得できない（検索結果が0件）場合、jp.co.future.uroborosql.exception.DataNotFoundExceptionをスローします。\n検索結果が2件以上存在する場合、jp.co.future.uroborosql.exception.DataNotUniqueExceptionをスローします。\n\nTIP\n\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (SqlAgent agent = config.agent()) {\n  Map<String, Object> department =\n    agent.query("department/select_department").one();\n} catch (DataNotFoundException | DataNotUniqueException ex) {\n  ex.printStackTrace();\n}\n\n// 結果(department)\n {"DEPT_NO"=1, "DEPT_NAME"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にjp.co.future.uroborosql.utils.CaseFormatを指定することで、Mapのキー名に対する書式を変更することができます。\n\nCaseFormat.CAMEL_CASE指定\n\ntry (SqlAgent agent = config.agent()) {\n  Map<String, Object> department =\n    agent.query("department/select_department").one(CaseFormat.CAMEL_CASE);\n} catch (DataNotFoundException | DataNotUniqueException ex) {\n  ex.printStackTrace();\n}\n// 結果(department)\n {"deptNo"=1, "deptName"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (SqlAgent agent = config.agent()) {\n  Department department =\n    agent.query("department/select_department").one(Department.class);\n} catch (DataNotFoundException | DataNotUniqueException ex) {\n  ex.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n# 先頭１件取得（SqlQuery#findOne)\nメソッド名                          戻り値の型                           \nSqlQuery#findOne()             Optional<Map<String, Object>>   \nSqlQuery#findOne(CaseFormat)   Optional<Map<String, Object>>   \nSqlQuery#findOne(Class<T>)     Optional<T>                     \n\n検索結果の1件目をOptionalの形式で取得します。\n検索結果が2件以上存在する場合、jp.co.future.uroborosql.exception.DataNotUniqueExceptionをスローします。\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (SqlAgent agent = config.agent()) {\n  Optional<Map<String, Object>> department =\n    agent.query("department/select_department").findOne();\n} catch (DataNotUniqueException ex) {\n  ex.printStackTrace();\n}\n// 結果(department)\n {"DEPT_NO"=1, "DEPT_NAME"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にjp.co.future.uroborosql.utils.CaseFormatを指定することで、Mapのキー名に対する書式を変更することができます。\n\nCaseFormat.CAMEL_CASE指定\n\ntry (SqlAgent agent = config.agent()) {\n  Optional<Map<String, Object>> department =\n    agent.query("department/select_department").findOne(CaseFormat.CAMEL_CASE);\n} catch (DataNotUniqueException ex) {\n  ex.printStackTrace();\n}\n// 結果(department)\n {"deptNo"=1, "deptName"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (SqlAgent agent = config.agent()) {\n  Department department =\n    agent.query("department/select_department").findOne(Department.class).orElse(null);\n} catch (DataNotUniqueException ex) {\n  ex.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n# Stream取得(SqlQuery#stream)\nメソッド名                                    戻り値の型                         \nSqlQuery#stream()                        Stream<Map<String, Object>>   \nSqlQuery#stream(CaseFormat)              Stream<Map<String, Object>>   \nSqlQuery#stream(Class<T>)                Stream<T>                     \nSqlQuery#stream(ResultSetConverter<T>)   Stream<T>                     \n\n検索結果をjava.util.stream.Streamの形式で取得します。\nStreamによる順次読み込みと終端操作までの遅延処理により、メモリ効率の良い操作が可能になります。\n\n引数なし\n\ntry (SqlAgent agent = config.agent()) {\n  agent.query("department/select_department").stream()\n    .forEach(System.out::println);\n}\n// 結果\n{"DEPT_NO"=1, "DEPT_NAME"="sales"}\n{"DEPT_NO"=2, "DEPT_NAME"="export"}\n{"DEPT_NO"=3, "DEPT_NAME"="accounting"}\n{"DEPT_NO"=4, "DEPT_NAME"="personnel"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にjp.co.future.uroborosql.utils.CaseFormatを指定することで、Mapのキー名に対する書式を変更することができます。\n\nCaseFormat.PASCAL_CASE指定\n\ntry (SqlAgent agent = config.agent()) {\n  agent.query("department/select_department").stream(CaseFormat.PASCAL_CASE)\n    .forEach(System.out::println);\n}\n// 結果\n{"DeptNo"=1, "DeptName"="sales"}\n{"DeptNo"=2, "DeptName"="export"}\n{"DeptNo"=3, "DeptName"="accounting"}\n{"DeptNo"=4, "DeptName"="personnel"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (SqlAgent agent = config.agent()) {\n  agent.query("department/select_department").stream(Department.class)\n    .forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\njp.co.future.uroborosql.converter.ResultSetConverterインタフェースを実装したクラスを引数に渡すことで、検索結果により複雑な加工を行うことができます。\nResultSetConverterはFunctionInterfaceとして提供されているので、lambda式による記述も可能です。\n\nResultSetConverter指定(lambda式)\n\ntry (SqlAgent agent = config.agent()) {\n  // ResultSetConverterはlambda式で指定可能\n  agent.query("department/select_department").stream(rs -> {\n    Map<String, Object> row = new HashMap<>();\n    row.put("deptNo", rs.getObject("DEPT_NO"));\n    row.put("deptName", rs.getObject("DEPT_NAME"));\n    return row;\n  }).forEach(System.out::println);\n}\n// 結果\n{"deptNo"=1, "deptName"="sales"}\n{"deptNo"=2, "deptName"="export"}\n{"deptNo"=3, "deptName"="accounting"}\n{"deptNo"=4, "deptName"="personnel"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n注意\n\n戻り値として取得されるStreamインスタンスは内部にResultSetリソースを保持しています。このResultSetはデータを最後まで読み込むかStream#close()が呼ばれたタイミングでリソースのクローズを行います。(Stream生成時、Stream#onClose()にResultSetリソースのcloseHandlerを登録します)\nそのため、取得したStreamで全データを扱う終端処理(collectなど)を行うか、try-with-resourcesの利用やStream#close()の明示的な呼び出しによるStreamのクローズを行わないとResultSetリソースがクローズされずカーソルのリークが発生します。\n\n注意\n\n取得したStreamのクローズより先にSqlAgentインスタンスがクローズ、または破棄された場合、Streamの内部に保持しているResultSetリソースもクローズされてしまい不正な動作となります。StreamインスタンスとそのStreamを生成したSqlAgentインスタンスの生存期間を合わせる、もしくはSqlAgentインスタンスの生存期間を長くしてください。\n\nStreamのクローズ\n\ntry (SqlAgent agent = config.agent()) {\n  try (Stream<Map<String, Object>> stream = agent.query("department/select_department").stream()) {\n    // Stream#findFirst() はStream内のResultSetリソースをクローズしないので、try-with-resourcesでStreamをクローズする\n    stream.findFirst().ifPresent(System.out::println);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n# ResultSet取得(SqlQuery#resultSet)\nメソッド名                  戻り値の型        \nSqlQuery#resultSet()   ResulitSet   \n\n検索結果をjava.sql.ResultSetの形式で取得します。\n\n注意\n\nResultSetリソースのクローズは各自で行う必要があります。\n\n注意\n\nResultSetリソースのクローズより先にSqlAgentインスタンスがクローズ、または破棄された場合、ResultSetリソースもクローズされてしまい不正な動作となります。ResultSetリソースとそのResultSetを生成したSqlAgentインスタンスの生存期間を合わせる、もしくはSqlAgentインスタンスの生存期間を長くしてください。\n\nこのAPIは他のフレームワークとの連携など、ResultSetリソースの取得が必要なケースを想定して提供しています。\n\nWARNING\n\nResultSetリソースの取得が必要でなければ、ResultSetリソースのクローズが管理されている他のAPIの利用を検討してください。\n\ntry (SqlAgent agent = config.agent()) {\n  try (ResultSet rs = agent.query("department/select_department").resultSet()) {\n    // try-with-resourcesでResultSetをクローズする\n    while (rs.next()) {\n      // ResultSetからの値取得\n      ・・・\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# SQLによる更新(SqlAgent#update /#updateWith)\nDB更新処理(登録/変更/削除)やDDLの実行も検索処理と同様SQL名を指定する場合とSQL文字列を指定する２つのAPIが提供されています。\n\n利用メソッド                            説明                 \nSqlAgent#update("[SQL名]")         SQL名で説明したSQL名を指定   \nSqlAgent#updateWith("[SQL文字列]")   SQL文字列を直接指定        \n\n上記２つのメソッドは更新を行うためのSqlUpdateインタフェースのインスタンスを返却します。\n\n// １件挿入(SQL名指定)\nint count = agent.update("department/insert_department")\n  .param("dept_no", 1)\n  .param("dept_name", "Sales")\n  .count();\n\n// 更新(SQL文字列指定)\nint count = agent.updateWith("update employee set first_name = /*first_name*/ where emp_no = /*emp_no*/")\n  .param("emp_no", 1)\n  .param("first_name", "Bob")\n  .count();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\ndepartment/insert_department.sql\n\ninsert /* _SQL_ID_ */\ninto\n  department\n(\n  dept_name\n, lock_version\n) values (\n  /*dept_name*/\'sample\'\n,  0\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nSqlUpdateインタフェースの主なAPIは以下になります。\n\n# 更新の実行(SqlUpdate#count)\nメソッド名               戻り値の型   \nSqlUpdate#count()   int     \n\n更新処理を行い、登録、更新、削除を行った行数を返します。\n\ntry (SqlAgent agent = config.agent()) {\n  // insert\n  agent.update("department/insert_department")\n    .param("dept_no", 1)\n    .param("dept_name", "sales")\n    .count();\n  // update\n  agent.update("department/update_department")\n    .param("dept_no", 1)\n    .param("dept_name", "HR")\n    .count();\n  // delete\n  agent.update("department/delete_department")\n    .param("dept_no", 1)\n    .count();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# SQLによるバッチ更新(SqlBatch#batch /#batchWith)\n大量のデータを一括で更新する場合、通常の更新ではSQLが都度実行されるため処理速度が遅く問題になる場合があります。\nこういったケースに対応するため、uroboroSQLではバッチ更新用のAPIを提供しています。\n\nバッチ更新処理も他と同様SQL名を指定する場合とSQL文字列を直接記述する２つのAPIが提供されています。\n\n利用メソッド                           説明                 \nSqlAgent#batch("[SQL名]")         SQL名で説明したSQL名を指定   \nSqlAgent#batchWith("[SQL文字列]")   SQL文字列を直接指定        \n\n上記２つのメソッドはバッチ更新を行うためのSqlBatchインタフェースのインスタンスを返却します。\n\nSqlBatchインタフェースでは、SqlFluentインタフェースによるバインドパラメータの設定とは別にjava.util.stream.Streamを用いたバッチパラメータの設定を行うAPIが提供されています。\n\nメソッド                                                説明                                                                    \nSqlBatch#paramStream(Stream<Map<String, Object>>)   バインドパラメータや置換文字列として使用するキーと値のセットをjava.util.stream.Streamで設定する。          \nSqlBatch#paramStream(Stream<E>)                     バインドパラメータや置換文字列として使用するエンティティクラスインスタンスをjava.util.stream.Streamで設定する。   \n\n# バッチ更新の実行(SqlBatch#count)\nメソッド名              戻り値の型   \nSqlBatch#count()   int     \n\nバッチ更新処理を行い、登録、更新、削除を行った行数を返します。\n\nバッチ更新\n\n// バッチ処理の実行\nint count = agent.batch("department/insert_department")\n  // 指定したファイルからMap<String, Object>のStreamを生成し、バッチ処理のパラメータとして指定する\n  .paramStream(getDataByFile(Paths.get("data/department.tsv")))\n  .count();\n\n・・・\n\nprivate Stream<Map<String, Object>> getDataByFile(final Path filePath) {\n  try {\n    final List<String> lines = Files.readAllLines(filePath);\n    final String[] header = lines.get(0).split("\\\\t");\n    return lines.stream()\n        .skip(1)\n        .map(s -> s.split("\\\\t"))\n        .map(data -> IntStream.range(0, header.length)\n            .<Map<String, Object>> collect(HashMap::new, (row, i) -> row.put(header[i], data[i]),\n                Map::putAll));\n  } catch (IOException e) {\n    e.printStackTrace();\n    throw new UncheckedIOException(e);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\ndata/department.tsv の内容\n\ndept_no  dept_name\n1  sales\n2  export\n3  accounting\n4  personnel\n\n\n1\n2\n3\n4\n5\nparamStream()メソッドにSqlQuery#stream()の結果を指定することで疑似的にSELECT-INSERT / SELECT-UPDATE / SELECT-DELETEを行うことができます。\nStream APIを利用することで検索結果の件数が多い場合でも、少ないメモリ使用量でバッチ処理を行うことができます。\n\nSELECT-UPDATE\n\nint updateCount = agent.batch("department/update_department")\n  .paramStream(agent.query("department/select_department")\n    .stream(CaseFormat.LOWER_SNAKE_CASE).map(e -> {\n      Map<String, Object> ans = new HashMap<>(e);\n      ans.replaceAll((k, v) -> v != null ? v.toString() + "_after" : "after"); // 取得した検索結果の各行の値に "_after" を付与する\n      return ans;\n    }))\n  .count();\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# バッチSQL実行動作のカスタマイズ\nSqlBatchインタフェースにはバッチSQL実行時の動作を変更するためのAPIが提供されています。\n\nメソッド                                                      説明                                                       デフォルト値                             \nby(BiPredicate<SqlContext, Map<String, Object>>)          バッチSQLの実行条件を指定します。BiPredicateの結果がtrueの場合にバッチSQLを実行します。   1000件毎                             \nbatchWhen(BiConsumer<SqlAgent, SqlContext>)               バッチSQLの実行タイミングで行う操作を指定します。                               何もしない                              \nerrorWhen(TriConsumer<SqlAgent, SqlContext, Exception>)   バッチSQLの実行時に例外が発生した時の動作を指定します。                            UroborosqlRuntimeExceptionをスローする   \n\nこれらのAPIを利用することでより柔軟なSQL実行が可能になります。\n\nバッチSQL実行時動作のカスタマイズ例\n\nList<Map<String, Object>> inputData = new ArrayList<>();\n// 中略　入力データ作成\n\ntry (SqlAgent agent = config.agent()) {\n  agent.batch("department/insert_department")\n    .paramStream(inputData.stream())\n    .by((ctx, row) -> ctx.batchCount() == 10)  // 10件毎にSQL実行\n    .batchWhen((agent, ctx) -> agent.commit())  // SQL実行が成功したらコミットする\n    .errorWhen((agent, ctx, ex) -> {\n      log.error("error occured. ex:{}", ex.getMessage());\n    })  // 例外が発生したらログ出力する\n    .count();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# ストアドプロシージャの実行(SqlAgent#proc /#procWith)\nuroboroSQLでは、SQLの検索/更新のほかDBが提供するストアドプロシージャの呼び出し用APIも提供しています。\n\n利用メソッド                          説明                 \nSqlAgent#proc("[SQL名]")         SQL名で説明したSQL名を指定   \nSqlAgent#procWith("[SQL文字列]")   SQL文字列を直接指定        \n\n上記２つのメソッドはストアドプロシージャの呼出を行うためのProcedureインタフェースのインスタンスを返却します。\n\n# Procedureインタフェース\nメソッド名              戻り値の型                 \nProcedure#call()   Map<String, Object>   \n\nProcedureインタフェースでは、ストアドプロシージャからの戻り値を取得するためのAPIが提供されています。\n\nメソッド                                                  説明                                                                                               \nProcedureFluent#outParam(String, int)                 ストアドプロシージャからの戻り値として受け取るパラメータを指定します                                                               \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のMap<String, Object>に格納されて取得できます。第2引数で受け取る値の型をint型で指定します       \nProcedureFluent#outParam(String, SQLType)             ストアドプロシージャからの戻り値として受け取るパラメータを指定します                                                               \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のMap<String, Object>に格納されて取得できます。第2引数で受け取る値の型をSQLType型で指定します   \nProcedureFluent#inOutParam(String, int)               ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のMap<String, Object>に格納されて取得できます。第2引数で受け取る値の型をint型で指定します       \nProcedureFluent#inOutParam(String, SQLType)           ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のMap<String, Object>に格納されて取得できます。第2引数で受け取る値の型をSQLType型で指定します   \nProcedureFluent#inOutParamIfAbsent(String, int)       ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      指定したパラメータ名のパラメータが事前に登録されていない場合に値を追加します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のMap<String, Object>に格納されて取得できます。第2引数で受け取る値の型をint型で指定します       \nProcedureFluent#inOutParamIfAbsent(String, SQLType)   ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      指定したパラメータ名のパラメータが事前に登録されていない場合に値を追加します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のMap<String, Object>に格納されて取得できます。第2引数で受け取る値の型をSQLType型で指定します   \n\n// Procedureインタフェースのインスタンスを取得\nMap<String, Object> result = agent.procWith("{call product_id_exist_check(/*product_id*/, /*check_out*/)}")\n  .param("product_id", 0)\n  .outParam("check_out", java.sql.JDBCType.NUMERIC)\n  .call();\n// outParamメソッドで指定したパラメータの値(戻り値)を取得\nBigDecimal checkOut = (BigDecimal)result.get("check_out");\n\n\n1\n2\n3\n4\n5\n6\n7',contentLowercase:'# sqlファイルインタフェース\n# sqlによる検索(sqlagent#query /#querywith)\nsqlを検索する方法は2つあります。\n\n利用メソッド                           説明                 \nsqlagent#query("[sql名]")         sql名で説明したsql名を指定   \nsqlagent#querywith("[sql文字列]")   sql文字列を直接指定        \n\n上記２つのメソッドは検索を行うためのsqlqueryインタフェースのインスタンスを返却します。\n\n// sql名を指定\nsqlquery query1 = agent.query("employee/select_employee");\n\n// sql文字列を指定\nsqlquery query2 = agent.querywith("select first_name, last_name where employee");\n\n\n1\n2\n3\n4\n5\n# 検索結果の取得\nsqlagentから取得したsqlqueryを使用していろいろな形式で検索結果を取得することが出来ます。\n下記のsqlを例に説明します。\n\n-- department/select_department.sql\nselect /* _sql_id_ */\n  dept.dept_no  as  dept_no\n,  dept.dept_name  as  dept_name\nfrom\n  department  dept\nwhere\n  1        =  1\n/*if sf.isnotempty(dept_no)*/\nand  dept.dept_no  =  /*dept_no*/1\n/*end*/\n/*if sf.isnotempty(dept_name)*/\nand  dept.dept_name  =  /*dept_name*/\'sample\'\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# リスト取得(sqlquery#collect)\nメソッド名                          戻り値の型                       \nsqlquery#collect()             list<map<string, object>>   \nsqlquery#collect(caseformat)   list<map<string, object>>   \nsqlquery#collect(class<t>)     list<class<t>>              \n\n検索結果をmapやエンティティクラスのlistとして取得します。\nmapにはキー：カラムラベル名、値：カラムの値の形で1行分のデータが格納されます。\n\nwarning\n\nsqlquery#collect()では検索結果をすべてメモリ上に格納します。大量データの検索を行う場合は後述のsqlquery#strem()の利用を検討してください。\n\n引数なし\n\ntry (sqlagent agent = config.agent()) {\n  list<map<string, object>> departments =\n    agent.query("department/select_department").collect();\n}\n// 結果(departments)\n[\n {"dept_no"=1, "dept_name"="sales"},\n {"dept_no"=2, "dept_name"="export"},\n {"dept_no"=3, "dept_name"="accounting"},\n {"dept_no"=4, "dept_name"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n引数にjp.co.future.uroborosql.utils.caseformatを指定することで、mapのキー名に対する書式を変更することができます。\n\ncaseformat.camel_case指定\n\ntry (sqlagent agent = config.agent()) {\n  list<map<string, object>> departments =\n    agent.query("department/select_department").collect(caseformat.camel_case);\n}\n// 結果(departments) のキーが"deptno", "deptname"となる\n[\n {"deptno"=1, "deptname"="sales"},\n {"deptno"=2, "deptname"="export"},\n {"deptno"=3, "deptname"="accounting"},\n {"deptno"=4, "deptname"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\ncaseformatの指定がない場合はデフォルトのcaseformat（初期設定ではupper_snake_case）で加工した値になります。\nデフォルトのcaseformatはsqlconfig生成時に変更することができます。 デフォルトcaseformatの設定の詳細は caseformatの初期値設定 を参照してください\n\n引数にエンティティクラスを指定すると、検索結果をmapの代わりにエンティティクラスのインスタンスのlistで取得することができます。\n\nエンティティクラス\n\n/**\n * entity that can be mapped to department table\n */\npublic class department {\n  private long deptno;\n  private string deptname;\n\n  public long getdeptno() {　return this.deptno;　}\n  public void setdeptno(long deptno) {　this.deptno = deptno;　}\n  public string getdeptname() {　return this.deptname;　}\n  public void setdeptname(string deptname) {　this.deptname = deptname;　}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\ntry (sqlagent agent = config.agent()) {\n  list<department> departments =\n    agent.query("department/select_department").collect(department.class);\n}\n\n\n1\n2\n3\n4\n# 先頭取得（sqlquery#first)\nメソッド名                        戻り値の型                 \nsqlquery#first()             map<string, object>   \nsqlquery#first(caseformat)   map<string, object>   \nsqlquery#first(class<t>)     t                     \n\n検索結果の1件目を取得します。\n結果を取得できない（検索結果が0件）場合、jp.co.future.uroborosql.exception.datanotfoundexceptionをスローします。\n\ntip\n\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (sqlagent agent = config.agent()) {\n  map<string, object> department =\n    agent.query("department/select_department").first();\n} catch (datanotfoundexception ex) {\n  ex.printstacktrace();\n}\n\n// 結果(department)\n {"dept_no"=1, "dept_name"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にjp.co.future.uroborosql.utils.caseformatを指定することで、mapのキー名に対する書式を変更することができます。\n\ncaseformat.camel_case指定\n\ntry (sqlagent agent = config.agent()) {\n  map<string, object> department =\n    agent.query("department/select_department").first(caseformat.camel_case);\n} catch (datanotfoundexception ex) {\n  ex.printstacktrace();\n}\n// 結果(department)\n {"deptno"=1, "deptname"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (sqlagent agent = config.agent()) {\n  department department =\n    agent.query("department/select_department").first(department.class);\n} catch (datanotfoundexception ex) {\n  ex.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n# 先頭取得（sqlquery#findfirst)\nメソッド名                            戻り値の型                           \nsqlquery#findfirst()             optional<map<string, object>>   \nsqlquery#findfirst(caseformat)   optional<map<string, object>>   \nsqlquery#findfirst(class<t>)     optional<t>                     \n\n検索結果の1件目をoptionalの形式で取得します。\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (sqlagent agent = config.agent()) {\n  optional<map<string, object>> department =\n    agent.query("department/select_department").findfirst();\n}\n// 結果(department)\n {"dept_no"=1, "dept_name"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n引数にjp.co.future.uroborosql.utils.caseformatを指定することで、mapのキー名に対する書式を変更することができます。\n\ncaseformat.camel_case指定\n\ntry (sqlagent agent = config.agent()) {\n  optional<map<string, object>> department =\n    agent.query("department/select_department").findfirst(caseformat.camel_case);\n}\n// 結果(department)\n {"deptno"=1, "deptname"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (sqlagent agent = config.agent()) {\n  department department =\n    agent.query("department/select_department").findfirst(department.class).orelse(null);\n}\n\n\n1\n2\n3\n4\n# 先頭１件取得（sqlquery#one)\nメソッド名                      戻り値の型                 \nsqlquery#one()             map<string, object>   \nsqlquery#one(caseformat)   map<string, object>   \nsqlquery#one(class<t>)     t                     \n\n検索結果の1件目を取得します。find()と違い、実行するsqlで複数件の検索結果を返す場合は例外をスローします。\n結果を取得できない（検索結果が0件）場合、jp.co.future.uroborosql.exception.datanotfoundexceptionをスローします。\n検索結果が2件以上存在する場合、jp.co.future.uroborosql.exception.datanotuniqueexceptionをスローします。\n\ntip\n\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (sqlagent agent = config.agent()) {\n  map<string, object> department =\n    agent.query("department/select_department").one();\n} catch (datanotfoundexception | datanotuniqueexception ex) {\n  ex.printstacktrace();\n}\n\n// 結果(department)\n {"dept_no"=1, "dept_name"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にjp.co.future.uroborosql.utils.caseformatを指定することで、mapのキー名に対する書式を変更することができます。\n\ncaseformat.camel_case指定\n\ntry (sqlagent agent = config.agent()) {\n  map<string, object> department =\n    agent.query("department/select_department").one(caseformat.camel_case);\n} catch (datanotfoundexception | datanotuniqueexception ex) {\n  ex.printstacktrace();\n}\n// 結果(department)\n {"deptno"=1, "deptname"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (sqlagent agent = config.agent()) {\n  department department =\n    agent.query("department/select_department").one(department.class);\n} catch (datanotfoundexception | datanotuniqueexception ex) {\n  ex.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n# 先頭１件取得（sqlquery#findone)\nメソッド名                          戻り値の型                           \nsqlquery#findone()             optional<map<string, object>>   \nsqlquery#findone(caseformat)   optional<map<string, object>>   \nsqlquery#findone(class<t>)     optional<t>                     \n\n検索結果の1件目をoptionalの形式で取得します。\n検索結果が2件以上存在する場合、jp.co.future.uroborosql.exception.datanotuniqueexceptionをスローします。\nメモリ上には最大1件分のデータしか格納しないため、検索結果が大量になる場合でもメモリ使用量を気にせず呼び出すことができます。\n\n引数なし\n\ntry (sqlagent agent = config.agent()) {\n  optional<map<string, object>> department =\n    agent.query("department/select_department").findone();\n} catch (datanotuniqueexception ex) {\n  ex.printstacktrace();\n}\n// 結果(department)\n {"dept_no"=1, "dept_name"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にjp.co.future.uroborosql.utils.caseformatを指定することで、mapのキー名に対する書式を変更することができます。\n\ncaseformat.camel_case指定\n\ntry (sqlagent agent = config.agent()) {\n  optional<map<string, object>> department =\n    agent.query("department/select_department").findone(caseformat.camel_case);\n} catch (datanotuniqueexception ex) {\n  ex.printstacktrace();\n}\n// 結果(department)\n {"deptno"=1, "deptname"="sales"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (sqlagent agent = config.agent()) {\n  department department =\n    agent.query("department/select_department").findone(department.class).orelse(null);\n} catch (datanotuniqueexception ex) {\n  ex.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n# stream取得(sqlquery#stream)\nメソッド名                                    戻り値の型                         \nsqlquery#stream()                        stream<map<string, object>>   \nsqlquery#stream(caseformat)              stream<map<string, object>>   \nsqlquery#stream(class<t>)                stream<t>                     \nsqlquery#stream(resultsetconverter<t>)   stream<t>                     \n\n検索結果をjava.util.stream.streamの形式で取得します。\nstreamによる順次読み込みと終端操作までの遅延処理により、メモリ効率の良い操作が可能になります。\n\n引数なし\n\ntry (sqlagent agent = config.agent()) {\n  agent.query("department/select_department").stream()\n    .foreach(system.out::println);\n}\n// 結果\n{"dept_no"=1, "dept_name"="sales"}\n{"dept_no"=2, "dept_name"="export"}\n{"dept_no"=3, "dept_name"="accounting"}\n{"dept_no"=4, "dept_name"="personnel"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にjp.co.future.uroborosql.utils.caseformatを指定することで、mapのキー名に対する書式を変更することができます。\n\ncaseformat.pascal_case指定\n\ntry (sqlagent agent = config.agent()) {\n  agent.query("department/select_department").stream(caseformat.pascal_case)\n    .foreach(system.out::println);\n}\n// 結果\n{"deptno"=1, "deptname"="sales"}\n{"deptno"=2, "deptname"="export"}\n{"deptno"=3, "deptname"="accounting"}\n{"deptno"=4, "deptname"="personnel"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n引数にエンティティクラスを指定すると、検索結果をエンティティクラスのインスタンスの形で取得することができます。\n\nエンティティクラス\n\ntry (sqlagent agent = config.agent()) {\n  agent.query("department/select_department").stream(department.class)\n    .foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\njp.co.future.uroborosql.converter.resultsetconverterインタフェースを実装したクラスを引数に渡すことで、検索結果により複雑な加工を行うことができます。\nresultsetconverterはfunctioninterfaceとして提供されているので、lambda式による記述も可能です。\n\nresultsetconverter指定(lambda式)\n\ntry (sqlagent agent = config.agent()) {\n  // resultsetconverterはlambda式で指定可能\n  agent.query("department/select_department").stream(rs -> {\n    map<string, object> row = new hashmap<>();\n    row.put("deptno", rs.getobject("dept_no"));\n    row.put("deptname", rs.getobject("dept_name"));\n    return row;\n  }).foreach(system.out::println);\n}\n// 結果\n{"deptno"=1, "deptname"="sales"}\n{"deptno"=2, "deptname"="export"}\n{"deptno"=3, "deptname"="accounting"}\n{"deptno"=4, "deptname"="personnel"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n注意\n\n戻り値として取得されるstreamインスタンスは内部にresultsetリソースを保持しています。このresultsetはデータを最後まで読み込むかstream#close()が呼ばれたタイミングでリソースのクローズを行います。(stream生成時、stream#onclose()にresultsetリソースのclosehandlerを登録します)\nそのため、取得したstreamで全データを扱う終端処理(collectなど)を行うか、try-with-resourcesの利用やstream#close()の明示的な呼び出しによるstreamのクローズを行わないとresultsetリソースがクローズされずカーソルのリークが発生します。\n\n注意\n\n取得したstreamのクローズより先にsqlagentインスタンスがクローズ、または破棄された場合、streamの内部に保持しているresultsetリソースもクローズされてしまい不正な動作となります。streamインスタンスとそのstreamを生成したsqlagentインスタンスの生存期間を合わせる、もしくはsqlagentインスタンスの生存期間を長くしてください。\n\nstreamのクローズ\n\ntry (sqlagent agent = config.agent()) {\n  try (stream<map<string, object>> stream = agent.query("department/select_department").stream()) {\n    // stream#findfirst() はstream内のresultsetリソースをクローズしないので、try-with-resourcesでstreamをクローズする\n    stream.findfirst().ifpresent(system.out::println);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n# resultset取得(sqlquery#resultset)\nメソッド名                  戻り値の型        \nsqlquery#resultset()   resulitset   \n\n検索結果をjava.sql.resultsetの形式で取得します。\n\n注意\n\nresultsetリソースのクローズは各自で行う必要があります。\n\n注意\n\nresultsetリソースのクローズより先にsqlagentインスタンスがクローズ、または破棄された場合、resultsetリソースもクローズされてしまい不正な動作となります。resultsetリソースとそのresultsetを生成したsqlagentインスタンスの生存期間を合わせる、もしくはsqlagentインスタンスの生存期間を長くしてください。\n\nこのapiは他のフレームワークとの連携など、resultsetリソースの取得が必要なケースを想定して提供しています。\n\nwarning\n\nresultsetリソースの取得が必要でなければ、resultsetリソースのクローズが管理されている他のapiの利用を検討してください。\n\ntry (sqlagent agent = config.agent()) {\n  try (resultset rs = agent.query("department/select_department").resultset()) {\n    // try-with-resourcesでresultsetをクローズする\n    while (rs.next()) {\n      // resultsetからの値取得\n      ・・・\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# sqlによる更新(sqlagent#update /#updatewith)\ndb更新処理(登録/変更/削除)やddlの実行も検索処理と同様sql名を指定する場合とsql文字列を指定する２つのapiが提供されています。\n\n利用メソッド                            説明                 \nsqlagent#update("[sql名]")         sql名で説明したsql名を指定   \nsqlagent#updatewith("[sql文字列]")   sql文字列を直接指定        \n\n上記２つのメソッドは更新を行うためのsqlupdateインタフェースのインスタンスを返却します。\n\n// １件挿入(sql名指定)\nint count = agent.update("department/insert_department")\n  .param("dept_no", 1)\n  .param("dept_name", "sales")\n  .count();\n\n// 更新(sql文字列指定)\nint count = agent.updatewith("update employee set first_name = /*first_name*/ where emp_no = /*emp_no*/")\n  .param("emp_no", 1)\n  .param("first_name", "bob")\n  .count();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\ndepartment/insert_department.sql\n\ninsert /* _sql_id_ */\ninto\n  department\n(\n  dept_name\n, lock_version\n) values (\n  /*dept_name*/\'sample\'\n,  0\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nsqlupdateインタフェースの主なapiは以下になります。\n\n# 更新の実行(sqlupdate#count)\nメソッド名               戻り値の型   \nsqlupdate#count()   int     \n\n更新処理を行い、登録、更新、削除を行った行数を返します。\n\ntry (sqlagent agent = config.agent()) {\n  // insert\n  agent.update("department/insert_department")\n    .param("dept_no", 1)\n    .param("dept_name", "sales")\n    .count();\n  // update\n  agent.update("department/update_department")\n    .param("dept_no", 1)\n    .param("dept_name", "hr")\n    .count();\n  // delete\n  agent.update("department/delete_department")\n    .param("dept_no", 1)\n    .count();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# sqlによるバッチ更新(sqlbatch#batch /#batchwith)\n大量のデータを一括で更新する場合、通常の更新ではsqlが都度実行されるため処理速度が遅く問題になる場合があります。\nこういったケースに対応するため、uroborosqlではバッチ更新用のapiを提供しています。\n\nバッチ更新処理も他と同様sql名を指定する場合とsql文字列を直接記述する２つのapiが提供されています。\n\n利用メソッド                           説明                 \nsqlagent#batch("[sql名]")         sql名で説明したsql名を指定   \nsqlagent#batchwith("[sql文字列]")   sql文字列を直接指定        \n\n上記２つのメソッドはバッチ更新を行うためのsqlbatchインタフェースのインスタンスを返却します。\n\nsqlbatchインタフェースでは、sqlfluentインタフェースによるバインドパラメータの設定とは別にjava.util.stream.streamを用いたバッチパラメータの設定を行うapiが提供されています。\n\nメソッド                                                説明                                                                    \nsqlbatch#paramstream(stream<map<string, object>>)   バインドパラメータや置換文字列として使用するキーと値のセットをjava.util.stream.streamで設定する。          \nsqlbatch#paramstream(stream<e>)                     バインドパラメータや置換文字列として使用するエンティティクラスインスタンスをjava.util.stream.streamで設定する。   \n\n# バッチ更新の実行(sqlbatch#count)\nメソッド名              戻り値の型   \nsqlbatch#count()   int     \n\nバッチ更新処理を行い、登録、更新、削除を行った行数を返します。\n\nバッチ更新\n\n// バッチ処理の実行\nint count = agent.batch("department/insert_department")\n  // 指定したファイルからmap<string, object>のstreamを生成し、バッチ処理のパラメータとして指定する\n  .paramstream(getdatabyfile(paths.get("data/department.tsv")))\n  .count();\n\n・・・\n\nprivate stream<map<string, object>> getdatabyfile(final path filepath) {\n  try {\n    final list<string> lines = files.readalllines(filepath);\n    final string[] header = lines.get(0).split("\\\\t");\n    return lines.stream()\n        .skip(1)\n        .map(s -> s.split("\\\\t"))\n        .map(data -> intstream.range(0, header.length)\n            .<map<string, object>> collect(hashmap::new, (row, i) -> row.put(header[i], data[i]),\n                map::putall));\n  } catch (ioexception e) {\n    e.printstacktrace();\n    throw new uncheckedioexception(e);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\ndata/department.tsv の内容\n\ndept_no  dept_name\n1  sales\n2  export\n3  accounting\n4  personnel\n\n\n1\n2\n3\n4\n5\nparamstream()メソッドにsqlquery#stream()の結果を指定することで疑似的にselect-insert / select-update / select-deleteを行うことができます。\nstream apiを利用することで検索結果の件数が多い場合でも、少ないメモリ使用量でバッチ処理を行うことができます。\n\nselect-update\n\nint updatecount = agent.batch("department/update_department")\n  .paramstream(agent.query("department/select_department")\n    .stream(caseformat.lower_snake_case).map(e -> {\n      map<string, object> ans = new hashmap<>(e);\n      ans.replaceall((k, v) -> v != null ? v.tostring() + "_after" : "after"); // 取得した検索結果の各行の値に "_after" を付与する\n      return ans;\n    }))\n  .count();\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# バッチsql実行動作のカスタマイズ\nsqlbatchインタフェースにはバッチsql実行時の動作を変更するためのapiが提供されています。\n\nメソッド                                                      説明                                                       デフォルト値                             \nby(bipredicate<sqlcontext, map<string, object>>)          バッチsqlの実行条件を指定します。bipredicateの結果がtrueの場合にバッチsqlを実行します。   1000件毎                             \nbatchwhen(biconsumer<sqlagent, sqlcontext>)               バッチsqlの実行タイミングで行う操作を指定します。                               何もしない                              \nerrorwhen(triconsumer<sqlagent, sqlcontext, exception>)   バッチsqlの実行時に例外が発生した時の動作を指定します。                            uroborosqlruntimeexceptionをスローする   \n\nこれらのapiを利用することでより柔軟なsql実行が可能になります。\n\nバッチsql実行時動作のカスタマイズ例\n\nlist<map<string, object>> inputdata = new arraylist<>();\n// 中略　入力データ作成\n\ntry (sqlagent agent = config.agent()) {\n  agent.batch("department/insert_department")\n    .paramstream(inputdata.stream())\n    .by((ctx, row) -> ctx.batchcount() == 10)  // 10件毎にsql実行\n    .batchwhen((agent, ctx) -> agent.commit())  // sql実行が成功したらコミットする\n    .errorwhen((agent, ctx, ex) -> {\n      log.error("error occured. ex:{}", ex.getmessage());\n    })  // 例外が発生したらログ出力する\n    .count();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# ストアドプロシージャの実行(sqlagent#proc /#procwith)\nuroborosqlでは、sqlの検索/更新のほかdbが提供するストアドプロシージャの呼び出し用apiも提供しています。\n\n利用メソッド                          説明                 \nsqlagent#proc("[sql名]")         sql名で説明したsql名を指定   \nsqlagent#procwith("[sql文字列]")   sql文字列を直接指定        \n\n上記２つのメソッドはストアドプロシージャの呼出を行うためのprocedureインタフェースのインスタンスを返却します。\n\n# procedureインタフェース\nメソッド名              戻り値の型                 \nprocedure#call()   map<string, object>   \n\nprocedureインタフェースでは、ストアドプロシージャからの戻り値を取得するためのapiが提供されています。\n\nメソッド                                                  説明                                                                                               \nprocedurefluent#outparam(string, int)                 ストアドプロシージャからの戻り値として受け取るパラメータを指定します                                                               \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のmap<string, object>に格納されて取得できます。第2引数で受け取る値の型をint型で指定します       \nprocedurefluent#outparam(string, sqltype)             ストアドプロシージャからの戻り値として受け取るパラメータを指定します                                                               \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のmap<string, object>に格納されて取得できます。第2引数で受け取る値の型をsqltype型で指定します   \nprocedurefluent#inoutparam(string, int)               ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のmap<string, object>に格納されて取得できます。第2引数で受け取る値の型をint型で指定します       \nprocedurefluent#inoutparam(string, sqltype)           ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のmap<string, object>に格納されて取得できます。第2引数で受け取る値の型をsqltype型で指定します   \nprocedurefluent#inoutparamifabsent(string, int)       ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      指定したパラメータ名のパラメータが事前に登録されていない場合に値を追加します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のmap<string, object>に格納されて取得できます。第2引数で受け取る値の型をint型で指定します       \nprocedurefluent#inoutparamifabsent(string, sqltype)   ストアドプロシージャに渡し、かつ、戻り値として受け取るパラメータを指定します                                                           \n                                                      指定したパラメータ名のパラメータが事前に登録されていない場合に値を追加します                                                           \n                                                      実行したストアドプロシージャ内で指定したキーに設定された値が、戻り値のmap<string, object>に格納されて取得できます。第2引数で受け取る値の型をsqltype型で指定します   \n\n// procedureインタフェースのインスタンスを取得\nmap<string, object> result = agent.procwith("{call product_id_exist_check(/*product_id*/, /*check_out*/)}")\n  .param("product_id", 0)\n  .outparam("check_out", java.sql.jdbctype.numeric)\n  .call();\n// outparamメソッドで指定したパラメータの値(戻り値)を取得\nbigdecimal checkout = (bigdecimal)result.get("check_out");\n\n\n1\n2\n3\n4\n5\n6\n7',charsets:{cjk:!0}},{title:"トランザクション",frontmatter:{meta:[{name:"og:title",content:"トランザクション"},{name:"og:url",content:"/uroborosql-doc/basics/transaction.html"}]},regularPath:"/basics/transaction.html",relativePath:"basics/transaction.md",key:"v-2e849a2f",path:"/basics/transaction.html",headers:[{level:2,title:"トランザクションの開始と終了 ( SqlAgent#required /#requiredNew /#notSupported )",slug:"トランザクションの開始と終了-sqlagent-required-requirednew-notsupported",charIndex:109},{level:2,title:"コミットとロールバック ( SqlAgent#commit /#setRollbackOnly )",slug:"コミットとロールバック-sqlagent-commit-setrollbackonly",charIndex:1367},{level:2,title:"セーブポイント ( SqlAgent#setSavepoint /#rollback /#releaseSavepoint)",slug:"セーブポイント-sqlagent-setsavepoint-rollback-releasesavepoint",charIndex:2401},{level:3,title:"セーブポイントスコープ(SqlAgent#savepointScope)",slug:"セーブポイントスコープ-sqlagent-savepointscope",charIndex:3061},{level:2,title:"エラーハンドリング ( UroborosqlSQLException )",slug:"エラーハンドリング-uroborosqlsqlexception",charIndex:3874}],lastUpdated:"2020-3-8 21:44:34",headersStr:"トランザクションの開始と終了 ( SqlAgent#required /#requiredNew /#notSupported ) コミットとロールバック ( SqlAgent#commit /#setRollbackOnly ) セーブポイント ( SqlAgent#setSavepoint /#rollback /#releaseSavepoint) セーブポイントスコープ(SqlAgent#savepointScope) エラーハンドリング ( UroborosqlSQLException )",content:'# トランザクション\nuroboroSQLではローカルトランザクションを提供します。\nトランザクションを利用することで、エラー発生時でも一部のデータだけ登録を成功させるといった細かな制御ができるようになります。\n\n# トランザクションの開始と終了 ( SqlAgent#required /#requiredNew /#notSupported )\nuroboroSQLで提供するトランザクションのレベルは以下の3つです\n\nトランザクションタイプ    トランザクション有り                               トランザクションなし              \nrequired       トランザクション内で処理を実行                          新たなトランザクションを開始して処理を実行   \nrequiresNew    既存のトランザクションを停止し、新たなトランザクションを開始して処理を実行。   新たなトランザクションを開始して処理を実行   \n               トランザクションが終了すると停止していたトランザクションを再開させる                               \nnotSupported   既存のトランザクションを停止し、トランザクション外で処理を実行。         トランザクション外で処理を実行         \n               処理が終了すると停止していたトランザクションを再開させる                                     \n\nSqlAgentインタフェースにトランザクションタイプに応じたメソッドが提供されており、そのメソッドを呼び出すことでトランザクションの開始と終了を制御します。\n\nagent.required(() -> {\n  // トランザクション開始\n  agent.updateWith("insert into employee (emp_no) values (/*emp_no*/1001)")\n    .param("emp_no", 1)\n    .count();\n\n  agent.requiresNew(() -> {\n    // 新しい トランザクション開始\n    agent.updateWith("insert into department (dept_no, dept_name) values (/*dept_no*/1111, /*dept_name*/\'Sales\')")\n      .param("dept_no", 2)\n      .param("dept_name", "export")\n      .count();\n    // 新しい トランザクション終了 commit\n  });\n  // トランザクション終了 commit\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nTIP\n\n設定によりDB更新処理の実行をトランザクション内で行うことを強制することができます。詳しくはDB更新処理をトランザクション内のみに強制を参照してください。\n\n# コミットとロールバック ( SqlAgent#commit /#setRollbackOnly )\nトランザクションのlambda式が正常に終了すればトランザクションはコミットされます。\nトランザクションのlambda式が例外をスローした場合はトランザクションをロールバックします。\n明示的にコミットを行う場合はSqlAgent#commit()を呼び出します。\n例外をスローせずに明示的にロールバックを行う場合はSqlAgent#setRollbackOnly()を呼び出します。\n\nagent.required(() -> {\n  // トランザクション開始\n  agent.updateWith("insert into employee (emp_no) values (/*emp_no*/1001)")\n    .param("emp_no", 1)\n    .count();\n\n  // 新しい トランザクション開始\n  agent.requiresNew(() -> {\n    agent.updateWith("insert into department (dept_no, dept_name) values (/*dept_no*/1, /*dept_name*/\'\')")\n      .param("dept_no", 2)\n      .param("dept_name", "Production")\n      .count();\n    // 明示的なcommit\n    agent.commit();\n\n    agent.updateWith("insert into department (dept_no, dept_name) values (/*dept_no*/1, /*dept_name*/\'\')")\n      .param("dept_no", 3)\n      .param("dept_name", "export")\n      .count();\n    // 明示的なrollback\n    agent.setRollbackOnly();\n    // 新しい トランザクション終了\n  });\n  // トランザクション終了 commit\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# セーブポイント ( SqlAgent#setSavepoint /#rollback /#releaseSavepoint)\nトランザクション内にセーブポイントを設けることで、トランザクション内の特定の操作のみ取り消すといった細かな制御ができます。\n\nagent.required(() -> {\n  // トランザクション開始\n  agent.update("employee/insert_employee")\n    .param("emp_no", 1001)\n    .count();\n\n  // セーブポイント(名前:sp)の設定\n  agent.setSavepoint("sp");\n  agent.update("employee/insert_employee")\n    .param("emp_no", 1002)\n    .count();\n\n  assertThat(agent.query("employee/select_employee").collect().size(), 2);\n\n  // 最後のinsertを取消(セーブポイント(名前:sp)までロールバック)\n  agent.rollback("sp");\n\n  assertThat(agent.query("employee/select_employee").collect().size(), 1);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# セーブポイントスコープ(SqlAgent#savepointScope) \nSqlAgent#savepointScope() を使用して、より確実にsavepointの制御を行うことができます。\n\n// SqlAgent#savepoint()を使ったsavepointの実装\nagent.required(() -> {\n  // トランザクション開始\n  agent.update("employee/insert_employee")\n    .param("emp_no", 1001)\n    .count();\n\n  // セーブポイントスコープの開始\n  agent.savepointScope(() -> {\n    agent.update("employee/insert_employee")\n      .param("emp_no", 1002)\n      .count();\n\n    assertThat(agent.query("employee/select_employee").collect().size(), 2);\n    // savepointScope内の処理を取り消す場合は例外をスローする\n    throw new UroborosqlRuntimeException();\n  })\n  assertThat(agent.query("employee/select_employee").collect().size(), 1);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nTIP\n\nPostgreSQLについては、自動的にセーブポイントを利用したトランザクションの部分ロールバックに対応しています。 詳細は、PostgreSQLのトランザクション内SQLエラー対応を参照してください。\n\n# エラーハンドリング ( UroborosqlSQLException )\nuroboroSQLからSQLを実行した際にSQLExceptionがスローされると、 そのSQLExceptionを内部に保持するUroborosqlSQLExceptionが呼び出し元に返却されます。\nUroborosqlSQLExceptionはjava.lang.RuntimeExceptionを継承しているため明示的なキャッチは不要です。\n\n呼出元のアプリケーションで明示的にエラーハンドリングを行う場合は、try-catchでUroborosqlSQLExceptionをキャッチすることで、 例外発生時の挙動を制御することができます。\n\nエラーハンドリングの例\n\nSqlConfig config = UroboroSQL.builder(...).build();\n\ntry (SqlAgent agent = config.agent()) {\n  // INSERT文の実行\n  // insert into product (product_id) values (/*product_id*/0);\n  agent.update("example/insert_product")\n    .param("product_id", 1)\n    .count();\n} catch (UroborosqlSQLException ex) {\n  // SQLExceptionが発生した際に行う処理を実装\n  throw new Exception("exception occured. ex=" + ex.getCause().getMessage(), ex);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12',contentLowercase:'# トランザクション\nuroborosqlではローカルトランザクションを提供します。\nトランザクションを利用することで、エラー発生時でも一部のデータだけ登録を成功させるといった細かな制御ができるようになります。\n\n# トランザクションの開始と終了 ( sqlagent#required /#requirednew /#notsupported )\nuroborosqlで提供するトランザクションのレベルは以下の3つです\n\nトランザクションタイプ    トランザクション有り                               トランザクションなし              \nrequired       トランザクション内で処理を実行                          新たなトランザクションを開始して処理を実行   \nrequiresnew    既存のトランザクションを停止し、新たなトランザクションを開始して処理を実行。   新たなトランザクションを開始して処理を実行   \n               トランザクションが終了すると停止していたトランザクションを再開させる                               \nnotsupported   既存のトランザクションを停止し、トランザクション外で処理を実行。         トランザクション外で処理を実行         \n               処理が終了すると停止していたトランザクションを再開させる                                     \n\nsqlagentインタフェースにトランザクションタイプに応じたメソッドが提供されており、そのメソッドを呼び出すことでトランザクションの開始と終了を制御します。\n\nagent.required(() -> {\n  // トランザクション開始\n  agent.updatewith("insert into employee (emp_no) values (/*emp_no*/1001)")\n    .param("emp_no", 1)\n    .count();\n\n  agent.requiresnew(() -> {\n    // 新しい トランザクション開始\n    agent.updatewith("insert into department (dept_no, dept_name) values (/*dept_no*/1111, /*dept_name*/\'sales\')")\n      .param("dept_no", 2)\n      .param("dept_name", "export")\n      .count();\n    // 新しい トランザクション終了 commit\n  });\n  // トランザクション終了 commit\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\ntip\n\n設定によりdb更新処理の実行をトランザクション内で行うことを強制することができます。詳しくはdb更新処理をトランザクション内のみに強制を参照してください。\n\n# コミットとロールバック ( sqlagent#commit /#setrollbackonly )\nトランザクションのlambda式が正常に終了すればトランザクションはコミットされます。\nトランザクションのlambda式が例外をスローした場合はトランザクションをロールバックします。\n明示的にコミットを行う場合はsqlagent#commit()を呼び出します。\n例外をスローせずに明示的にロールバックを行う場合はsqlagent#setrollbackonly()を呼び出します。\n\nagent.required(() -> {\n  // トランザクション開始\n  agent.updatewith("insert into employee (emp_no) values (/*emp_no*/1001)")\n    .param("emp_no", 1)\n    .count();\n\n  // 新しい トランザクション開始\n  agent.requiresnew(() -> {\n    agent.updatewith("insert into department (dept_no, dept_name) values (/*dept_no*/1, /*dept_name*/\'\')")\n      .param("dept_no", 2)\n      .param("dept_name", "production")\n      .count();\n    // 明示的なcommit\n    agent.commit();\n\n    agent.updatewith("insert into department (dept_no, dept_name) values (/*dept_no*/1, /*dept_name*/\'\')")\n      .param("dept_no", 3)\n      .param("dept_name", "export")\n      .count();\n    // 明示的なrollback\n    agent.setrollbackonly();\n    // 新しい トランザクション終了\n  });\n  // トランザクション終了 commit\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# セーブポイント ( sqlagent#setsavepoint /#rollback /#releasesavepoint)\nトランザクション内にセーブポイントを設けることで、トランザクション内の特定の操作のみ取り消すといった細かな制御ができます。\n\nagent.required(() -> {\n  // トランザクション開始\n  agent.update("employee/insert_employee")\n    .param("emp_no", 1001)\n    .count();\n\n  // セーブポイント(名前:sp)の設定\n  agent.setsavepoint("sp");\n  agent.update("employee/insert_employee")\n    .param("emp_no", 1002)\n    .count();\n\n  assertthat(agent.query("employee/select_employee").collect().size(), 2);\n\n  // 最後のinsertを取消(セーブポイント(名前:sp)までロールバック)\n  agent.rollback("sp");\n\n  assertthat(agent.query("employee/select_employee").collect().size(), 1);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# セーブポイントスコープ(sqlagent#savepointscope) \nsqlagent#savepointscope() を使用して、より確実にsavepointの制御を行うことができます。\n\n// sqlagent#savepoint()を使ったsavepointの実装\nagent.required(() -> {\n  // トランザクション開始\n  agent.update("employee/insert_employee")\n    .param("emp_no", 1001)\n    .count();\n\n  // セーブポイントスコープの開始\n  agent.savepointscope(() -> {\n    agent.update("employee/insert_employee")\n      .param("emp_no", 1002)\n      .count();\n\n    assertthat(agent.query("employee/select_employee").collect().size(), 2);\n    // savepointscope内の処理を取り消す場合は例外をスローする\n    throw new uroborosqlruntimeexception();\n  })\n  assertthat(agent.query("employee/select_employee").collect().size(), 1);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ntip\n\npostgresqlについては、自動的にセーブポイントを利用したトランザクションの部分ロールバックに対応しています。 詳細は、postgresqlのトランザクション内sqlエラー対応を参照してください。\n\n# エラーハンドリング ( uroborosqlsqlexception )\nuroborosqlからsqlを実行した際にsqlexceptionがスローされると、 そのsqlexceptionを内部に保持するuroborosqlsqlexceptionが呼び出し元に返却されます。\nuroborosqlsqlexceptionはjava.lang.runtimeexceptionを継承しているため明示的なキャッチは不要です。\n\n呼出元のアプリケーションで明示的にエラーハンドリングを行う場合は、try-catchでuroborosqlsqlexceptionをキャッチすることで、 例外発生時の挙動を制御することができます。\n\nエラーハンドリングの例\n\nsqlconfig config = uroborosql.builder(...).build();\n\ntry (sqlagent agent = config.agent()) {\n  // insert文の実行\n  // insert into product (product_id) values (/*product_id*/0);\n  agent.update("example/insert_product")\n    .param("product_id", 1)\n    .count();\n} catch (uroborosqlsqlexception ex) {\n  // sqlexceptionが発生した際に行う処理を実装\n  throw new exception("exception occured. ex=" + ex.getcause().getmessage(), ex);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12',charsets:{cjk:!0}},{title:"SqlConfigの生成",frontmatter:{meta:[{name:"og:title",content:"SqlConfigの生成"},{name:"og:url",content:"/uroborosql-doc/configuration/"}]},regularPath:"/configuration/",relativePath:"configuration/README.md",key:"v-6053133c",path:"/configuration/",lastUpdated:"2020-3-8 21:44:34",headersStr:null,content:'# SqlConfigの生成\nuroboroSQLではSqlConfigを生成するタイミングで各種の設定を行うことによりライブラリの動作や実行されるSQLを変更することができます。\n\nシンプルな設定\n\n// create SqlConfig H2DBのメモリDBに接続する\nSqlConfig config = UroboroSQL\n  .builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "")\n  .build();\n\n\n1\n2\n3\n4\nUroboroSQLビルダー取得API（UroboroSQL.UroboroSQLBuilder）\n\nメソッド名                                                              説明                               \nbuilder()                                                          DB接続設定を行っていないビルダーを取得             \nbuilder(Connection conn)                                           引数で指定したコネクションでDB接続するビルダーを取得      \nbuilder(DataSource dataSource)                                     引数で指定したデータソースを使ってDB接続するビルダーを取得   \nbuilder(String url, String user, String password)                  引数で指定したDB接続情報を元にDB接続するビルダーを取得    \nbuilder(String url, String user, String password, String schema)   引数で指定したDB接続情報を元にDB接続するビルダーを取得    \n\n上記APIで取得したUroboroSQL.UroboroSQLBuilderに対して下記の設定クラスを設定することで、設定変更ができます。\n\n設定するクラス              説明                                        \nConnectionSupplier   JDBCコネクション提供クラス                           \nSqlContextFactory    SQLコンテキスト生成クラス                            \nSqlAgentFactory      SQL実行クラス(SqlAgent)生成クラス                   \nSqlManager           SQLファイル管理クラス                              \nSqlFilterManager     SQLフィルター管理クラス                             \nEntityHandler        エンティティ処理クラス                               \nDialect              Database方言を表すクラス                          \nClock                タイムゾーンを使用して現在の時点、日付および時間へのアクセスを提供するクロック',contentLowercase:'# sqlconfigの生成\nuroborosqlではsqlconfigを生成するタイミングで各種の設定を行うことによりライブラリの動作や実行されるsqlを変更することができます。\n\nシンプルな設定\n\n// create sqlconfig h2dbのメモリdbに接続する\nsqlconfig config = uroborosql\n  .builder("jdbc:h2:mem:test;db_close_delay=-1", "sa", "")\n  .build();\n\n\n1\n2\n3\n4\nuroborosqlビルダー取得api（uroborosql.uroborosqlbuilder）\n\nメソッド名                                                              説明                               \nbuilder()                                                          db接続設定を行っていないビルダーを取得             \nbuilder(connection conn)                                           引数で指定したコネクションでdb接続するビルダーを取得      \nbuilder(datasource datasource)                                     引数で指定したデータソースを使ってdb接続するビルダーを取得   \nbuilder(string url, string user, string password)                  引数で指定したdb接続情報を元にdb接続するビルダーを取得    \nbuilder(string url, string user, string password, string schema)   引数で指定したdb接続情報を元にdb接続するビルダーを取得    \n\n上記apiで取得したuroborosql.uroborosqlbuilderに対して下記の設定クラスを設定することで、設定変更ができます。\n\n設定するクラス              説明                                        \nconnectionsupplier   jdbcコネクション提供クラス                           \nsqlcontextfactory    sqlコンテキスト生成クラス                            \nsqlagentfactory      sql実行クラス(sqlagent)生成クラス                   \nsqlmanager           sqlファイル管理クラス                              \nsqlfiltermanager     sqlフィルター管理クラス                             \nentityhandler        エンティティ処理クラス                               \ndialect              database方言を表すクラス                          \nclock                タイムゾーンを使用して現在の時点、日付および時間へのアクセスを提供するクロック',charsets:{cjk:!0}},{title:"ConnectionSupplier",frontmatter:{meta:[{name:"og:title",content:"ConnectionSupplier"},{name:"og:url",content:"/uroborosql-doc/configuration/connection-supplier.html"}]},regularPath:"/configuration/connection-supplier.html",relativePath:"configuration/connection-supplier.md",key:"v-76bd776b",path:"/configuration/connection-supplier.html",headers:[{level:2,title:"ConnectionContext",slug:"connectioncontext",charIndex:454},{level:3,title:"実装例",slug:"実装例",charIndex:1411}],lastUpdated:"2020-11-19 23:55:38",headersStr:"ConnectionContext 実装例",content:'# ConnectionSupplier\nDB接続を行う際のコネクションを提供するクラスです。 標準で以下のクラスが提供されているので用途に応じて使い分けてください。\n\nクラス名                               説明                                     \nDefaultConnectionSupplierImpl      コンストラクタで受け取ったコネクションを返すだけのコネクション供給クラス   \nJdbcConnectionSupplierImpl         JDBCドライバーマネージャを使用したコネクション提供クラス         \nDataSourceConnectionSupplierImpl   データソースを使用したコネクション提供クラス                 \n\nまた、ConnectionSupplierインタフェースを実装した独自のJDBCコネクション提供クラスを利用することもできます。\n\n# ConnectionContext \n動的にSqlAgentの接続先を切り替える場合は、SqlConfig#agent(ConnectionContext)メソッドを使用します。\n\nConnectionContextは、ConnectionContextBuilderの下記メソッドを利用して、インスタンスを生成します。\n\n戻り値                           メソッド名                                                           説明                                   \nDataSourceConnectionContext   dataSource()                                                    DataSourceConnectionContext を生成する.   \nDataSourceConnectionContext   dataSource(String dataSourceName)                               DataSourceConnectionContext を生成する.   \nJdbcConnectionContext         jdbc(String url)                                                JdbcConnectionContext を生成する.         \nJdbcConnectionContext         jdbc(String url, String user, String password)                  JdbcConnectionContext を生成する.         \nJdbcConnectionContext         jdbc(String url, String user, String password, String schema)   JdbcConnectionContext を生成する.         \n\n# 実装例\nSqlConfig config = UroboroSQL\n    .builder()\n    .setConnectionSupplier(new JdbcConnectionSupplier("jdbc:h2:mem:mainConnection", "sa", "sa"))\n    .build();\n\ntry (SqlAgent agent = config.agent()) {\n  // using jdbc:h2:mem:mainConnection\n  agent.required(() -> {\n    ....\n  });\n}\n\n//-------------------------------------------------------\n\ntry (SqlAgent agent = config.agent(ConnectionContextBuilder\n\t\t\t\t.jdbc("jdbc:h2:mem:subConnection", "sa", "sa"))) {\n  // usingjdbc:h2:mem:subConnection\n  agent.required(() -> {\n    ....\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21',contentLowercase:'# connectionsupplier\ndb接続を行う際のコネクションを提供するクラスです。 標準で以下のクラスが提供されているので用途に応じて使い分けてください。\n\nクラス名                               説明                                     \ndefaultconnectionsupplierimpl      コンストラクタで受け取ったコネクションを返すだけのコネクション供給クラス   \njdbcconnectionsupplierimpl         jdbcドライバーマネージャを使用したコネクション提供クラス         \ndatasourceconnectionsupplierimpl   データソースを使用したコネクション提供クラス                 \n\nまた、connectionsupplierインタフェースを実装した独自のjdbcコネクション提供クラスを利用することもできます。\n\n# connectioncontext \n動的にsqlagentの接続先を切り替える場合は、sqlconfig#agent(connectioncontext)メソッドを使用します。\n\nconnectioncontextは、connectioncontextbuilderの下記メソッドを利用して、インスタンスを生成します。\n\n戻り値                           メソッド名                                                           説明                                   \ndatasourceconnectioncontext   datasource()                                                    datasourceconnectioncontext を生成する.   \ndatasourceconnectioncontext   datasource(string datasourcename)                               datasourceconnectioncontext を生成する.   \njdbcconnectioncontext         jdbc(string url)                                                jdbcconnectioncontext を生成する.         \njdbcconnectioncontext         jdbc(string url, string user, string password)                  jdbcconnectioncontext を生成する.         \njdbcconnectioncontext         jdbc(string url, string user, string password, string schema)   jdbcconnectioncontext を生成する.         \n\n# 実装例\nsqlconfig config = uroborosql\n    .builder()\n    .setconnectionsupplier(new jdbcconnectionsupplier("jdbc:h2:mem:mainconnection", "sa", "sa"))\n    .build();\n\ntry (sqlagent agent = config.agent()) {\n  // using jdbc:h2:mem:mainconnection\n  agent.required(() -> {\n    ....\n  });\n}\n\n//-------------------------------------------------------\n\ntry (sqlagent agent = config.agent(connectioncontextbuilder\n\t\t\t\t.jdbc("jdbc:h2:mem:subconnection", "sa", "sa"))) {\n  // usingjdbc:h2:mem:subconnection\n  agent.required(() -> {\n    ....\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21',charsets:{cjk:!0}},{title:"Dialect",frontmatter:{meta:[{name:"og:title",content:"Dialect"},{name:"og:url",content:"/uroborosql-doc/configuration/dialect.html"}]},regularPath:"/configuration/dialect.html",relativePath:"configuration/dialect.md",key:"v-610199ea",path:"/configuration/dialect.html",headers:[{level:2,title:"カスタムDialectの登録",slug:"カスタムdialectの登録",charIndex:703}],lastUpdated:"2020-11-19 23:55:38",headersStr:"カスタムDialectの登録",content:'# Dialect\n複数のDBを対象とするアプリケーションを作成する場合、DB毎のSQL文法の差異を吸収するため アプリケーションで対象DBを判定し実行するSQLファイルを切り替える、といった対応が必要になります。uroboroSQLでは、こういったDB毎のSQL文法の差異に対応するため、Dialectという仕組みを提供しています。\nDialectは接続したDBから取得できる情報を元に自動で判別される為、通常は変更する必要はありません。\n\n現在、標準で以下のDBに対するDialectが提供されています。\n\nDB名                    Dialect             \nH2 DB                  H2Dialect           \nMicrosoft SQL Server   MsSqlDialect        \nMySQL                  MySqlDialect        \nOracle10g以下            Oracle10Dialect     \nOracle11g              Oracle11Dialect     \nOracle12c以上            Oracle12Dialect     \nPostgresql             PostgresqlDialect   \nその他                    DefaultDialect      \n\nWARNING\n\n該当するDBが見つからない場合はDefaultDialectが適用されます\n\n# カスタムDialectの登録\n標準でサポートしている上記のDB以外に接続し、DefaultDialectと違う動作をさせたい場合は、対象のDBに対するDialectクラスを作成してuroboroSQLに登録する必要があります。\n\nDialectの登録には、Javaの java.util.ServiceLoaderを利用します。\n\n最初に対象のDB（ここではSQLiteとする）に対するDialectクラスを作成します。\n\npackage foo.bar.dialect;\n\npublic class SqliteDialect extends AbstractDialect {\n  /**\n   * コンストラクタ\n   */\n  public SqliteDialect() {\n    super();\n  }\n\n  @Override\n  public String getDatabaseName() {\n    return "SQLite";  // 対象DBの製品名を特定するための文字列を返す\n  }\n\n  // supportsXXXメソッド、isXXXメソッド、getXXXメソッドを必要に応じて実装\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nDialectインタフェースで提供すべきメソッドは以下になります。\n\nメソッド名                                                                                 戻り値             説明                                                          \nsupportsBulkInsert()                                                                  boolean         BULK INSERTをサポートするかどうか                                      \nsupportsLimitClause()                                                                 boolean         LIMIT句をサポートするかどうか                                           \nsupportsOptimizerHints()                                                              boolean         オプティマイザーヒントをサポートするかどうか                                      \nsupportsNullValuesOrdering()                                                          boolean         SELECT句のORDER BYでNULL値の順序を指定できるか（NULLS FIRST/LAST）          \nsupportsIdentity()                                                                    boolean         データベースのIDカラムを使用したID自動採番をサポートしているか                           \nsupportsSequence()                                                                    boolean         データベースのシーケンスを使用したID自動採番をサポートしているか                           \nsupportsForUpdate()                                                                   boolean         明示的な行ロックをサポートしているか                                          \nsupportsForUpdateNoWait()                                                             boolean         明示的な行ロック（待機なし）をサポートしているか                                    \nsupportsForUpdateWait()                                                               boolean         明示的な行ロック（待機あり）をサポートしているか                                    \nisRemoveTerminator()                                                                  boolean         実行するSQLに記述されている終端文字(;)を削除するかどうか                             \nisRollbackToSavepointBeforeRetry()                                                    boolean         リトライする前に設定したSavepointまでロールバックするかどうか                         \ngetSequenceNextValSql(String sequenceName)                                            String          シーケンスを取得するためのSQL文を取得する                                      \ngetLimitClause(long limit, long offset)                                               String          LIMIT句（とOFFSET句）を取得する                                       \nescapeLikePattern(CharSequence pattern)                                               String          LIKE演算子のパターン文字列をエスケープする                                     \ngetJavaType(JDBCType jdbcType, String jdbcTypeName)                                   JavaType        引数で渡ってきたJavaTypeを変換したJavaTypeを取得する。（DB固有のJava型変換を行う場合に実装）   \ngetJavaType(int jdbcType, String jdbcTypeName)                                        JavaType        引数で渡ってきたJavaTypeを変換したJavaTypeを取得する。（DB固有のJava型変換を行う場合に実装）   \ngetDatabaseName()                                                                     String          データベースを判別するための文字列を取得する                                      \ngetDatabaseType()                                                                     String          データベースの種別を表す名前を取得する                                         \ngetEscapeChar()                                                                       char            LIKE句で指定するエスケープキャラクタを取得する                                   \naddForUpdateClause(StringBuilder sql, ForUpdateType forUpdateType, int waitSeconds)   StringBuilder   FOR UPDATE句の文字列をSQLに追加する                                    \naddOptimizerHints(StringBuilder sql, List<String> hints)                              StringBuilder   引数で渡したSQLにオプティマイザーヒントを付与する                                  \ngetModLiteral(final String dividend, final String divisor)                            StringBuilder   乗除を行うためのSQL文字列を取得する                                         \ngetPessimisticLockingErrorCodes()                                                     Set<String>     悲観ロックのErrorCode もしくは SqlStateを取得する                          \n\nDialectインタフェースのデフォルト実装やAbstractDialectクラスを参考に、上記のメソッドのうち変更が必要なメソッドの実装を行ってください。\n\n次にuroboroSQLを利用するアプリケーションのクラスパス上に以下のファイル名のファイルを作成します。\n\nMETA-INF\n  └─services\n      └─jp.co.future.uroborosql.dialect.Dialect\n\n\n1\n2\n3\n最後に作成したjp.co.future.uroborosql.dialect.Dialectファイルの中に作成したDialectのクラス名（FQDN名）を記述します。\n\nfoo.bar.dialect.SqliteDialect\n\n\n1\nアプリケーションでjp.co.future.uroborosql.dialect.DialectがServiceLoader経由で読み込まれれば登録したSqliteDialectが利用可能になります。',contentLowercase:'# dialect\n複数のdbを対象とするアプリケーションを作成する場合、db毎のsql文法の差異を吸収するため アプリケーションで対象dbを判定し実行するsqlファイルを切り替える、といった対応が必要になります。uroborosqlでは、こういったdb毎のsql文法の差異に対応するため、dialectという仕組みを提供しています。\ndialectは接続したdbから取得できる情報を元に自動で判別される為、通常は変更する必要はありません。\n\n現在、標準で以下のdbに対するdialectが提供されています。\n\ndb名                    dialect             \nh2 db                  h2dialect           \nmicrosoft sql server   mssqldialect        \nmysql                  mysqldialect        \noracle10g以下            oracle10dialect     \noracle11g              oracle11dialect     \noracle12c以上            oracle12dialect     \npostgresql             postgresqldialect   \nその他                    defaultdialect      \n\nwarning\n\n該当するdbが見つからない場合はdefaultdialectが適用されます\n\n# カスタムdialectの登録\n標準でサポートしている上記のdb以外に接続し、defaultdialectと違う動作をさせたい場合は、対象のdbに対するdialectクラスを作成してuroborosqlに登録する必要があります。\n\ndialectの登録には、javaの java.util.serviceloaderを利用します。\n\n最初に対象のdb（ここではsqliteとする）に対するdialectクラスを作成します。\n\npackage foo.bar.dialect;\n\npublic class sqlitedialect extends abstractdialect {\n  /**\n   * コンストラクタ\n   */\n  public sqlitedialect() {\n    super();\n  }\n\n  @override\n  public string getdatabasename() {\n    return "sqlite";  // 対象dbの製品名を特定するための文字列を返す\n  }\n\n  // supportsxxxメソッド、isxxxメソッド、getxxxメソッドを必要に応じて実装\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\ndialectインタフェースで提供すべきメソッドは以下になります。\n\nメソッド名                                                                                 戻り値             説明                                                          \nsupportsbulkinsert()                                                                  boolean         bulk insertをサポートするかどうか                                      \nsupportslimitclause()                                                                 boolean         limit句をサポートするかどうか                                           \nsupportsoptimizerhints()                                                              boolean         オプティマイザーヒントをサポートするかどうか                                      \nsupportsnullvaluesordering()                                                          boolean         select句のorder byでnull値の順序を指定できるか（nulls first/last）          \nsupportsidentity()                                                                    boolean         データベースのidカラムを使用したid自動採番をサポートしているか                           \nsupportssequence()                                                                    boolean         データベースのシーケンスを使用したid自動採番をサポートしているか                           \nsupportsforupdate()                                                                   boolean         明示的な行ロックをサポートしているか                                          \nsupportsforupdatenowait()                                                             boolean         明示的な行ロック（待機なし）をサポートしているか                                    \nsupportsforupdatewait()                                                               boolean         明示的な行ロック（待機あり）をサポートしているか                                    \nisremoveterminator()                                                                  boolean         実行するsqlに記述されている終端文字(;)を削除するかどうか                             \nisrollbacktosavepointbeforeretry()                                                    boolean         リトライする前に設定したsavepointまでロールバックするかどうか                         \ngetsequencenextvalsql(string sequencename)                                            string          シーケンスを取得するためのsql文を取得する                                      \ngetlimitclause(long limit, long offset)                                               string          limit句（とoffset句）を取得する                                       \nescapelikepattern(charsequence pattern)                                               string          like演算子のパターン文字列をエスケープする                                     \ngetjavatype(jdbctype jdbctype, string jdbctypename)                                   javatype        引数で渡ってきたjavatypeを変換したjavatypeを取得する。（db固有のjava型変換を行う場合に実装）   \ngetjavatype(int jdbctype, string jdbctypename)                                        javatype        引数で渡ってきたjavatypeを変換したjavatypeを取得する。（db固有のjava型変換を行う場合に実装）   \ngetdatabasename()                                                                     string          データベースを判別するための文字列を取得する                                      \ngetdatabasetype()                                                                     string          データベースの種別を表す名前を取得する                                         \ngetescapechar()                                                                       char            like句で指定するエスケープキャラクタを取得する                                   \naddforupdateclause(stringbuilder sql, forupdatetype forupdatetype, int waitseconds)   stringbuilder   for update句の文字列をsqlに追加する                                    \naddoptimizerhints(stringbuilder sql, list<string> hints)                              stringbuilder   引数で渡したsqlにオプティマイザーヒントを付与する                                  \ngetmodliteral(final string dividend, final string divisor)                            stringbuilder   乗除を行うためのsql文字列を取得する                                         \ngetpessimisticlockingerrorcodes()                                                     set<string>     悲観ロックのerrorcode もしくは sqlstateを取得する                          \n\ndialectインタフェースのデフォルト実装やabstractdialectクラスを参考に、上記のメソッドのうち変更が必要なメソッドの実装を行ってください。\n\n次にuroborosqlを利用するアプリケーションのクラスパス上に以下のファイル名のファイルを作成します。\n\nmeta-inf\n  └─services\n      └─jp.co.future.uroborosql.dialect.dialect\n\n\n1\n2\n3\n最後に作成したjp.co.future.uroborosql.dialect.dialectファイルの中に作成したdialectのクラス名（fqdn名）を記述します。\n\nfoo.bar.dialect.sqlitedialect\n\n\n1\nアプリケーションでjp.co.future.uroborosql.dialect.dialectがserviceloader経由で読み込まれれば登録したsqlitedialectが利用可能になります。',charsets:{cjk:!0}},{title:"EntityHandler",frontmatter:{meta:[{name:"og:title",content:"EntityHandler"},{name:"og:url",content:"/uroborosql-doc/configuration/entity-handler.html"}]},regularPath:"/configuration/entity-handler.html",relativePath:"configuration/entity-handler.md",key:"v-919e5336",path:"/configuration/entity-handler.html",lastUpdated:"2019-9-4 23:08:33",headersStr:null,content:"# EntityHandler\nEntityHandlerはDAOインタフェースを利用したDB操作を行う際に実行するSQLの生成を制御するためのクラスです。\nアプリケーションの要件によってEntityHandlerインタフェースやDefaultEntityHandlerクラスを継承した独自のEntityHandlerを指定することが出来ます。\n\nTIP\n\nEntityHandlerはDAOインタフェース利用時のみに有効な手段ですが、SQLファイルインタフェースにおいても自動でバインドする場合は、自動パラメータバインド関数の設定を参照してください。\n\nEntityHandler拡張例\n\npublic class CustomEntityHandler extends DefaultEntityHandler\n  implements EntityHandler<Object> {\n\n  @Override\n  public void setInsertParams(final SqlContext context, final Object entity) {\n    setEntityModelInsertParams((EntityModel) entity);  // entityがEntityModel型を継承している場合\n    super.setInsertParams(context, entity);\n  }\n\n  @Override\n  public void setUpdateParams(final SqlContext context, final Object entity) {\n    setEntityModelUpdateParams((EntityModel) entity);  // entityがEntityModel型を継承している場合\n    super.setUpdateParams(context, entity);\n  }\n\n  @Override\n  public void setBulkInsertParams(final SqlContext context, final Object entity, final int entityIndex) {\n    setEntityModelInsertParams((EntityModel) entity);  // entityがEntityModel型を継承している場合\n    super.setBulkInsertParams(context, entity, entityIndex);\n  }\n\n  private void setEntityModelInsertParams(final EntityModel model) {\n    ZonedDateTime now = ZonedDateTime.now();\n    model.setCreatedAt(now);\n    model.setUpdatedAt(now);\n  }\n\n  private void setEntityModelUpdateParams(final EntityModel model) {\n    model.setUpdatedAt(ZonedDateTime.now());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n// create SqlConfig\nSqlConfig config = UroboroSQL\n  .builder(...)\n  // EntityHandlerの設定\n  .setEntityHandler(new CustomEntityHandler()).build();\n\n\n1\n2\n3\n4\n5",contentLowercase:"# entityhandler\nentityhandlerはdaoインタフェースを利用したdb操作を行う際に実行するsqlの生成を制御するためのクラスです。\nアプリケーションの要件によってentityhandlerインタフェースやdefaultentityhandlerクラスを継承した独自のentityhandlerを指定することが出来ます。\n\ntip\n\nentityhandlerはdaoインタフェース利用時のみに有効な手段ですが、sqlファイルインタフェースにおいても自動でバインドする場合は、自動パラメータバインド関数の設定を参照してください。\n\nentityhandler拡張例\n\npublic class customentityhandler extends defaultentityhandler\n  implements entityhandler<object> {\n\n  @override\n  public void setinsertparams(final sqlcontext context, final object entity) {\n    setentitymodelinsertparams((entitymodel) entity);  // entityがentitymodel型を継承している場合\n    super.setinsertparams(context, entity);\n  }\n\n  @override\n  public void setupdateparams(final sqlcontext context, final object entity) {\n    setentitymodelupdateparams((entitymodel) entity);  // entityがentitymodel型を継承している場合\n    super.setupdateparams(context, entity);\n  }\n\n  @override\n  public void setbulkinsertparams(final sqlcontext context, final object entity, final int entityindex) {\n    setentitymodelinsertparams((entitymodel) entity);  // entityがentitymodel型を継承している場合\n    super.setbulkinsertparams(context, entity, entityindex);\n  }\n\n  private void setentitymodelinsertparams(final entitymodel model) {\n    zoneddatetime now = zoneddatetime.now();\n    model.setcreatedat(now);\n    model.setupdatedat(now);\n  }\n\n  private void setentitymodelupdateparams(final entitymodel model) {\n    model.setupdatedat(zoneddatetime.now());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n// create sqlconfig\nsqlconfig config = uroborosql\n  .builder(...)\n  // entityhandlerの設定\n  .setentityhandler(new customentityhandler()).build();\n\n\n1\n2\n3\n4\n5",charsets:{cjk:!0}},{title:"SqlContextFactory",frontmatter:{meta:[{name:"og:title",content:"SqlContextFactory"},{name:"og:url",content:"/uroborosql-doc/configuration/sql-context-factory.html"}]},regularPath:"/configuration/sql-context-factory.html",relativePath:"configuration/sql-context-factory.md",key:"v-78e55c2b",path:"/configuration/sql-context-factory.html",headers:[{level:2,title:"区分値定数や列挙型の利用 ( SqlContextFactory#setConstantClassNames /#setEnumConstantPackageNames)",slug:"区分値定数や列挙型の利用-sqlcontextfactory-setconstantclassnames-setenumconstantpackagenames",charIndex:1423},{level:2,title:"自動パラメータバインド関数の設定 ( SqlContextFactory#addQueryAutoParameterBinder /#addUpdateAutoParameterBinder )",slug:"自動パラメータバインド関数の設定-sqlcontextfactory-addqueryautoparameterbinder-addupdateautoparameterbinder",charIndex:5816},{level:2,title:"バインドパラメータ変換クラスの設定 ( SqlContextFactory#addBindParamMapper )",slug:"バインドパラメータ変換クラスの設定-sqlcontextfactory-addbindparammapper",charIndex:6900},{level:2,title:"java.sql.ResultSetの挙動設定",slug:"java-sql-resultsetの挙動設定",charIndex:8133},{level:3,title:"カーソル型の初期値（DefaultResultSetType）",slug:"カーソル型の初期値-defaultresultsettype",charIndex:8797},{level:3,title:"変更可能性の初期値（DefaultResultSetConcurrency）",slug:"変更可能性の初期値-defaultresultsetconcurrency",charIndex:9250}],lastUpdated:"2020-3-8 21:44:34",headersStr:"区分値定数や列挙型の利用 ( SqlContextFactory#setConstantClassNames /#setEnumConstantPackageNames) 自動パラメータバインド関数の設定 ( SqlContextFactory#addQueryAutoParameterBinder /#addUpdateAutoParameterBinder ) バインドパラメータ変換クラスの設定 ( SqlContextFactory#addBindParamMapper ) java.sql.ResultSetの挙動設定 カーソル型の初期値（DefaultResultSetType） 変更可能性の初期値（DefaultResultSetConcurrency）",content:'# SqlContextFactory\nSQL構造を表現するクラスであるSqlContextを生成するファクトリクラスです。生成されるSQLの挙動を変更するための設定が行えます。\n\n設定例\n\n// create SqlConfig\nSqlConfig config = UroboroSQL\n  .builder(...)\n  // SqlContextFactoryの設定\n  .setSqlContextFactory(new SqlContextFactoryImpl()\n    // 定数クラス設定の追加\n    .setConstantClassNames(Arrays.asList(TypeConstants.class.getName()))\n    // 列挙型パッケージ設定の追加\n    .setEnumConstantPackageNames(Arrays.asList(Gender.class.getPackage().getName()))\n     // 定数パラメータのプレフィックス指定(初期値 : CLS_)\n    .setConstParamPrefix("CLS_")\n    // query用自動パラメータバインド関数の登録\n    .addQueryAutoParameterBinder((ctx) -> ctx.paramIfAbsent("current_flg", true))\n    // update/batch/procedure用自動パラメータバインド関数の登録\n    .addUpdateAutoParameterBinder((ctx) -> ctx.paramIfAbsent("ins_datetime", LocalDateTime.now()))\n    .addUpdateAutoParameterBinder((ctx) -> ctx.paramIfAbsent("upd_datetime", LocalDateTime.now()))\n    // パラメータ変換クラスの登録\n    .addBindParamMapper(new CustomBindParamMapper())\n    // ResultSetTypeの初期値\n    // java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.TYPE_SCROLL_SENSITIVE のいづれか\n    .setDefaultResultSetType(ResultSet.TYPE_FORWARD_ONLY)\n    // ResultSetConcurrencyの初期値\n    // java.sql.ResultSet.CONCUR_READ_ONLY, java.sql.ResultSet.CONCUR_UPDATABLE のいづれか\n    .setDefaultResultSetConcurrency(ResultSet.CONCUR_READ_ONLY)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 区分値定数や列挙型の利用 ( SqlContextFactory#setConstantClassNames /#setEnumConstantPackageNames)\nこれまでSQLの開発では、区分値や定数値などの固定値がマジックナンバーとしてSQL文内に埋め込まれていました。\nしかしマジックナンバーの記述は可読性が悪く仕様変更時の影響調査が困難なため不具合の温床となっていました。\n\n例\n\nselect\n *\nfrom employee\nwhere emp_typ = \'05\' -- 05:従業員     <-- 従業員の区分が変わったらどうする？\n\n\n1\n2\n3\n4\nuroboroSQLはエンタープライズ分野での開発に利用されてきた経験から、SQL文の中でマジックナンバーの代わりに定数や列挙型を利用するための仕組みを提供しています。\n\n区分値定数/列挙型を利用するためにはSqlContextFactoryに以下の設定を追加します。\n\n// create SqlConfig\nSqlConfig config = UroboroSQL\n  .builder(...)\n  // SqlContextFactoryの設定\n  .setSqlContextFactory(new SqlContextFactoryImpl()\n    // 定数クラス設定の追加\n    .setConstantClassNames(Arrays.asList(TypeConstants.class.getName()))\n    // 列挙型パッケージ設定の追加\n    .setEnumConstantPackageNames(Arrays.asList(Gender.class.getPackage().getName()))\n     // 定数パラメータのプレフィックス指定(初期値 : CLS_)\n    .setConstParamPrefix("CLS_")\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n定数クラス : TypeConstants.javaの実装例\n\n/**\n * 区分値定数クラス\n */\npublic final class TypeConstants {\n  private TypeConstants() {}\n\n  /** 区分種別：口座種別区分  区分種別番号：0035 */\n  public static final String ACCOUNT_TYP = "0035";\n  /** 区分種別：口座種別区分  区分値：普通  区分値番号：1 */\n  public static final String ACCOUNT_TYP_SAVING = "1";\n  /** 区分種別：口座種別区分  区分値：当座  区分値番号：2 */\n  public static final String ACCOUNT_TYP_CHECKING = "2";\n  /** 区分種別：口座種別区分  区分値：定期  区分値番号：3 */\n  public static final String ACCOUNT_TYP_FIXED_DEPOSIT = "3";\n  /** 区分種別：実行区分  区分種別番号：0052 */\n  public static final String ISSUE_TYP = "0052";\n  /** 区分種別：実行区分  区分値：未実行  区分値番号：1 */\n  public static final String ISSUE_TYP_UNISSUED = "1";\n  /** 区分種別：実行区分  区分値：実行済  区分値番号：2 */\n  public static final String ISSUE_TYP_OUTSTANDING = "2";\n}\n\n/**\n * システム定数\n */\npublic final class Consts {\n  private Consts() {}\n\n  public static final class CommonValue {\n    private CommonValue() {}\n\n    /** 業務日付（オンライン） */\n    public static final String ONLINE_DATE = "1";\n\n    /** 業務日付（バッチ） */\n    public static final String BATCH_DATE = "2";\n\n    /** SQL上でのフラグ表現（TRUE=1） */\n    public static final String FLAG_ON = "1";\n    /** SQL上でのフラグ表現（FALSE=0） */\n    public static final String FLAG_OFF = "0";\n    /** 日付ALL0 */\n    public static final String ZERO_DATE = "00000000";\n    /** 日付最小値 */\n    public static final String MIN_DATE = "19000101";\n    /** 日付最大値 */\n    public static final String MAX_DATE = "99991231";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n列挙型 : Gender.javaの実装例\n\n/**\n * 性別を表す列挙型\n */\npublic enum Gender {\n  MALE("M"), FEMALE("F"), OTHER("O");\n\n  private final String label;\n\n  private Gender(String label) {\n    this.label = label;\n  }\n\n  @Override\n  public String toString() {\n    return label;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nこのように区分値定数や列挙型を定数パラメータとして登録しておくことで、SQL文の中で定数名が利用できるようになります。\n\n定数パラメータを利用する場合、以下の命名ルールに従ってパラメータを指定します。\n\nパターン                書式                                                             \n定数                  [定数パラメータプレフィックス][定数フィールド名大文字]                                  \n定数(Innerクラスがある場合)   [定数パラメータプレフィックス][Innerクラス名大文字スネークケース]_[Innerクラス内定数フィールド名大文字]   \n列挙型                 [定数パラメータプレフィックス][列挙型名大文字]_[列挙子名大文字]                            \n\nTIP\n\n※定数パラメータプレフィックスの初期値は CLS_となっています。\nSqlContextFactory#setConstParamPrefix()で変更することが可能です。\n\n実際に使用する際はSQL文の中で置換文字列として以下のように指定します\n\n * /*#[定数パラメータプレフィックス][定数フィールド名大文字]*/\n * /*#[定数パラメータプレフィックス][Innerクラス名大文字スネークケース]_[Innerクラス内定数フィールド名大文字]*/\n * /*#[定数パラメータプレフィックス][列挙型名大文字]_[列挙子名大文字]*/\n\nまたは\n\n * /*$[定数パラメータプレフィックス][定数フィールド名大文字]*/\n * /*$[定数パラメータプレフィックス][Innerクラス名大文字スネークケース]_[Innerクラス内定数フィールド名大文字]*/\n * /*$[定数パラメータプレフィックス][列挙型名大文字]_[列挙子名大文字]*/\n\nという風に使用します。\n\nTIP\n\n定数や列挙型の値は固定値なので生成されるSQLは毎回同じ値になり、SQL文解析処理によるCPU負荷を考慮する必要はありません。\n\n区分の例\n\nselect\n *\nfrom account\nwhere account_typ = /*#CLS_ACCOUNT_TYP_SAVING*/\'1\' -- 1:普通口座\n\n\n1\n2\n3\n4\n定数の例\n\nselect\n  emp.emp_no    as  emp_no\n,  emp.first_name  as  first_name\n,  emp.last_name  as  last_name\n,  emp.birth_date  as  birth_date\n,  emp.gender    as  gender\nfrom\n  employee  emp\nwhere\n  emp.birth_date    !=  /*#CLS_COMMON_VALUE_ZERO_DATE*/\'00000000\'  -- 定数パラメータの指定\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n列挙型の例\n\nselect\n  emp.emp_no    as  emp_no\n,  emp.first_name  as  first_name\n,  emp.last_name  as  last_name\n,  emp.birth_date  as  birth_date\n,  emp.gender    as  gender\nfrom\n  employee  emp\nwhere\n  emp.gender    =  /*#CLS_GENDER_FEMALE*/\'F\'  -- 列挙型定数パラメータの指定\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 自動パラメータバインド関数の設定 ( SqlContextFactory#addQueryAutoParameterBinder /#addUpdateAutoParameterBinder ) \nアプリケーションで使用する各テーブルに共通項目（登録日時、更新日時など）が定義されている場合、 INSERT文やUPDATE文を実行する際には毎回これらの共通項目に対するパラメータを指定する必要が出てきます。\nこのような共通項目へのパラメータ設定を個別に行うと実装が煩雑になり、 どうしても実装漏れや記述ミスにより正しく値が設定されない、といったことが起こります。\n\nuroboroSQLではこのような共通項目に対して自動的にパラメータをバインドする仕組みを提供しています。\n自動パラメータバインド関数を設定することで、SQLの実行のたびに自動パラメータバインド関数が呼び出され、 関数内で指定したパラメータがSQLにバインドされることになります。\n\n設定例\n\nSqlConfig config = UroboroSQL\n  .builder(...)\n  // SqlContextFactoryの設定\n  .setSqlContextFactory(new SqlContextFactoryImpl()\n    // query用自動パラメータバインド関数の登録\n    .addQueryAutoParameterBinder((ctx) -> ctx.paramIfAbsent("current_flg", true))\n    // update/batch/procedure用自動パラメータバインド関数の登録\n    .addUpdateAutoParameterBinder((ctx) -> ctx.paramIfAbsent("ins_datetime", LocalDateTime.now()))\n    .addUpdateAutoParameterBinder((ctx) -> ctx.paramIfAbsent("upd_datetime", LocalDateTime.now()))\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n自動パラメータバインド関数はSqlContextを引数に受け取るので、関数内でパラメータの設定を行ってください。\n\nTIP\n\n関数の評価は、SQL生成処理（SQL文内の/*IF*/や/*BEGIN*/、/*parameter_name*/の評価）の直前に行われます。\n\n# バインドパラメータ変換クラスの設定 ( SqlContextFactory#addBindParamMapper ) \nSQLを実行する際、独自に作成したクラスをバインドしたい場合があります。 そういったケースに対応できるようuroboroSQLではバインドパラメータをJDBCが受け入れられる型に変換するためのクラスを 設定することが出来ます。\n\nバインドパラメータ変換クラスの例\n\n// Nameクラスに対するバインドパラメータ変換クラス\npublic class CustomBindParamMapper implements BindParameterMapper<Name> {\n  @Override\n  public Object toJdbc(Name original, Connection connection,\n    BindParameterMapperManager parameterMapperManager) {\n    return original.toString();\n  }\n}\n\n// バインドパラメータに設定するドメインクラス\npublic class Name {\n  private final String firstName;\n  private final String lastName;\n\n  public Name(String firstName, String lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\n  @Override\n  public String toString() {\n    return this.firstName + " " + this.lastName;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nSqlContextFactoryの設定\n\n// create SqlConfig\nSqlConfig config = UroboroSQL\n.builder(...)\n// SqlContextFactoryの設定\n.setSqlContextFactory(new SqlContextFactoryImpl()\n  // パラメータ変換クラスの登録\n  .addBindParamMapper(new CustomBindParamMapper())\n).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nバインドパラメータ設定例\n\nName name = new Name("Bob", "Smith");\nagent.update("insert_user").param("name", name).count();\n\n\n1\n2\n# java.sql.ResultSetの挙動設定 \n検索SQLの発行で取得するjava.util.ResultSetの挙動を変更することができます。\n\n// create SqlConfig\nSqlConfig config = UroboroSQL\n  .builder(...)\n  // SqlContextFactoryの設定\n  .setSqlContextFactory(new SqlContextFactoryImpl()\n    // ResultSetTypeの初期値\n    // java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.TYPE_SCROLL_SENSITIVE のいづれか\n    .setDefaultResultSetType(ResultSet.TYPE_FORWARD_ONLY)\n    // ResultSetConcurrencyの初期値\n    // java.sql.ResultSet.CONCUR_READ_ONLY, java.sql.ResultSet.CONCUR_UPDATABLE のいづれか\n    .setDefaultResultSetConcurrency(ResultSet.CONCUR_READ_ONLY)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# カーソル型の初期値（DefaultResultSetType）\njava.sql.ResultSetのカーソルの型を指定します。\n\n型                                            説明                                          初期値   \njava.sql.ResultSet#TYPE_FORWARD_ONLY         カーソルは最初から最後まで順方向にしか移動できません。                 ◯     \njava.sql.ResultSet#TYPE_SCROLL_INSENSITIVE   カーソルは順方向・逆方向いずれにも移動可能です。ただし他による変更を反映しません。         \njava.sql.ResultSet#TYPE_SCROLL_SENSITIVE     カーソルは順方向・逆方向いずれにも移動可能です。また他による変更も反映します。           \n\n# 変更可能性の初期値（DefaultResultSetConcurrency）\njava.sql.ResultSetの変更可能性を指定します。\n\n型                                     説明                                           初期値   \njava.sql.ResultSet.CONCUR_READ_ONLY   カーソルはデータの読み出ししかサポートしません。                     ◯     \njava.sql.ResultSet.CONCUR_UPDATABLE   カーソルは変更可能です。カーソルを用いたデータの挿入・変更・削除がサポートされます。',contentLowercase:'# sqlcontextfactory\nsql構造を表現するクラスであるsqlcontextを生成するファクトリクラスです。生成されるsqlの挙動を変更するための設定が行えます。\n\n設定例\n\n// create sqlconfig\nsqlconfig config = uroborosql\n  .builder(...)\n  // sqlcontextfactoryの設定\n  .setsqlcontextfactory(new sqlcontextfactoryimpl()\n    // 定数クラス設定の追加\n    .setconstantclassnames(arrays.aslist(typeconstants.class.getname()))\n    // 列挙型パッケージ設定の追加\n    .setenumconstantpackagenames(arrays.aslist(gender.class.getpackage().getname()))\n     // 定数パラメータのプレフィックス指定(初期値 : cls_)\n    .setconstparamprefix("cls_")\n    // query用自動パラメータバインド関数の登録\n    .addqueryautoparameterbinder((ctx) -> ctx.paramifabsent("current_flg", true))\n    // update/batch/procedure用自動パラメータバインド関数の登録\n    .addupdateautoparameterbinder((ctx) -> ctx.paramifabsent("ins_datetime", localdatetime.now()))\n    .addupdateautoparameterbinder((ctx) -> ctx.paramifabsent("upd_datetime", localdatetime.now()))\n    // パラメータ変換クラスの登録\n    .addbindparammapper(new custombindparammapper())\n    // resultsettypeの初期値\n    // java.sql.resultset.type_forward_only, java.sql.resultset.type_scroll_insensitive, java.sql.resultset.type_scroll_sensitive のいづれか\n    .setdefaultresultsettype(resultset.type_forward_only)\n    // resultsetconcurrencyの初期値\n    // java.sql.resultset.concur_read_only, java.sql.resultset.concur_updatable のいづれか\n    .setdefaultresultsetconcurrency(resultset.concur_read_only)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 区分値定数や列挙型の利用 ( sqlcontextfactory#setconstantclassnames /#setenumconstantpackagenames)\nこれまでsqlの開発では、区分値や定数値などの固定値がマジックナンバーとしてsql文内に埋め込まれていました。\nしかしマジックナンバーの記述は可読性が悪く仕様変更時の影響調査が困難なため不具合の温床となっていました。\n\n例\n\nselect\n *\nfrom employee\nwhere emp_typ = \'05\' -- 05:従業員     <-- 従業員の区分が変わったらどうする？\n\n\n1\n2\n3\n4\nuroborosqlはエンタープライズ分野での開発に利用されてきた経験から、sql文の中でマジックナンバーの代わりに定数や列挙型を利用するための仕組みを提供しています。\n\n区分値定数/列挙型を利用するためにはsqlcontextfactoryに以下の設定を追加します。\n\n// create sqlconfig\nsqlconfig config = uroborosql\n  .builder(...)\n  // sqlcontextfactoryの設定\n  .setsqlcontextfactory(new sqlcontextfactoryimpl()\n    // 定数クラス設定の追加\n    .setconstantclassnames(arrays.aslist(typeconstants.class.getname()))\n    // 列挙型パッケージ設定の追加\n    .setenumconstantpackagenames(arrays.aslist(gender.class.getpackage().getname()))\n     // 定数パラメータのプレフィックス指定(初期値 : cls_)\n    .setconstparamprefix("cls_")\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n定数クラス : typeconstants.javaの実装例\n\n/**\n * 区分値定数クラス\n */\npublic final class typeconstants {\n  private typeconstants() {}\n\n  /** 区分種別：口座種別区分  区分種別番号：0035 */\n  public static final string account_typ = "0035";\n  /** 区分種別：口座種別区分  区分値：普通  区分値番号：1 */\n  public static final string account_typ_saving = "1";\n  /** 区分種別：口座種別区分  区分値：当座  区分値番号：2 */\n  public static final string account_typ_checking = "2";\n  /** 区分種別：口座種別区分  区分値：定期  区分値番号：3 */\n  public static final string account_typ_fixed_deposit = "3";\n  /** 区分種別：実行区分  区分種別番号：0052 */\n  public static final string issue_typ = "0052";\n  /** 区分種別：実行区分  区分値：未実行  区分値番号：1 */\n  public static final string issue_typ_unissued = "1";\n  /** 区分種別：実行区分  区分値：実行済  区分値番号：2 */\n  public static final string issue_typ_outstanding = "2";\n}\n\n/**\n * システム定数\n */\npublic final class consts {\n  private consts() {}\n\n  public static final class commonvalue {\n    private commonvalue() {}\n\n    /** 業務日付（オンライン） */\n    public static final string online_date = "1";\n\n    /** 業務日付（バッチ） */\n    public static final string batch_date = "2";\n\n    /** sql上でのフラグ表現（true=1） */\n    public static final string flag_on = "1";\n    /** sql上でのフラグ表現（false=0） */\n    public static final string flag_off = "0";\n    /** 日付all0 */\n    public static final string zero_date = "00000000";\n    /** 日付最小値 */\n    public static final string min_date = "19000101";\n    /** 日付最大値 */\n    public static final string max_date = "99991231";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n列挙型 : gender.javaの実装例\n\n/**\n * 性別を表す列挙型\n */\npublic enum gender {\n  male("m"), female("f"), other("o");\n\n  private final string label;\n\n  private gender(string label) {\n    this.label = label;\n  }\n\n  @override\n  public string tostring() {\n    return label;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nこのように区分値定数や列挙型を定数パラメータとして登録しておくことで、sql文の中で定数名が利用できるようになります。\n\n定数パラメータを利用する場合、以下の命名ルールに従ってパラメータを指定します。\n\nパターン                書式                                                             \n定数                  [定数パラメータプレフィックス][定数フィールド名大文字]                                  \n定数(innerクラスがある場合)   [定数パラメータプレフィックス][innerクラス名大文字スネークケース]_[innerクラス内定数フィールド名大文字]   \n列挙型                 [定数パラメータプレフィックス][列挙型名大文字]_[列挙子名大文字]                            \n\ntip\n\n※定数パラメータプレフィックスの初期値は cls_となっています。\nsqlcontextfactory#setconstparamprefix()で変更することが可能です。\n\n実際に使用する際はsql文の中で置換文字列として以下のように指定します\n\n * /*#[定数パラメータプレフィックス][定数フィールド名大文字]*/\n * /*#[定数パラメータプレフィックス][innerクラス名大文字スネークケース]_[innerクラス内定数フィールド名大文字]*/\n * /*#[定数パラメータプレフィックス][列挙型名大文字]_[列挙子名大文字]*/\n\nまたは\n\n * /*$[定数パラメータプレフィックス][定数フィールド名大文字]*/\n * /*$[定数パラメータプレフィックス][innerクラス名大文字スネークケース]_[innerクラス内定数フィールド名大文字]*/\n * /*$[定数パラメータプレフィックス][列挙型名大文字]_[列挙子名大文字]*/\n\nという風に使用します。\n\ntip\n\n定数や列挙型の値は固定値なので生成されるsqlは毎回同じ値になり、sql文解析処理によるcpu負荷を考慮する必要はありません。\n\n区分の例\n\nselect\n *\nfrom account\nwhere account_typ = /*#cls_account_typ_saving*/\'1\' -- 1:普通口座\n\n\n1\n2\n3\n4\n定数の例\n\nselect\n  emp.emp_no    as  emp_no\n,  emp.first_name  as  first_name\n,  emp.last_name  as  last_name\n,  emp.birth_date  as  birth_date\n,  emp.gender    as  gender\nfrom\n  employee  emp\nwhere\n  emp.birth_date    !=  /*#cls_common_value_zero_date*/\'00000000\'  -- 定数パラメータの指定\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n列挙型の例\n\nselect\n  emp.emp_no    as  emp_no\n,  emp.first_name  as  first_name\n,  emp.last_name  as  last_name\n,  emp.birth_date  as  birth_date\n,  emp.gender    as  gender\nfrom\n  employee  emp\nwhere\n  emp.gender    =  /*#cls_gender_female*/\'f\'  -- 列挙型定数パラメータの指定\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 自動パラメータバインド関数の設定 ( sqlcontextfactory#addqueryautoparameterbinder /#addupdateautoparameterbinder ) \nアプリケーションで使用する各テーブルに共通項目（登録日時、更新日時など）が定義されている場合、 insert文やupdate文を実行する際には毎回これらの共通項目に対するパラメータを指定する必要が出てきます。\nこのような共通項目へのパラメータ設定を個別に行うと実装が煩雑になり、 どうしても実装漏れや記述ミスにより正しく値が設定されない、といったことが起こります。\n\nuroborosqlではこのような共通項目に対して自動的にパラメータをバインドする仕組みを提供しています。\n自動パラメータバインド関数を設定することで、sqlの実行のたびに自動パラメータバインド関数が呼び出され、 関数内で指定したパラメータがsqlにバインドされることになります。\n\n設定例\n\nsqlconfig config = uroborosql\n  .builder(...)\n  // sqlcontextfactoryの設定\n  .setsqlcontextfactory(new sqlcontextfactoryimpl()\n    // query用自動パラメータバインド関数の登録\n    .addqueryautoparameterbinder((ctx) -> ctx.paramifabsent("current_flg", true))\n    // update/batch/procedure用自動パラメータバインド関数の登録\n    .addupdateautoparameterbinder((ctx) -> ctx.paramifabsent("ins_datetime", localdatetime.now()))\n    .addupdateautoparameterbinder((ctx) -> ctx.paramifabsent("upd_datetime", localdatetime.now()))\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n自動パラメータバインド関数はsqlcontextを引数に受け取るので、関数内でパラメータの設定を行ってください。\n\ntip\n\n関数の評価は、sql生成処理（sql文内の/*if*/や/*begin*/、/*parameter_name*/の評価）の直前に行われます。\n\n# バインドパラメータ変換クラスの設定 ( sqlcontextfactory#addbindparammapper ) \nsqlを実行する際、独自に作成したクラスをバインドしたい場合があります。 そういったケースに対応できるようuroborosqlではバインドパラメータをjdbcが受け入れられる型に変換するためのクラスを 設定することが出来ます。\n\nバインドパラメータ変換クラスの例\n\n// nameクラスに対するバインドパラメータ変換クラス\npublic class custombindparammapper implements bindparametermapper<name> {\n  @override\n  public object tojdbc(name original, connection connection,\n    bindparametermappermanager parametermappermanager) {\n    return original.tostring();\n  }\n}\n\n// バインドパラメータに設定するドメインクラス\npublic class name {\n  private final string firstname;\n  private final string lastname;\n\n  public name(string firstname, string lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  @override\n  public string tostring() {\n    return this.firstname + " " + this.lastname;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nsqlcontextfactoryの設定\n\n// create sqlconfig\nsqlconfig config = uroborosql\n.builder(...)\n// sqlcontextfactoryの設定\n.setsqlcontextfactory(new sqlcontextfactoryimpl()\n  // パラメータ変換クラスの登録\n  .addbindparammapper(new custombindparammapper())\n).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nバインドパラメータ設定例\n\nname name = new name("bob", "smith");\nagent.update("insert_user").param("name", name).count();\n\n\n1\n2\n# java.sql.resultsetの挙動設定 \n検索sqlの発行で取得するjava.util.resultsetの挙動を変更することができます。\n\n// create sqlconfig\nsqlconfig config = uroborosql\n  .builder(...)\n  // sqlcontextfactoryの設定\n  .setsqlcontextfactory(new sqlcontextfactoryimpl()\n    // resultsettypeの初期値\n    // java.sql.resultset.type_forward_only, java.sql.resultset.type_scroll_insensitive, java.sql.resultset.type_scroll_sensitive のいづれか\n    .setdefaultresultsettype(resultset.type_forward_only)\n    // resultsetconcurrencyの初期値\n    // java.sql.resultset.concur_read_only, java.sql.resultset.concur_updatable のいづれか\n    .setdefaultresultsetconcurrency(resultset.concur_read_only)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# カーソル型の初期値（defaultresultsettype）\njava.sql.resultsetのカーソルの型を指定します。\n\n型                                            説明                                          初期値   \njava.sql.resultset#type_forward_only         カーソルは最初から最後まで順方向にしか移動できません。                 ◯     \njava.sql.resultset#type_scroll_insensitive   カーソルは順方向・逆方向いずれにも移動可能です。ただし他による変更を反映しません。         \njava.sql.resultset#type_scroll_sensitive     カーソルは順方向・逆方向いずれにも移動可能です。また他による変更も反映します。           \n\n# 変更可能性の初期値（defaultresultsetconcurrency）\njava.sql.resultsetの変更可能性を指定します。\n\n型                                     説明                                           初期値   \njava.sql.resultset.concur_read_only   カーソルはデータの読み出ししかサポートしません。                     ◯     \njava.sql.resultset.concur_updatable   カーソルは変更可能です。カーソルを用いたデータの挿入・変更・削除がサポートされます。',charsets:{cjk:!0}},{title:"SqlFilterManager",frontmatter:{meta:[{name:"og:title",content:"SqlFilterManager"},{name:"og:url",content:"/uroborosql-doc/configuration/sql-filter-manager.html"}]},regularPath:"/configuration/sql-filter-manager.html",relativePath:"configuration/sql-filter-manager.md",key:"v-7608f377",path:"/configuration/sql-filter-manager.html",headers:[{level:2,title:"SQLフィルター",slug:"sqlフィルター",charIndex:21}],lastUpdated:"2019-9-4 23:08:33",headersStr:"SQLフィルター",content:'# SqlFilterManager\n# SQLフィルター\nuroboroSQLではSQLの実行を行う一連の処理の流れの中にいくつかの拡張ポイントを設けており、この拡張ポイントに処理を追加することで、共通的なSQL文の加工や検索結果の記録といった様々な拡張を行うことができるように設計されています。\n\nSQL処理の拡張はSqlFilterインタフェースを実装したクラスを作成し登録することで行います。\nSqlFilterインタフェースには以下のメソッドが定義されています。\n\nSqlFilterメソッド名        説明                              \ninitialize            SqlFilterの初期化を行う                \ndoTransformSql        変換前のSQLに対して加工を行う                \ndoParameter           バインドパラメータの加工を行う                 \ndoOutParameter        ストアドプロシージャのOutParameterの加工を行う   \ndoPreparedStatement   PreparedStatementの加工を行う         \ndoCallableStatement   CallableStatementの加工を行う         \ndoQuery               検索処理結果の加工を行う                    \ndoUpdate              更新処理結果の加工を行う                    \ndoBatch               バッチ処理結果の加工を行う                   \ndoProcedure           Procedure呼出処理結果の加工を行う           \n\nuroboroSQLには標準でいくつかのSqlFilterの実装が含まれています。\n\nクラス名                                                   説明                                                            \njp.co.future.uroborosql.filter.DebugSqlFilter          SqlFilterの動作を理解するためのサンプル。各拡張ポイントで呼び出されるメソッドでログを出力します。         \njp.co.future.uroborosql.filter.DumpResultSqlFilter     検索結果を表形式でログ出力するSQLフィルター。SqlREPLで使用しています。                      \njp.co.future.uroborosql.filter.WrapContextSqlFilter    SQL文の前後に文字列を追加するSQLフィルター。ページングや検索件数の上限設定に使用します。               \njp.co.future.uroborosql.filter.SecretColumnSqlFilter   指定した特定のカラムのみ暗号化を行うSQLフィルター。パスワードや機密情報を暗号化してDBに格納するために使用します。   \njp.co.future.uroborosql.filter.AuditLogSqlFilter       監査記録を取得するためのSQLフィルター。                                         \n\nSQLフィルターを利用するためには、SqlConfig生成時にSqlFilterManagerの設定を追加して利用するSQLフィルターの登録を行ってください。\nSQLフィルターは複数登録することができます。複数登録した場合は登録した順にSQLフィルターが処理されます。\n\n// create SqlConfig\nSqlConfig config = UroboroSQL\n  .builder(...)\n  // SqlFilterManagerの設定\n  .setSqlFilterManager(new SqlFilterManagerImpl()\n    // DumpResultSqlFilterの登録\n    .addSqlFilter(new DumpResultSqlFilter())\n    // WrapContextSqlFilterの登録\n    .addSqlFilter(new WrapContextSqlFilter("",\n      "LIMIT /*$maxRowCount*/10 OFFSET /*$startRowIndex*/0",\n      ".*FOR\\\\sUPDATE.*"))\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n独自にSqlFilterを作成する場合は、jp.co.future.uroborosql.filter.AbstractSqlFilterを継承し、必要に応じてメソッドをオーバーライドしてください。\n\npublic class CustomSqlFilter extends AbstractSqlFilter {\n\n    // 途中略\n\n    @Override\n    public ResultSet doQuery(SqlContext sqlContext, PreparedStatement preparedStatement, ResultSet resultSet) {\n        // フィルター処理の実装\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9',contentLowercase:'# sqlfiltermanager\n# sqlフィルター\nuroborosqlではsqlの実行を行う一連の処理の流れの中にいくつかの拡張ポイントを設けており、この拡張ポイントに処理を追加することで、共通的なsql文の加工や検索結果の記録といった様々な拡張を行うことができるように設計されています。\n\nsql処理の拡張はsqlfilterインタフェースを実装したクラスを作成し登録することで行います。\nsqlfilterインタフェースには以下のメソッドが定義されています。\n\nsqlfilterメソッド名        説明                              \ninitialize            sqlfilterの初期化を行う                \ndotransformsql        変換前のsqlに対して加工を行う                \ndoparameter           バインドパラメータの加工を行う                 \ndooutparameter        ストアドプロシージャのoutparameterの加工を行う   \ndopreparedstatement   preparedstatementの加工を行う         \ndocallablestatement   callablestatementの加工を行う         \ndoquery               検索処理結果の加工を行う                    \ndoupdate              更新処理結果の加工を行う                    \ndobatch               バッチ処理結果の加工を行う                   \ndoprocedure           procedure呼出処理結果の加工を行う           \n\nuroborosqlには標準でいくつかのsqlfilterの実装が含まれています。\n\nクラス名                                                   説明                                                            \njp.co.future.uroborosql.filter.debugsqlfilter          sqlfilterの動作を理解するためのサンプル。各拡張ポイントで呼び出されるメソッドでログを出力します。         \njp.co.future.uroborosql.filter.dumpresultsqlfilter     検索結果を表形式でログ出力するsqlフィルター。sqlreplで使用しています。                      \njp.co.future.uroborosql.filter.wrapcontextsqlfilter    sql文の前後に文字列を追加するsqlフィルター。ページングや検索件数の上限設定に使用します。               \njp.co.future.uroborosql.filter.secretcolumnsqlfilter   指定した特定のカラムのみ暗号化を行うsqlフィルター。パスワードや機密情報を暗号化してdbに格納するために使用します。   \njp.co.future.uroborosql.filter.auditlogsqlfilter       監査記録を取得するためのsqlフィルター。                                         \n\nsqlフィルターを利用するためには、sqlconfig生成時にsqlfiltermanagerの設定を追加して利用するsqlフィルターの登録を行ってください。\nsqlフィルターは複数登録することができます。複数登録した場合は登録した順にsqlフィルターが処理されます。\n\n// create sqlconfig\nsqlconfig config = uroborosql\n  .builder(...)\n  // sqlfiltermanagerの設定\n  .setsqlfiltermanager(new sqlfiltermanagerimpl()\n    // dumpresultsqlfilterの登録\n    .addsqlfilter(new dumpresultsqlfilter())\n    // wrapcontextsqlfilterの登録\n    .addsqlfilter(new wrapcontextsqlfilter("",\n      "limit /*$maxrowcount*/10 offset /*$startrowindex*/0",\n      ".*for\\\\supdate.*"))\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n独自にsqlfilterを作成する場合は、jp.co.future.uroborosql.filter.abstractsqlfilterを継承し、必要に応じてメソッドをオーバーライドしてください。\n\npublic class customsqlfilter extends abstractsqlfilter {\n\n    // 途中略\n\n    @override\n    public resultset doquery(sqlcontext sqlcontext, preparedstatement preparedstatement, resultset resultset) {\n        // フィルター処理の実装\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9',charsets:{cjk:!0}},{title:"SqlAgentFactory",frontmatter:{meta:[{name:"og:title",content:"SqlAgentFactory"},{name:"og:url",content:"/uroborosql-doc/configuration/sql-agent-factory.html"}]},regularPath:"/configuration/sql-agent-factory.html",relativePath:"configuration/sql-agent-factory.md",key:"v-381b576b",path:"/configuration/sql-agent-factory.html",headers:[{level:2,title:"フェッチサイズと検索タイムアウト設定 ( SqlAgentFactory#setFetchSize /#setQueryTimeout  )",slug:"フェッチサイズと検索タイムアウト設定-sqlagentfactory-setfetchsize-setquerytimeout",charIndex:null},{level:2,title:"例外発生時のログ出力を行うかどうかを設定 ( SqlAgentFactory#setOutputExceptionLog )",slug:"例外発生時のログ出力を行うかどうかを設定-sqlagentfactory-setoutputexceptionlog",charIndex:1908},{level:2,title:"SQL_IDの置換文字列設定 ( SqlAgentFactory#setSqlIdKeyName )",slug:"sql-idの置換文字列設定-sqlagentfactory-setsqlidkeyname",charIndex:2251},{level:2,title:"CaseFormatの初期値設定 ( SqlAgentFactory#setDefaultMapKeyCaseFormat )",slug:"caseformatの初期値設定-sqlagentfactory-setdefaultmapkeycaseformat",charIndex:3526},{level:2,title:"複数件挿入時の挿入方法の初期値設定 ( SqlAgentFactory#setDefaultInsertsType )",slug:"複数件挿入時の挿入方法の初期値設定-sqlagentfactory-setdefaultinsertstype",charIndex:4891},{level:2,title:"SQL実行のリトライ ( SqlAgentFactory#setSqlRetryCodeList /#setDefaultMaxRetryCount /#setDefaultSqlRetryWaitTime )",slug:"sql実行のリトライ-sqlagentfactory-setsqlretrycodelist-setdefaultmaxretrycount-setdefaultsqlretrywaittime",charIndex:5250},{level:2,title:"DB更新処理をトランザクション内のみに強制 ( SqlAgentFactory#setForceUpdateWithinTransaction )",slug:"db更新処理をトランザクション内のみに強制-sqlagentfactory-setforceupdatewithintransaction",charIndex:7778},{level:2,title:"明示的な行ロック時の待機時間(s)のデフォルト値設定 ( SqlAgentFactory#setDefaultForUpdateWaitSeconds )",slug:"明示的な行ロック時の待機時間-s-のデフォルト値設定-sqlagentfactory-setdefaultforupdatewaitseconds",charIndex:8953}],lastUpdated:"2020-3-8 21:44:34",headersStr:"フェッチサイズと検索タイムアウト設定 ( SqlAgentFactory#setFetchSize /#setQueryTimeout  ) 例外発生時のログ出力を行うかどうかを設定 ( SqlAgentFactory#setOutputExceptionLog ) SQL_IDの置換文字列設定 ( SqlAgentFactory#setSqlIdKeyName ) CaseFormatの初期値設定 ( SqlAgentFactory#setDefaultMapKeyCaseFormat ) 複数件挿入時の挿入方法の初期値設定 ( SqlAgentFactory#setDefaultInsertsType ) SQL実行のリトライ ( SqlAgentFactory#setSqlRetryCodeList /#setDefaultMaxRetryCount /#setDefaultSqlRetryWaitTime ) DB更新処理をトランザクション内のみに強制 ( SqlAgentFactory#setForceUpdateWithinTransaction ) 明示的な行ロック時の待機時間(s)のデフォルト値設定 ( SqlAgentFactory#setDefaultForUpdateWaitSeconds )",content:'# SqlAgentFactory\nSQL実行を行うクラスであるSqlAgentを生成するファクトリクラスです。SQL実行時の挙動を変更するための初期値の設定が行えます。\n\n設定例\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // JDBCフェッチサイズ\n    .setFetchSize(1000)\n    // Statementオブジェクトの検索タイムアウト時間(s)\n    .setQueryTimeout(10)\n    // 例外発生時のログ出力を行うかどうか\n    .setOutputExceptionLog(true)\n    // SQL_IDの置換文字列\n    .setSqlIdKeyName("_SQL_ID_")\n    // 検索結果を格納するMapのキー変換に使用するCaseFormatの初期値\n    .setDefaultMapKeyCaseFormat(CaseFormat.UPPER_SNAKE_CASE)\n    // 複数件挿入時の挿入方法の初期値\n    .setDefaultInsertsType(InsertsType.BULK)\n    // アプリケーション全体のリトライ設定\n    // SQLエラーコードが54,30006のいずれか(Oracleのリソース・ビジー)の場合\n    .setSqlRetryCodeList(Arrays.asList("54", "30006"))\n    // 最大リトライ回数\n    .setDefaultMaxRetryCount(3)\n    // リトライ間隔\n    .setDefaultSqlRetryWaitTime(10)\n    // トランザクション内での更新を強制するかどうか\n    .setForceUpdateWithinTransaction(true)\n    // 明示的な行ロック時の待機時間(s)デフォルト値\n    .setDefaultForUpdateWaitSeconds(10)\n    )\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# フェッチサイズと検索タイムアウト設定 ( SqlAgentFactory#setFetchSize /#setQueryTimeout )\nSqlAgentで検索処理を行う際、データベースから一度に取得する行数（fetchSize）や 検索タイムアウト時間（秒）（queryTimeout）の初期値を指定することが出来ます。 指定しない場合fetchSize, queryTimeoutともに-1が設定されます。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // JDBCフェッチサイズ\n    .setFetchSize(1000)\n    // Statementオブジェクトの検索タイムアウト時間(s)\n    .setQueryTimeout(10)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n補足\n\nfetchSizeは、Statement.setFetchSizeに渡される値で、パフォーマンスに影響します。\nJDBCクライアント（uroborosqlを使用しているJavaアプリケーション）ではDBサーバ側で実行されたSELECTの結果セットをfetchサイズで指定された行数ずつ分割して取得します。 そのため結果行数に対してfetchSizeが小さいと、JDBCクライアント <-> DBサーバ間の通信回数が増大してパフォーマンスに悪影響を及ぼします。\n（例：select結果が10,000件、fetchSizeが100の場合、JDBCクライアント⇔DBサーバ間の通信は10,000÷100 = 100回行われる）\n\n注意\n\nfetchSizeはcollect/foreachメソッドで返却される結果セットの行数を制限する設定ではありません。\n\n# 例外発生時のログ出力を行うかどうかを設定 ( SqlAgentFactory#setOutputExceptionLog )\nSQL実行時にSQL例外が発生した場合に、発生した例外と実行したSQLの詳細情報を出力するかどうかを指定できます。 指定しない場合falseになります。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // 例外発生時のログ出力を行うかどうか\n    .setOutputExceptionLog(true)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n# SQL_IDの置換文字列設定 ( SqlAgentFactory#setSqlIdKeyName )\nSQL文に特定の置換文字列をSQLコメントとして記述することで、SQL実行時に実行したSQLの元となるSQLファイルを特定するための 情報（SQL_ID）を埋め込むことが出来ます。SQL_IDを埋め込むことでSQLログやDBのSQL履歴で実行されたSQLの元となるファイルを 特定しやすくなります。\n必要に応じてこの置換文字列は変更することが出来ます。 指定しない場合_SQL_ID_になります。\n\n設定例\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // SQL_IDの置換文字列\n    .setSqlIdKeyName("_SQL_ID_")\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\ndepartment/select_department.sql\n\nselect /* _SQL_ID_ */  -- _SQL_ID_ がSQLファイルを特定するための情報の埋め込み先となる\n  dept.dept_no      as  dept_no\n, dept.dept_name    as  dept_name\n, dept.lock_version as  lock_version\nfrom\n  department  dept\n/*BEGIN*/\nwhere\n/*IF SF.isNotEmpty(deptNo)*/\nand dept.dept_no  = /*deptNo*/1\n/*END*/\n/*IF SF.isNotEmpty(deptName)*/\nand dept.dept_name  = /*deptName*/\'sample\'\n/*END*/\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nSQL実行処理\n\nagent.query("department/select_department")\n  .param("deptNo", 1)\n  .collect();\n\n\n1\n2\n3\n実行されるSQL\n\nselect /* department/select_department */  -- _SQL_ID_ にSQL名（department/select_department）が設定される\n  dept.dept_no      as  dept_no\n, dept.dept_name    as  dept_name\n, dept.lock_version as  lock_version\nfrom\n  department  dept\nwhere\n  dept.dept_no  = 1/*deptNo*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# CaseFormatの初期値設定 ( SqlAgentFactory#setDefaultMapKeyCaseFormat )\nSQLによる検索で、以下のメソッドを使用してList<Map<String, Object>>やMap<String, Object>を取得する際、 取得したMapのキー名に対する書式の初期値を指定することが出来ます。 指定しない場合CaseFormat.UPPER_SNAKE_CASEになります。\n\n対象メソッド                 戻り値の型                           \nSqlQuery#collect()     List<Map<String, Object>>       \nSqlQuery#findFirst()   Optional<Map<String, Object>>   \nSqlQuery#first()       Map<String, Object>             \nSqlQuery#stream()      Stream<Map<String, Object>>     \n\n指定しない場合（初期設定：CaseFormat.UPPER_SNAKE_CASE）\n\nagent.query("department/select_department").collect();\n\n// 結果(departments) キーがUPPER_SNAKE_CASEとなっている\n[\n {"DEPT_NO"=1, "DEPT_NAME"="sales"},\n {"DEPT_NO"=2, "DEPT_NAME"="export"},\n {"DEPT_NO"=3, "DEPT_NAME"="accounting"},\n {"DEPT_NO"=4, "DEPT_NAME"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nCaseFormat.CAMEL_CASEを初期値として設定\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // 検索結果を格納するMapのキー変換に使用するCaseFormatの初期値\n    .setDefaultMapKeyCaseFormat(CaseFormat.CAMEL_CASE)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\nagent.query("department/select_department").collect();\n\n// 結果(departments) キーがCAMEL_CASEとなっている\n[\n {"deptNo"=1, "deptName"="sales"},\n {"deptNo"=2, "deptName"="export"},\n {"deptNo"=3, "deptName"="accounting"},\n {"deptNo"=4, "deptName"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 複数件挿入時の挿入方法の初期値設定 ( SqlAgentFactory#setDefaultInsertsType )\nSqlAgent#inserts()メソッドで使用するInsertsTypeの初期値を設定することが出来ます。 指定しない場合InsertsType.BULKになります。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // 複数件挿入時の挿入方法の初期値\n    .setDefaultInsertsType(InsertsType.BULK)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n# SQL実行のリトライ ( SqlAgentFactory#setSqlRetryCodeList /#setDefaultMaxRetryCount /#setDefaultSqlRetryWaitTime )\nSQLを実行した際、タイミングによって発生する例外（テーブルロックエラーなど）の場合はリトライを行い、 できるだけ正常に処理を終了させたい場合があります。\n通常、このようなケースでは以下のような実装を行います。\n\nString MAX_RETRY_COUNT = 3; // MAX_RETRY_COUNT はアプリケーションで定義された最大リトライ回数の定数とする\nSqlConfig config = UroboroSQL.builder(...).build();\n\nint retryCount = 0;\nfor(;;) {\n  try (SqlAgent agent = config.agent()) {\n    // INSERT文の実行\n    // insert into product (product_id) values (/*product_id*/0);\n    agent.update("example/insert_product").param("product_id", 1).count();\n    break;\n  } catch (UroborosqlSQLException ex) {\n    // SQLExceptionが発生した際に行う処理を実装\n    int errorCode = ex.getErrorCode();\n    if (errorCode == 30006 || errorCode == 54) {// リソース・ビジー(Oracleの場合)\n      // リトライ対象エラーコードの場合はリトライカウントをカウントアップしてリトライする\n      retryCount++;\n      if (retryCount == MAX_RETRY_COUNT) {\n        // 最大リトライ回数に達した場合は例外をスローする\n        throw ex;\n      } else {\n        try {\n          // 10ms 待機\n          Thread.sleep(10);\n        } catch (InterruptedException iex) {\n          // do nothing\n        }\n      }\n    } else {\n      // リトライ対象エラーコード以外はすぐに例外をスローする\n      throw ex;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nしかし、上記のようなリトライ処理を個々の実装で行うと、 実装漏れや実装ミス、実装方法の差異（for()の代わりにwhile()を使用するなど）により不具合が発生しやすくなります。\nuroboroSQLでは、アプリケーション全体のリトライ設定と、全体設定より優先される個別処理でのリトライ用APIの 2種類のAPIを提供することで、より簡潔で確実なリトライ処理が行えるよう工夫されています。\nアプリケーション全体のリトライ設定はSqlAgentFactory生成時に行います。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // アプリケーション全体のリトライ設定\n    // SQLエラーコードが54,30006のいずれか(Oracleのリソース・ビジー)の場合\n    .setSqlRetryCodeList(Arrays.asList("54", "30006"))\n    // 最大リトライ回数（3回）リトライ\n    .setDefaultMaxRetryCount(3)\n    // リトライ間隔10ms待機\n    .setDefaultSqlRetryWaitTime(10)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nリトライAPIを用いた実装は次のようになります。\n\n// アプリケーション全体のリトライ設定に従ってリトライを行う。（個別のリトライ指定なし）\ntry (SqlAgent agent = config.agent()) {\n  // INSERT文の実行\n  // insert into product (product_id) values (/*product_id*/0);\n  agent.update("example/insert_product")\n    .param("product_id", 1)\n    .count();\n}\n\n// 個別にリトライ設定を上書きする（retry()を利用）\ntry (SqlAgent agent = config.agent()) {\n  // INSERT文の実行\n  // insert into product (product_id) values (/*product_id*/0);\n  // リトライ対象エラーコードの場合、5回のリトライを20ms間隔で行う\n  agent.update("example/insert_product")\n    .param("product_id", 1)\n    .retry(5, 20)\n    .count();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# DB更新処理をトランザクション内のみに強制 ( SqlAgentFactory#setForceUpdateWithinTransaction ) \n複数のDB更新処理をまとめて行う際、途中で例外が発生するとDBデータが不整合な状態になる場合があります。このようなデータ不整合を防ぐためにはトランザクションを利用します。\nしかし、通常の設定ではトランザクションを開始しない状態でもDB更新処理を行うことが可能になっているため不具合に気付きにくいという問題があります。\nuroboroSQLではトランザクションを開始していない状態でDB更新処理が行なわれた場合に例外をスローするオプションを提供しています。このオプションを使用することでDBデータの整合性を維持しやすくなります。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // トランザクション内での更新を強制するかどうか\n    .setForceUpdateWithinTransaction(true)\n    )\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\nSqlAgentFactory#setForceUpdateWithinTransaction()にtrueを指定することでトランザクションを開始していない状態でDB更新処理が行なわれた場合にUroborosqlTransactionExceptionがスローされます。\n\nagent.required(() -> { // トランザクション開始\n  // トランザクション内でのDB更新なのでOK\n  agent.updateWith("insert into employee (emp_no) values (/*emp_no*/1001)")\n    .param("emp_no", 1)\n    .count();\n  });\n});　// トランザクション終了\n\n// トランザクション外でのDB更新なので UroborosqlTransactionException がスローされる\nagent.updateWith("insert into department (dept_no, dept_name) values (/*dept_no*/1111, /*dept_name*/\'Sales\')")\n  .param("dept_no", 2)\n  .param("dept_name", "export")\n  .count();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 明示的な行ロック時の待機時間(s)のデフォルト値設定 ( SqlAgentFactory#setDefaultForUpdateWaitSeconds ) \nSqlEntityQuery#forUpdateWait()による明示的な行ロックをおこなう際の待機時間を指定することができます。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // SqlAgentFactoryの設定\n  .setSqlAgentFactory(new SqlAgentFactoryImpl()\n    // 明示的な行ロック時の待機時間(s)デフォルト値\n    .setDefaultForUpdateWaitSeconds(10)\n    )\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n待機時間の初期値を設定することでSqlEntityQuery#forUpdateWait()を発行する際に適用され、 待機時間を都度指定する必要がなくなります。\nSqlEntityQuery#forUpdateWait(int)を使って個別に待機時間を指定した場合は個別設定が優先されます。',contentLowercase:'# sqlagentfactory\nsql実行を行うクラスであるsqlagentを生成するファクトリクラスです。sql実行時の挙動を変更するための初期値の設定が行えます。\n\n設定例\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // jdbcフェッチサイズ\n    .setfetchsize(1000)\n    // statementオブジェクトの検索タイムアウト時間(s)\n    .setquerytimeout(10)\n    // 例外発生時のログ出力を行うかどうか\n    .setoutputexceptionlog(true)\n    // sql_idの置換文字列\n    .setsqlidkeyname("_sql_id_")\n    // 検索結果を格納するmapのキー変換に使用するcaseformatの初期値\n    .setdefaultmapkeycaseformat(caseformat.upper_snake_case)\n    // 複数件挿入時の挿入方法の初期値\n    .setdefaultinsertstype(insertstype.bulk)\n    // アプリケーション全体のリトライ設定\n    // sqlエラーコードが54,30006のいずれか(oracleのリソース・ビジー)の場合\n    .setsqlretrycodelist(arrays.aslist("54", "30006"))\n    // 最大リトライ回数\n    .setdefaultmaxretrycount(3)\n    // リトライ間隔\n    .setdefaultsqlretrywaittime(10)\n    // トランザクション内での更新を強制するかどうか\n    .setforceupdatewithintransaction(true)\n    // 明示的な行ロック時の待機時間(s)デフォルト値\n    .setdefaultforupdatewaitseconds(10)\n    )\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# フェッチサイズと検索タイムアウト設定 ( sqlagentfactory#setfetchsize /#setquerytimeout )\nsqlagentで検索処理を行う際、データベースから一度に取得する行数（fetchsize）や 検索タイムアウト時間（秒）（querytimeout）の初期値を指定することが出来ます。 指定しない場合fetchsize, querytimeoutともに-1が設定されます。\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // jdbcフェッチサイズ\n    .setfetchsize(1000)\n    // statementオブジェクトの検索タイムアウト時間(s)\n    .setquerytimeout(10)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n補足\n\nfetchsizeは、statement.setfetchsizeに渡される値で、パフォーマンスに影響します。\njdbcクライアント（uroborosqlを使用しているjavaアプリケーション）ではdbサーバ側で実行されたselectの結果セットをfetchサイズで指定された行数ずつ分割して取得します。 そのため結果行数に対してfetchsizeが小さいと、jdbcクライアント <-> dbサーバ間の通信回数が増大してパフォーマンスに悪影響を及ぼします。\n（例：select結果が10,000件、fetchsizeが100の場合、jdbcクライアント⇔dbサーバ間の通信は10,000÷100 = 100回行われる）\n\n注意\n\nfetchsizeはcollect/foreachメソッドで返却される結果セットの行数を制限する設定ではありません。\n\n# 例外発生時のログ出力を行うかどうかを設定 ( sqlagentfactory#setoutputexceptionlog )\nsql実行時にsql例外が発生した場合に、発生した例外と実行したsqlの詳細情報を出力するかどうかを指定できます。 指定しない場合falseになります。\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // 例外発生時のログ出力を行うかどうか\n    .setoutputexceptionlog(true)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n# sql_idの置換文字列設定 ( sqlagentfactory#setsqlidkeyname )\nsql文に特定の置換文字列をsqlコメントとして記述することで、sql実行時に実行したsqlの元となるsqlファイルを特定するための 情報（sql_id）を埋め込むことが出来ます。sql_idを埋め込むことでsqlログやdbのsql履歴で実行されたsqlの元となるファイルを 特定しやすくなります。\n必要に応じてこの置換文字列は変更することが出来ます。 指定しない場合_sql_id_になります。\n\n設定例\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // sql_idの置換文字列\n    .setsqlidkeyname("_sql_id_")\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\ndepartment/select_department.sql\n\nselect /* _sql_id_ */  -- _sql_id_ がsqlファイルを特定するための情報の埋め込み先となる\n  dept.dept_no      as  dept_no\n, dept.dept_name    as  dept_name\n, dept.lock_version as  lock_version\nfrom\n  department  dept\n/*begin*/\nwhere\n/*if sf.isnotempty(deptno)*/\nand dept.dept_no  = /*deptno*/1\n/*end*/\n/*if sf.isnotempty(deptname)*/\nand dept.dept_name  = /*deptname*/\'sample\'\n/*end*/\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nsql実行処理\n\nagent.query("department/select_department")\n  .param("deptno", 1)\n  .collect();\n\n\n1\n2\n3\n実行されるsql\n\nselect /* department/select_department */  -- _sql_id_ にsql名（department/select_department）が設定される\n  dept.dept_no      as  dept_no\n, dept.dept_name    as  dept_name\n, dept.lock_version as  lock_version\nfrom\n  department  dept\nwhere\n  dept.dept_no  = 1/*deptno*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# caseformatの初期値設定 ( sqlagentfactory#setdefaultmapkeycaseformat )\nsqlによる検索で、以下のメソッドを使用してlist<map<string, object>>やmap<string, object>を取得する際、 取得したmapのキー名に対する書式の初期値を指定することが出来ます。 指定しない場合caseformat.upper_snake_caseになります。\n\n対象メソッド                 戻り値の型                           \nsqlquery#collect()     list<map<string, object>>       \nsqlquery#findfirst()   optional<map<string, object>>   \nsqlquery#first()       map<string, object>             \nsqlquery#stream()      stream<map<string, object>>     \n\n指定しない場合（初期設定：caseformat.upper_snake_case）\n\nagent.query("department/select_department").collect();\n\n// 結果(departments) キーがupper_snake_caseとなっている\n[\n {"dept_no"=1, "dept_name"="sales"},\n {"dept_no"=2, "dept_name"="export"},\n {"dept_no"=3, "dept_name"="accounting"},\n {"dept_no"=4, "dept_name"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\ncaseformat.camel_caseを初期値として設定\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // 検索結果を格納するmapのキー変換に使用するcaseformatの初期値\n    .setdefaultmapkeycaseformat(caseformat.camel_case)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\nagent.query("department/select_department").collect();\n\n// 結果(departments) キーがcamel_caseとなっている\n[\n {"deptno"=1, "deptname"="sales"},\n {"deptno"=2, "deptname"="export"},\n {"deptno"=3, "deptname"="accounting"},\n {"deptno"=4, "deptname"="personnel"}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 複数件挿入時の挿入方法の初期値設定 ( sqlagentfactory#setdefaultinsertstype )\nsqlagent#inserts()メソッドで使用するinsertstypeの初期値を設定することが出来ます。 指定しない場合insertstype.bulkになります。\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // 複数件挿入時の挿入方法の初期値\n    .setdefaultinsertstype(insertstype.bulk)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n# sql実行のリトライ ( sqlagentfactory#setsqlretrycodelist /#setdefaultmaxretrycount /#setdefaultsqlretrywaittime )\nsqlを実行した際、タイミングによって発生する例外（テーブルロックエラーなど）の場合はリトライを行い、 できるだけ正常に処理を終了させたい場合があります。\n通常、このようなケースでは以下のような実装を行います。\n\nstring max_retry_count = 3; // max_retry_count はアプリケーションで定義された最大リトライ回数の定数とする\nsqlconfig config = uroborosql.builder(...).build();\n\nint retrycount = 0;\nfor(;;) {\n  try (sqlagent agent = config.agent()) {\n    // insert文の実行\n    // insert into product (product_id) values (/*product_id*/0);\n    agent.update("example/insert_product").param("product_id", 1).count();\n    break;\n  } catch (uroborosqlsqlexception ex) {\n    // sqlexceptionが発生した際に行う処理を実装\n    int errorcode = ex.geterrorcode();\n    if (errorcode == 30006 || errorcode == 54) {// リソース・ビジー(oracleの場合)\n      // リトライ対象エラーコードの場合はリトライカウントをカウントアップしてリトライする\n      retrycount++;\n      if (retrycount == max_retry_count) {\n        // 最大リトライ回数に達した場合は例外をスローする\n        throw ex;\n      } else {\n        try {\n          // 10ms 待機\n          thread.sleep(10);\n        } catch (interruptedexception iex) {\n          // do nothing\n        }\n      }\n    } else {\n      // リトライ対象エラーコード以外はすぐに例外をスローする\n      throw ex;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nしかし、上記のようなリトライ処理を個々の実装で行うと、 実装漏れや実装ミス、実装方法の差異（for()の代わりにwhile()を使用するなど）により不具合が発生しやすくなります。\nuroborosqlでは、アプリケーション全体のリトライ設定と、全体設定より優先される個別処理でのリトライ用apiの 2種類のapiを提供することで、より簡潔で確実なリトライ処理が行えるよう工夫されています。\nアプリケーション全体のリトライ設定はsqlagentfactory生成時に行います。\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // アプリケーション全体のリトライ設定\n    // sqlエラーコードが54,30006のいずれか(oracleのリソース・ビジー)の場合\n    .setsqlretrycodelist(arrays.aslist("54", "30006"))\n    // 最大リトライ回数（3回）リトライ\n    .setdefaultmaxretrycount(3)\n    // リトライ間隔10ms待機\n    .setdefaultsqlretrywaittime(10)\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nリトライapiを用いた実装は次のようになります。\n\n// アプリケーション全体のリトライ設定に従ってリトライを行う。（個別のリトライ指定なし）\ntry (sqlagent agent = config.agent()) {\n  // insert文の実行\n  // insert into product (product_id) values (/*product_id*/0);\n  agent.update("example/insert_product")\n    .param("product_id", 1)\n    .count();\n}\n\n// 個別にリトライ設定を上書きする（retry()を利用）\ntry (sqlagent agent = config.agent()) {\n  // insert文の実行\n  // insert into product (product_id) values (/*product_id*/0);\n  // リトライ対象エラーコードの場合、5回のリトライを20ms間隔で行う\n  agent.update("example/insert_product")\n    .param("product_id", 1)\n    .retry(5, 20)\n    .count();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# db更新処理をトランザクション内のみに強制 ( sqlagentfactory#setforceupdatewithintransaction ) \n複数のdb更新処理をまとめて行う際、途中で例外が発生するとdbデータが不整合な状態になる場合があります。このようなデータ不整合を防ぐためにはトランザクションを利用します。\nしかし、通常の設定ではトランザクションを開始しない状態でもdb更新処理を行うことが可能になっているため不具合に気付きにくいという問題があります。\nuroborosqlではトランザクションを開始していない状態でdb更新処理が行なわれた場合に例外をスローするオプションを提供しています。このオプションを使用することでdbデータの整合性を維持しやすくなります。\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // トランザクション内での更新を強制するかどうか\n    .setforceupdatewithintransaction(true)\n    )\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\nsqlagentfactory#setforceupdatewithintransaction()にtrueを指定することでトランザクションを開始していない状態でdb更新処理が行なわれた場合にuroborosqltransactionexceptionがスローされます。\n\nagent.required(() -> { // トランザクション開始\n  // トランザクション内でのdb更新なのでok\n  agent.updatewith("insert into employee (emp_no) values (/*emp_no*/1001)")\n    .param("emp_no", 1)\n    .count();\n  });\n});　// トランザクション終了\n\n// トランザクション外でのdb更新なので uroborosqltransactionexception がスローされる\nagent.updatewith("insert into department (dept_no, dept_name) values (/*dept_no*/1111, /*dept_name*/\'sales\')")\n  .param("dept_no", 2)\n  .param("dept_name", "export")\n  .count();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 明示的な行ロック時の待機時間(s)のデフォルト値設定 ( sqlagentfactory#setdefaultforupdatewaitseconds ) \nsqlentityquery#forupdatewait()による明示的な行ロックをおこなう際の待機時間を指定することができます。\n\nsqlconfig config = uroborosql.builder(...)\n  // sqlagentfactoryの設定\n  .setsqlagentfactory(new sqlagentfactoryimpl()\n    // 明示的な行ロック時の待機時間(s)デフォルト値\n    .setdefaultforupdatewaitseconds(10)\n    )\n  ).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n待機時間の初期値を設定することでsqlentityquery#forupdatewait()を発行する際に適用され、 待機時間を都度指定する必要がなくなります。\nsqlentityquery#forupdatewait(int)を使って個別に待機時間を指定した場合は個別設定が優先されます。',charsets:{cjk:!0}},{title:"Developer Tools",frontmatter:{meta:[{name:"og:title",content:"Developer Tools"},{name:"og:url",content:"/uroborosql-doc/developer_tools/"}]},regularPath:"/developer_tools/",relativePath:"developer_tools/README.md",key:"v-c0980c7c",path:"/developer_tools/",lastUpdated:"2019-9-4 23:08:33",headersStr:null,content:"# Developer Tools\n\n\n * CLI * https://github.com/future-architect/uroboroSQL-formatter\n   \n   \n * Sublime Text 3 Plugin * https://github.com/future-architect/Sublime-uroboroSQL-formatter\n   \n   \n * IntelliJ IDEA Platform Plugin * https://github.com/future-architect/idea-uroborosql-formatter\n   \n   \n * Eclipse Plugin * https://github.com/future-architect/eclipse-uroborosql-formatter",contentLowercase:"# developer tools\n\n\n * cli * https://github.com/future-architect/uroborosql-formatter\n   \n   \n * sublime text 3 plugin * https://github.com/future-architect/sublime-uroborosql-formatter\n   \n   \n * intellij idea platform plugin * https://github.com/future-architect/idea-uroborosql-formatter\n   \n   \n * eclipse plugin * https://github.com/future-architect/eclipse-uroborosql-formatter",charsets:{}},{title:"環境設定",frontmatter:{meta:[{name:"og:title",content:"環境設定"},{name:"og:url",content:"/uroborosql-doc/getting_started/"}]},regularPath:"/getting_started/",relativePath:"getting_started/README.md",key:"v-4db41f02",path:"/getting_started/",headers:[{level:2,title:"ビルドツールの設定",slug:"ビルドツールの設定",charIndex:9},{level:2,title:"事前準備",slug:"事前準備",charIndex:1557},{level:2,title:"サンプルプロジェクトの実行",slug:"サンプルプロジェクトの実行",charIndex:1730},{level:2,title:"サンプルプロジェクトの構成",slug:"サンプルプロジェクトの構成",charIndex:2272}],lastUpdated:"2020-11-19 23:55:38",headersStr:"ビルドツールの設定 事前準備 サンプルプロジェクトの実行 サンプルプロジェクトの構成",content:"# 環境設定\n# ビルドツールの設定\nuroboroSQLをMavenプロジェクトに組み込むには、pom.xmlに以下のライブラリ依存関係を追加して下さい。uroboroSQLはMaven Central Repositoryで公開されています。\n\n<dependency>\n  <groupId>jp.co.future</groupId>\n  <artifactId>uroborosql</artifactId>\n  <version>0.20.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\nまた、 より式言語ライブラリの選択が可能になりました。\n以下の2つのライブラリのうち、どちらかを選択してライブラリ依存関係に追加して下さい。\n\nOGNLを利用する場合\n\n<dependency>\n  <groupId>ognl</groupId>\n  <artifactId>ognl</artifactId>\n  <version>3.2.16</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\nSpring Expression Language(SpEL)を利用する場合\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-expression</artifactId>\n  <version>5.3.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\nuroboroSQLでREPLを使用する場合は追加で以下のライブラリ依存関係を追加してください。\n\n<dependency>\n  <groupId>org.jline</groupId>\n  <artifactId>jline</artifactId>\n  <version>3.17.1</version>\n</dependency>\n<dependency>\n  <groupId>org.fusesource.jansi</groupId>\n  <artifactId>jansi</artifactId>\n  <version>1.18</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nGradleプロジェクトの場合は、build.gradleのdependencies内に以下のライブラリ依存関係を追加してください。\n\ncompile group: 'jp.co.future', name: 'uroborosql', version: '0.20.2'\n\n// 式言語ライブラリとしてOGNLを使用する場合\ncompile group: 'ognl', name: 'ognl', version: '3.2.16'\n// 式言語ライブラリとしてSpring Expression Language(SpEL)を使用する場合\ncompile group: 'org.springframework', name: 'spring-expression', version: '5.3.1'\n\n// REPLを使用する場合\ncompile group: 'org.jline', name: 'jline', version: '3.17.1'\ncompile group: 'org.fusesource.jansi', name: 'jansi', version: '1.18'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nTIP\n\nuroboroSQLを利用するためには、Java8以上の環境が必要です。\n\n# 事前準備\n事前準備として、\n\n * Java8 or 11のいずれかのJDKディストリビューション * AdobtOpenJDK\n    * Amazon Corretto\n    * Oracle JDK\n   \n   \n * Apache Maven のv3.3.1(Java7対応版)以上のバージョン\n\nをインストールしてください。\n\n# サンプルプロジェクトの実行\nuroboroSQLのサンプルアプリケーションであるuroborosql-sampleを使ってuroboroSQLを動かしてみましょう。\n\nまず始めにuroborosql-sampleから最新のソースコードを取得します。\n\ngit clone https://github.com/future-architect/uroborosql-sample.git\n\n\n1\n取得できたらcloneしたフォルダに移動します。\n\ncd uroborosql-sample\n\n\n1\nまずはサンプルアプリケーションを実行してみましょう。 サンプルアプリケーションは以下の起動コマンドで実行します。\n\nmvn -PrunMain\n\n\n1\nこれでサンプルアプリケーションが実行されます。\n（初回実行時は必要なライブラリをダウンロードするため時間がかかります）\nアプリケーションの実行ログが出力され、Mavenが正常終了すれば成功です。 色々ログが流れますが、この中で\n\n * DB接続\n * テーブル作成と初期データの挿入\n * SQLによる検索\n * トランザクション\n * SQLによる挿入、更新、削除\n * バッチ更新\n\nといった一連の処理が実行されています。\n\n# サンプルプロジェクトの構成\nではサンプルアプリケーションの構成を見ていきましょう。\n\nuroborosql-sample\n├─REPL\n│      repl.properties\n│      \n└─src\n   └─main\n       ├─java\n       │  └─jp\n       │      └─co\n       │          └─future\n       │              └─uroborosql\n       │                  └─sample\n       │                      │  AbstractApiSample.java\n       │                      │  Main.java\n       │                      │  EntityApiSample.java\n       │                      │  SqlFileApiSample.java\n       │                      │  \n       │                      ├─entity\n       │                      │      Department.java\n       │                      │      Employee.java\n       │                      │      DeptEmp.java\n       │                      │      \n       │                      └─type\n       │                              Gender.java\n       │                              \n       └─resources\n           │  logback.xml\n           │  \n           ├─data\n           │      department.tsv\n           │      dept_emp.tsv\n           │      employee.tsv\n           │      \n           └─sql\n               ├─ddl\n               │      create_tables.sql\n               │      \n               ├─setup\n               │       insert_data.sql\n               │      \n               ├─department\n               │      insert_department.sql\n               │      select_department.sql\n               │      \n               ├─employee\n               │      insert_employee.sql\n               │      select_employee.sql\n               │      update_employee.sql\n               │      \n               └─relation\n                      insert_dept_emp.sql\n                      select_dept_emp.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n主要なファイルの説明です\n\nファイル                                             説明                                                              \nMain.java                                        uroborosql-sampleのメインプログラムです。ここから各サンプルコードの呼び出しを行っています。          \nSqlFileApiSample.java / EntityApiSample.java     提供されているAPIの種類毎のサンプルコードです。                                       \nDepartment.java / Employee.java / DeptEmp.java   テーブル構造を表すエンティティクラスです。サンプルコードの中で使用します。                           \nGender.java                                      性別を表すEnumクラスです。サンプルコードの中で使用します。                                 \nsqlフォルダ配下のSQL                                    uroborosqlで実行するSQLファイルです。                                       \ndataフォルダ配下のTSV                                   テーブルデータ作成用のTSVファイルです。Mainクラスの中でテーブルへの一括データ投入を行う際のデータとして利用します。   \nlogback.xml                                      ログ出力設定ファイルです。",contentLowercase:"# 環境設定\n# ビルドツールの設定\nuroborosqlをmavenプロジェクトに組み込むには、pom.xmlに以下のライブラリ依存関係を追加して下さい。uroborosqlはmaven central repositoryで公開されています。\n\n<dependency>\n  <groupid>jp.co.future</groupid>\n  <artifactid>uroborosql</artifactid>\n  <version>0.20.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\nまた、 より式言語ライブラリの選択が可能になりました。\n以下の2つのライブラリのうち、どちらかを選択してライブラリ依存関係に追加して下さい。\n\nognlを利用する場合\n\n<dependency>\n  <groupid>ognl</groupid>\n  <artifactid>ognl</artifactid>\n  <version>3.2.16</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\nspring expression language(spel)を利用する場合\n\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-expression</artifactid>\n  <version>5.3.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\nuroborosqlでreplを使用する場合は追加で以下のライブラリ依存関係を追加してください。\n\n<dependency>\n  <groupid>org.jline</groupid>\n  <artifactid>jline</artifactid>\n  <version>3.17.1</version>\n</dependency>\n<dependency>\n  <groupid>org.fusesource.jansi</groupid>\n  <artifactid>jansi</artifactid>\n  <version>1.18</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\ngradleプロジェクトの場合は、build.gradleのdependencies内に以下のライブラリ依存関係を追加してください。\n\ncompile group: 'jp.co.future', name: 'uroborosql', version: '0.20.2'\n\n// 式言語ライブラリとしてognlを使用する場合\ncompile group: 'ognl', name: 'ognl', version: '3.2.16'\n// 式言語ライブラリとしてspring expression language(spel)を使用する場合\ncompile group: 'org.springframework', name: 'spring-expression', version: '5.3.1'\n\n// replを使用する場合\ncompile group: 'org.jline', name: 'jline', version: '3.17.1'\ncompile group: 'org.fusesource.jansi', name: 'jansi', version: '1.18'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\ntip\n\nuroborosqlを利用するためには、java8以上の環境が必要です。\n\n# 事前準備\n事前準備として、\n\n * java8 or 11のいずれかのjdkディストリビューション * adobtopenjdk\n    * amazon corretto\n    * oracle jdk\n   \n   \n * apache maven のv3.3.1(java7対応版)以上のバージョン\n\nをインストールしてください。\n\n# サンプルプロジェクトの実行\nuroborosqlのサンプルアプリケーションであるuroborosql-sampleを使ってuroborosqlを動かしてみましょう。\n\nまず始めにuroborosql-sampleから最新のソースコードを取得します。\n\ngit clone https://github.com/future-architect/uroborosql-sample.git\n\n\n1\n取得できたらcloneしたフォルダに移動します。\n\ncd uroborosql-sample\n\n\n1\nまずはサンプルアプリケーションを実行してみましょう。 サンプルアプリケーションは以下の起動コマンドで実行します。\n\nmvn -prunmain\n\n\n1\nこれでサンプルアプリケーションが実行されます。\n（初回実行時は必要なライブラリをダウンロードするため時間がかかります）\nアプリケーションの実行ログが出力され、mavenが正常終了すれば成功です。 色々ログが流れますが、この中で\n\n * db接続\n * テーブル作成と初期データの挿入\n * sqlによる検索\n * トランザクション\n * sqlによる挿入、更新、削除\n * バッチ更新\n\nといった一連の処理が実行されています。\n\n# サンプルプロジェクトの構成\nではサンプルアプリケーションの構成を見ていきましょう。\n\nuroborosql-sample\n├─repl\n│      repl.properties\n│      \n└─src\n   └─main\n       ├─java\n       │  └─jp\n       │      └─co\n       │          └─future\n       │              └─uroborosql\n       │                  └─sample\n       │                      │  abstractapisample.java\n       │                      │  main.java\n       │                      │  entityapisample.java\n       │                      │  sqlfileapisample.java\n       │                      │  \n       │                      ├─entity\n       │                      │      department.java\n       │                      │      employee.java\n       │                      │      deptemp.java\n       │                      │      \n       │                      └─type\n       │                              gender.java\n       │                              \n       └─resources\n           │  logback.xml\n           │  \n           ├─data\n           │      department.tsv\n           │      dept_emp.tsv\n           │      employee.tsv\n           │      \n           └─sql\n               ├─ddl\n               │      create_tables.sql\n               │      \n               ├─setup\n               │       insert_data.sql\n               │      \n               ├─department\n               │      insert_department.sql\n               │      select_department.sql\n               │      \n               ├─employee\n               │      insert_employee.sql\n               │      select_employee.sql\n               │      update_employee.sql\n               │      \n               └─relation\n                      insert_dept_emp.sql\n                      select_dept_emp.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n主要なファイルの説明です\n\nファイル                                             説明                                                              \nmain.java                                        uroborosql-sampleのメインプログラムです。ここから各サンプルコードの呼び出しを行っています。          \nsqlfileapisample.java / entityapisample.java     提供されているapiの種類毎のサンプルコードです。                                       \ndepartment.java / employee.java / deptemp.java   テーブル構造を表すエンティティクラスです。サンプルコードの中で使用します。                           \ngender.java                                      性別を表すenumクラスです。サンプルコードの中で使用します。                                 \nsqlフォルダ配下のsql                                    uroborosqlで実行するsqlファイルです。                                       \ndataフォルダ配下のtsv                                   テーブルデータ作成用のtsvファイルです。mainクラスの中でテーブルへの一括データ投入を行う際のデータとして利用します。   \nlogback.xml                                      ログ出力設定ファイルです。",charsets:{cjk:!0}},{title:"開発者ガイド",frontmatter:{meta:[{name:"og:title",content:"開発者ガイド"},{name:"og:url",content:"/uroborosql-doc/developer_guide/"}]},regularPath:"/developer_guide/",relativePath:"developer_guide/README.md",key:"v-ba42e200",path:"/developer_guide/",headers:[{level:2,title:"ソースコードの取得",slug:"ソースコードの取得",charIndex:37},{level:2,title:"ソースのビルド",slug:"ソースのビルド",charIndex:135},{level:2,title:"テスト",slug:"テスト",charIndex:187},{level:2,title:"Mavenローカルリポジトリへのインストール",slug:"mavenローカルリポジトリへのインストール",charIndex:438},{level:2,title:"IDE",slug:"ide",charIndex:479},{level:3,title:"Eclipse",slug:"eclipse",charIndex:485},{level:3,title:"Intellij",slug:"intellij",charIndex:632},{level:2,title:"Continuous Integration",slug:"continuous-integration",charIndex:764},{level:2,title:"Issue Management",slug:"issue-management",charIndex:1007}],lastUpdated:"2019-9-4 23:08:33",headersStr:"ソースコードの取得 ソースのビルド テスト Mavenローカルリポジトリへのインストール IDE Eclipse Intellij Continuous Integration Issue Management",content:"# 開発者ガイド\nuroboroSQLを開発する人向けのガイドです\n\n# ソースコードの取得\nGitHubからソースをクローンする。\n\ngit clone https://github.com/future-architect/uroborosql.git\n\n\n1\n# ソースのビルド\nビルドにはApache Mavenを利用します。\n\nmvn compile\n\n\n1\n# テスト\nテストはJUnitで行います。\n\nmvn test\n\n\n1\nカバレッジはJacocoで確認することができます。\n\nmvn test jacoco:report\n\n\n1\ntarget/site/jacoco フォルダにjacocoカバレッジレポートが出力されます。\n\n開発を行う際は、Jadocコメントが正しく記載されているようにしてください。\njavadocプラグインでjavadocを生成し、エラーが出力されないことを確認してください。\n\nmvn javadoc:javadoc\n\n\n1\n# Mavenローカルリポジトリへのインストール\nmvn install\n\n\n1\n# IDE\n# Eclipse\nクローンしたフォルダをEclipseの既存Mavenプロジェクトとしてインポートしてください。\nMavenのinitializeフェーズでEclipseプロジェクトの文字コードをUTF-8にする設定が入っているので、インポートが完了すれば開発が始められる状態になります。\n\n# Intellij\nImport Project でクローンしたフォルダを指定してください。\nImport project from external model でMavenを選択してください。\nプロジェクトが読み込まれると開発が始められる状態になります。\n\n# Continuous Integration\nContinuous Integration(CI)はTravis CIで行っています。\n\nCIの状況確認は以下で行います。\n\n * https://travis-ci.org/future-architect/uroborosql\n\nまた、CIと合わせてカバレッジレポートをCoverallsで公開しています。\n\n * https://coveralls.io/github/future-architect/uroborosql\n\n# Issue Management\nIssueとPullRequestはGithubの機能を利用しています。\nコメントは英語で記載をお願いします。（Google翻訳がお勧めです）\n\n * https://github.com/future-architect/uroborosql/issues\n * https://github.com/future-architect/uroborosql/pulls",contentLowercase:"# 開発者ガイド\nuroborosqlを開発する人向けのガイドです\n\n# ソースコードの取得\ngithubからソースをクローンする。\n\ngit clone https://github.com/future-architect/uroborosql.git\n\n\n1\n# ソースのビルド\nビルドにはapache mavenを利用します。\n\nmvn compile\n\n\n1\n# テスト\nテストはjunitで行います。\n\nmvn test\n\n\n1\nカバレッジはjacocoで確認することができます。\n\nmvn test jacoco:report\n\n\n1\ntarget/site/jacoco フォルダにjacocoカバレッジレポートが出力されます。\n\n開発を行う際は、jadocコメントが正しく記載されているようにしてください。\njavadocプラグインでjavadocを生成し、エラーが出力されないことを確認してください。\n\nmvn javadoc:javadoc\n\n\n1\n# mavenローカルリポジトリへのインストール\nmvn install\n\n\n1\n# ide\n# eclipse\nクローンしたフォルダをeclipseの既存mavenプロジェクトとしてインポートしてください。\nmavenのinitializeフェーズでeclipseプロジェクトの文字コードをutf-8にする設定が入っているので、インポートが完了すれば開発が始められる状態になります。\n\n# intellij\nimport project でクローンしたフォルダを指定してください。\nimport project from external model でmavenを選択してください。\nプロジェクトが読み込まれると開発が始められる状態になります。\n\n# continuous integration\ncontinuous integration(ci)はtravis ciで行っています。\n\nciの状況確認は以下で行います。\n\n * https://travis-ci.org/future-architect/uroborosql\n\nまた、ciと合わせてカバレッジレポートをcoverallsで公開しています。\n\n * https://coveralls.io/github/future-architect/uroborosql\n\n# issue management\nissueとpullrequestはgithubの機能を利用しています。\nコメントは英語で記載をお願いします。（google翻訳がお勧めです）\n\n * https://github.com/future-architect/uroborosql/issues\n * https://github.com/future-architect/uroborosql/pulls",charsets:{cjk:!0}},{title:"SqlManager",frontmatter:{meta:[{name:"og:title",content:"SqlManager"},{name:"og:url",content:"/uroborosql-doc/configuration/sql-manager.html"}]},regularPath:"/configuration/sql-manager.html",relativePath:"configuration/sql-manager.md",key:"v-0244eaea",path:"/configuration/sql-manager.html",headers:[{level:2,title:"SQLファイルルートフォルダの設定",slug:"sqlファイルルートフォルダの設定",charIndex:1406},{level:3,title:"Spring bootでの利用",slug:"spring-bootでの利用",charIndex:1925},{level:2,title:"DB種類毎のファイルパス切り替え",slug:"db種類毎のファイルパス切り替え",charIndex:1082},{level:2,title:"SQLファイルの更新監視",slug:"sqlファイルの更新監視",charIndex:3015}],lastUpdated:"2019-9-4 23:08:33",headersStr:"SQLファイルルートフォルダの設定 Spring bootでの利用 DB種類毎のファイルパス切り替え SQLファイルの更新監視",content:'# SqlManager\nSqlManagerはSQLファイルを管理するクラスです。２つのクラスが提供されています。\n\nクラス                 説明                                      \nSqlManagerImpl      java.ioを利用したファイルアクセスを行うSqlManagerクラス。   \nNioSqlManagerImpl   java.nioを利用したファイルアクセスを行うSqlManagerクラス   \n\nクラスの特徴比較\n\n特徴                  SqlManagerImpl   NioSqlManagerImpl   補足                                \nSQLファイルルートフォルダ設定    〇                〇                                                     \nSQLファイルエンコーディング設定   〇                〇                                                     \n起動時のファイルキャッシュ       〇                △                   NioSqlManagerImplはファイルパスのみキャッシュ   \n遅延ファイルキャッシュ         ×                〇                                                     \njarファイル中のSQL参照      〇                〇                                                     \nzipファイル中のSQL参照      ×                〇                                                     \nカスタムファイルアクセス対応      ×                〇                   java.nio.fileパッケージを使用             \nファイル変更検知            ×                〇                                                     \nDB種類毎のファイルパス切り替え    ×                〇                                                     \n\n利用用途に応じてSqlManagerを選択してください。\nSqlManagerクラスの切り替えはビルダーAPIで行うことが出来ます。指定しない場合の初期値はSqlManagerImplになります。\n\nSqlConfig config = UroboroSQL.builder(...)\n  // NioSqlManagerの指定\n  .setSqlManager(new NioSqlManagerImpl(false)).build();\n\n\n1\n2\n3\n# SQLファイルルートフォルダの設定\nuroboroSQLは初期設定ではクラスパス上にあるsqlフォルダ配下のSQLを読み込みます。\nこのSQLファイルルートフォルダは変更することができます。\n\nSQLファイルルートフォルダの設定 (custom_sqlフォルダを指定)\n\n// SqlManagerImplの場合\nSqlConfig config = UroboroSQL.builder(...)\n  // SQLファイルのルートフォルダの設定(custom_sqlフォルダをルートフォルダにする場合)\n  .setSqlManager(new SqlManagerImpl("custom_sql")).build();\n\n// NioSqlManagerImplの場合\nSqlConfig config = UroboroSQL.builder(...)\n  // SQLファイルのルートフォルダの設定(custom_sqlフォルダをルートフォルダにする場合)\n  .setSqlManager(new NioSqlManagerImpl("custom_sql")).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# Spring bootでの利用 \nSpring boot利用時に実行可能jarにSQLファイルをリソースとして含める場合には、NioSqlManagerImplの場合、パスの指定を変更する必要があります。\n\n例えば、classpath:sqlにSQLファイルを配置している場合は、実行可能jarで起動する際にはアプリケーション設定を利用してBOOT-INF/classes/sqlのように指定してください。\n\n# DB種類毎のファイルパス切り替え \n後述するDialectを利用して、１つのSQL名に対してDB種類毎にファイルパスを切り替えることが出来ます。\n\n以下のようなファイル構成を例として説明します。\n\nsql\n  ├─employee\n  │    └─select_employee.sql  -- Oracle, postgresql以外のDB用SQL\n  ├─oracle\n  │   └─employee\n  │        └─select_employee.sql  -- oracle DB用SQL\n  └─postgresql\n      └─employee\n           └─select_employee.sql  -- postgresql DB用SQL\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nSQL名としてemployee/select_employeeを指定した場合、\nOracle DBの場合はsql/oracle/employee/select_employee.sqlが読み込まれます。\n同様にPostgresql DBの場合はsql/postgresql/employee/select_employee.sqlが読み込まれます。\nDBに対するDialect用のフォルダがない場合は通常通りsql/employee/select_employee.sqlが読み込まれます。\n\nDB毎のフォルダ名\n\nDB名                    フォルダ名        \nH2 DB                  h2           \nMicrosoft SQL Server   mssql        \nMySQL                  mysql        \nOracle                 oracle       \nPostgresql             postgresql   \nその他                    default      \n\n# SQLファイルの更新監視 \nNioSqlManagerImplでは、最初にSQLファイルの呼び出しがあったタイミングでSQLファイルをロードし、メモリ内にSQLをキャッシュします。 ファイル監視を有効にしている場合はキャッシュしているファイルに対してjava.nio.file.WatchServiceを利用したファイル監視を行い、 更新があった場合は自動的にリロードする仕組みを提供しています。\n\nWARNING\n\nファイル監視を行うのはファイルシステム上のファイルについてのみでjarファイルやzipファイル内のファイルに対してはファイル監視は行いません。\n\nアプリケーションの開発中など頻繁にSQLファイルを更新する場合に有効です。\nファイル監視の有無はNioSqlManagerImplの設定時に行います。\n\n// NioSqlManagerImplの場合\nSqlConfig config = UroboroSQL.builder(...)\n  // SQLファイル監視を有効化（初期値はfalse）\n  .setSqlManager(new NioSqlManagerImpl(true)).build();\n\n\n1\n2\n3\n4',contentLowercase:'# sqlmanager\nsqlmanagerはsqlファイルを管理するクラスです。２つのクラスが提供されています。\n\nクラス                 説明                                      \nsqlmanagerimpl      java.ioを利用したファイルアクセスを行うsqlmanagerクラス。   \nniosqlmanagerimpl   java.nioを利用したファイルアクセスを行うsqlmanagerクラス   \n\nクラスの特徴比較\n\n特徴                  sqlmanagerimpl   niosqlmanagerimpl   補足                                \nsqlファイルルートフォルダ設定    〇                〇                                                     \nsqlファイルエンコーディング設定   〇                〇                                                     \n起動時のファイルキャッシュ       〇                △                   niosqlmanagerimplはファイルパスのみキャッシュ   \n遅延ファイルキャッシュ         ×                〇                                                     \njarファイル中のsql参照      〇                〇                                                     \nzipファイル中のsql参照      ×                〇                                                     \nカスタムファイルアクセス対応      ×                〇                   java.nio.fileパッケージを使用             \nファイル変更検知            ×                〇                                                     \ndb種類毎のファイルパス切り替え    ×                〇                                                     \n\n利用用途に応じてsqlmanagerを選択してください。\nsqlmanagerクラスの切り替えはビルダーapiで行うことが出来ます。指定しない場合の初期値はsqlmanagerimplになります。\n\nsqlconfig config = uroborosql.builder(...)\n  // niosqlmanagerの指定\n  .setsqlmanager(new niosqlmanagerimpl(false)).build();\n\n\n1\n2\n3\n# sqlファイルルートフォルダの設定\nuroborosqlは初期設定ではクラスパス上にあるsqlフォルダ配下のsqlを読み込みます。\nこのsqlファイルルートフォルダは変更することができます。\n\nsqlファイルルートフォルダの設定 (custom_sqlフォルダを指定)\n\n// sqlmanagerimplの場合\nsqlconfig config = uroborosql.builder(...)\n  // sqlファイルのルートフォルダの設定(custom_sqlフォルダをルートフォルダにする場合)\n  .setsqlmanager(new sqlmanagerimpl("custom_sql")).build();\n\n// niosqlmanagerimplの場合\nsqlconfig config = uroborosql.builder(...)\n  // sqlファイルのルートフォルダの設定(custom_sqlフォルダをルートフォルダにする場合)\n  .setsqlmanager(new niosqlmanagerimpl("custom_sql")).build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# spring bootでの利用 \nspring boot利用時に実行可能jarにsqlファイルをリソースとして含める場合には、niosqlmanagerimplの場合、パスの指定を変更する必要があります。\n\n例えば、classpath:sqlにsqlファイルを配置している場合は、実行可能jarで起動する際にはアプリケーション設定を利用してboot-inf/classes/sqlのように指定してください。\n\n# db種類毎のファイルパス切り替え \n後述するdialectを利用して、１つのsql名に対してdb種類毎にファイルパスを切り替えることが出来ます。\n\n以下のようなファイル構成を例として説明します。\n\nsql\n  ├─employee\n  │    └─select_employee.sql  -- oracle, postgresql以外のdb用sql\n  ├─oracle\n  │   └─employee\n  │        └─select_employee.sql  -- oracle db用sql\n  └─postgresql\n      └─employee\n           └─select_employee.sql  -- postgresql db用sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nsql名としてemployee/select_employeeを指定した場合、\noracle dbの場合はsql/oracle/employee/select_employee.sqlが読み込まれます。\n同様にpostgresql dbの場合はsql/postgresql/employee/select_employee.sqlが読み込まれます。\ndbに対するdialect用のフォルダがない場合は通常通りsql/employee/select_employee.sqlが読み込まれます。\n\ndb毎のフォルダ名\n\ndb名                    フォルダ名        \nh2 db                  h2           \nmicrosoft sql server   mssql        \nmysql                  mysql        \noracle                 oracle       \npostgresql             postgresql   \nその他                    default      \n\n# sqlファイルの更新監視 \nniosqlmanagerimplでは、最初にsqlファイルの呼び出しがあったタイミングでsqlファイルをロードし、メモリ内にsqlをキャッシュします。 ファイル監視を有効にしている場合はキャッシュしているファイルに対してjava.nio.file.watchserviceを利用したファイル監視を行い、 更新があった場合は自動的にリロードする仕組みを提供しています。\n\nwarning\n\nファイル監視を行うのはファイルシステム上のファイルについてのみでjarファイルやzipファイル内のファイルに対してはファイル監視は行いません。\n\nアプリケーションの開発中など頻繁にsqlファイルを更新する場合に有効です。\nファイル監視の有無はniosqlmanagerimplの設定時に行います。\n\n// niosqlmanagerimplの場合\nsqlconfig config = uroborosql.builder(...)\n  // sqlファイル監視を有効化（初期値はfalse）\n  .setsqlmanager(new niosqlmanagerimpl(true)).build();\n\n\n1\n2\n3\n4',charsets:{cjk:!0}},{title:"SQLファイルを使用したDBアクセス",frontmatter:{meta:[{name:"og:title",content:"SQLファイルを使用したDBアクセス"},{name:"og:url",content:"/uroborosql-doc/getting_started/sql-file-access.html"}]},regularPath:"/getting_started/sql-file-access.html",relativePath:"getting_started/sql-file-access.md",key:"v-07b9536a",path:"/getting_started/sql-file-access.html",headers:[{level:2,title:"SqlConfigの生成",slug:"sqlconfigの生成",charIndex:23},{level:2,title:"テーブルの作成と初期データの登録",slug:"テーブルの作成と初期データの登録",charIndex:1131},{level:2,title:"SQLファイルを使用した検索",slug:"sqlファイルを使用した検索",charIndex:2074},{level:2,title:"SQLファイルを使用した行挿入",slug:"sqlファイルを使用した行挿入",charIndex:4117}],lastUpdated:"2019-9-23 23:39:17",headersStr:"SqlConfigの生成 テーブルの作成と初期データの登録 SQLファイルを使用した検索 SQLファイルを使用した行挿入",content:'# SQLファイルを使用したDBアクセス\n# SqlConfigの生成\nSQLファイルを使用したサンプルコード SqlFileApiSample.java を例として説明します。\n\nまず初めにコンストラクタの中で最初にSqlConfigクラスを作成しています。SqlConfigはuroboroSQLに対する各種の設定を保持するクラスで、SqlConfigの設定を変更することでuroboroSQLの動作を変更することが出来ます。\nここではH2DBのメモリDBに接続するSqlConfigインスタンスを生成しています。SqlConfigの生成にはUroboroSQLクラスによるBuilderAPIを使用します。\n\n * 基本的な呼出方法（DBへの接続情報のみ指定）\n\n// create SqlConfig\nSqlConfig config = UroboroSQL.builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "").build();\n\n\n1\n2\n * 設定のカスタマイズ（定数の指定や検索結果の取得方法変更）\n\n// create SqlConfig\nSqlConfig config = UroboroSQL\n    .builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "")\n    // SqlContextFactoryの設定（Enum定数パッケージ設定の追加）\n    .setSqlContextFactory(new SqlContextFactoryImpl()\n    .setEnumConstantPackageNames(Arrays.asList(Gender.class.getPackage().getName())))\n    // SqlAgentFactoryの設定（Queryの戻り値のMapのキー文字列のデフォルトCaseFormat設定の追加）\n    .setSqlAgentFactory(new SqlAgentFactoryImpl().setDefaultMapKeyCaseFormat(CaseFormat.CAMEL_CASE))\n    // SqlManagerの設定（NioSqlManagerImplの指定）\n    .setSqlManager(new NioSqlManagerImpl(false))\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nSqlConfig生成時のカスタマイズの詳細については 設定を参照してください。\n\n# テーブルの作成と初期データの登録\n次に事前準備として以降の処理で使用するテーブルの作成と初期データの登録を行います。（SqlFileApiSample#setupTableAndData()を参照）\nSQLを実行する場合はSqlConfigからSqlAgentを生成します。SqlAgentはuroboroSQLの中核となるクラスで、uroboroSQLの各操作はこのSqlAgentを使って行います。\nSqlAgentはAutoClosableインタフェースを実装しているので、try-with-resources文で囲むことで処理終了時に自動でクローズされます。 このときSqlAgentの中に保持するConnectionやStatementも合わせてクローズされるため、クローズ漏れによるメモリリークを防ぐことができます。\n\n// create SqlAgent. SqlAgent implements AutoClosable.\ntry (SqlAgent agent = config.agent()) {\n  // ここにSQL実行の処理を実装する\n}\n\n\n1\n2\n3\n4\nTIP\n\n以降の説明ではSqlAgentに対する処理はtry-with-resources文の中で行っているものとします。\n\nuroboroSQLでは実行するSQLをファイルパスに似た表現（以降 SQL名 と呼ぶ）で指定します。 下の例ではクラスパス上にあるsqlフォルダ配下のddl/create_tables.sqlを指定してSQL更新処理を実行します。\n\n更新処理を行う場合、SqlAgent#update("[SQL名]")メソッドを使用してSqlUpdateを取得しUpdateの実行を行います。\n\n// create table :  テーブル作成\nagent.update("ddl/create_tables").count();\n// setup data : 初期データ挿入\nagent.update("setup/insert_data").count();\n\n\n1\n2\n3\n4\nddl/create_tables.sqlで作成したテーブルの構成は以下になります。\n\n\n\n# SQLファイルを使用した検索\n登録したデータを検索します。検索を行う際は、SqlAgent#query("[SQL名]")メソッドを使用してSqlQueryを取得し、バインドパラメータの設定や検索の実行を行います。\n\nSqlQueryでは検索結果をいくつかの形式で取得することができます。\n\nメソッド                   説明                                                               \nSqlQuery#collect()     検索結果をList<Map>の形式で取得する                                           \nSqlQuery#stream()      検索結果をjava.util.Streamの形式で取得する                                    \nSqlQuery#resultSet()   検索結果のResultSetを取得する                                              \nSqlQuery#first()       検索結果の１件目を取得する。取得できない場合はRuntimeExceptionがスローされる                   \nSqlQuery#findFirst()   検索結果の１件目を取得する。戻り値はOptional                                       \nSqlQuery#one()         検索結果の１件目を取得する。取得できない場合、もしくは２件以上取得出来た場合はRuntimeExceptionがスローされる   \nSqlQuery#findOne()     検索結果の１件目を取得する。戻り値はOptional。２件以上取得出来た場合はRuntimeExceptionがスローされる   \n\n以下のように呼び出します。\n\n// no parameter : バインドパラメータ指定なしで検索\nList<Map<String, Object>> deps1 = agent.query("department/select_department")\n    .collect();\n\n// add bind parameter : バインドパラメータを設定して検索\nList<Map<String, Object>> deps2 = agent.query("department/select_department")\n    .param("deptNo", 1)\n    .collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nここで実行されるSQLは以下のようになっています。\n\n * department/select_department.sql\n\nselect /* _SQL_ID_ */\n    dept.dept_no        as    dept_no\n,   dept.dept_name      as    dept_name\n,   dept.lock_version   as    lock_version\nfrom\n    department    dept\n/*BEGIN*/\nwhere\n/*IF SF.isNotEmpty(deptNo)*/\nand dept.dept_no    = /*deptNo*/1\n/*END*/\n/*IF SF.isNotEmpty(deptName)*/\nand dept.dept_name  = /*deptName*/\'sample\'\n/*END*/\n/*END*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n * /* _SQL_ID_ */ はSQLを特定するID(SQL_IDといいます)を付与するための予約語で、実行時にSQLファイルを特定するための文字列に変換されます。\n * /*IF*/ ... /*END*/は条件分岐で、IFの後ろの評価式がTrueとなる場合に/*IF*/と/*END*/で囲まれた部分が出力されます。\n * /*deptNo*/はバインドパラメータで、実行時に?に変換され、SqlQueryに設定したパラメータがSQLへバインドされます。\n * /*deptNo*/の後ろの1はテスト用データです。このようにテスト用データをSQL文に記述しておくことで、このSQLを SQLクライアントツールで実行する際にエラーにならずに文法の確認を行うことができます。\n\nSQLで使用できる構文については2WaySQLを参照してください。\nまた、検索のより詳しい説明はSQLによる検索を参照してください。\n\n# SQLファイルを使用した行挿入\nテーブルに対して行挿入を行うことも出来ます。 行挿入を行う際は、SqlAgent#update("[SQL名]")メソッドを使用してSqlUpdateを取得し、続けてバインドパラメータの設定やSQLの実行を行います。\n\nagent.update("department/insert_department")\n    .param("deptName", "production")\n    .count();\n\n\n1\n2\n3\nここで実行されるSQLは以下のようになっています。\n\n * department/insert_department.sql\n\ninsert /* _SQL_ID_ */\ninto\n    department\n(\n    dept_name\n,   lock_version\n) values (\n    /*deptName*/\'sample\'\n,   0\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nSqlAgent#update("[SQL名]")では実行するSQLの内容によって行挿入の他に行更新や行削除を行うことが出来ます。より詳しい説明はSQLによる更新を参照してください。',contentLowercase:'# sqlファイルを使用したdbアクセス\n# sqlconfigの生成\nsqlファイルを使用したサンプルコード sqlfileapisample.java を例として説明します。\n\nまず初めにコンストラクタの中で最初にsqlconfigクラスを作成しています。sqlconfigはuroborosqlに対する各種の設定を保持するクラスで、sqlconfigの設定を変更することでuroborosqlの動作を変更することが出来ます。\nここではh2dbのメモリdbに接続するsqlconfigインスタンスを生成しています。sqlconfigの生成にはuroborosqlクラスによるbuilderapiを使用します。\n\n * 基本的な呼出方法（dbへの接続情報のみ指定）\n\n// create sqlconfig\nsqlconfig config = uroborosql.builder("jdbc:h2:mem:test;db_close_delay=-1", "sa", "").build();\n\n\n1\n2\n * 設定のカスタマイズ（定数の指定や検索結果の取得方法変更）\n\n// create sqlconfig\nsqlconfig config = uroborosql\n    .builder("jdbc:h2:mem:test;db_close_delay=-1", "sa", "")\n    // sqlcontextfactoryの設定（enum定数パッケージ設定の追加）\n    .setsqlcontextfactory(new sqlcontextfactoryimpl()\n    .setenumconstantpackagenames(arrays.aslist(gender.class.getpackage().getname())))\n    // sqlagentfactoryの設定（queryの戻り値のmapのキー文字列のデフォルトcaseformat設定の追加）\n    .setsqlagentfactory(new sqlagentfactoryimpl().setdefaultmapkeycaseformat(caseformat.camel_case))\n    // sqlmanagerの設定（niosqlmanagerimplの指定）\n    .setsqlmanager(new niosqlmanagerimpl(false))\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nsqlconfig生成時のカスタマイズの詳細については 設定を参照してください。\n\n# テーブルの作成と初期データの登録\n次に事前準備として以降の処理で使用するテーブルの作成と初期データの登録を行います。（sqlfileapisample#setuptableanddata()を参照）\nsqlを実行する場合はsqlconfigからsqlagentを生成します。sqlagentはuroborosqlの中核となるクラスで、uroborosqlの各操作はこのsqlagentを使って行います。\nsqlagentはautoclosableインタフェースを実装しているので、try-with-resources文で囲むことで処理終了時に自動でクローズされます。 このときsqlagentの中に保持するconnectionやstatementも合わせてクローズされるため、クローズ漏れによるメモリリークを防ぐことができます。\n\n// create sqlagent. sqlagent implements autoclosable.\ntry (sqlagent agent = config.agent()) {\n  // ここにsql実行の処理を実装する\n}\n\n\n1\n2\n3\n4\ntip\n\n以降の説明ではsqlagentに対する処理はtry-with-resources文の中で行っているものとします。\n\nuroborosqlでは実行するsqlをファイルパスに似た表現（以降 sql名 と呼ぶ）で指定します。 下の例ではクラスパス上にあるsqlフォルダ配下のddl/create_tables.sqlを指定してsql更新処理を実行します。\n\n更新処理を行う場合、sqlagent#update("[sql名]")メソッドを使用してsqlupdateを取得しupdateの実行を行います。\n\n// create table :  テーブル作成\nagent.update("ddl/create_tables").count();\n// setup data : 初期データ挿入\nagent.update("setup/insert_data").count();\n\n\n1\n2\n3\n4\nddl/create_tables.sqlで作成したテーブルの構成は以下になります。\n\n\n\n# sqlファイルを使用した検索\n登録したデータを検索します。検索を行う際は、sqlagent#query("[sql名]")メソッドを使用してsqlqueryを取得し、バインドパラメータの設定や検索の実行を行います。\n\nsqlqueryでは検索結果をいくつかの形式で取得することができます。\n\nメソッド                   説明                                                               \nsqlquery#collect()     検索結果をlist<map>の形式で取得する                                           \nsqlquery#stream()      検索結果をjava.util.streamの形式で取得する                                    \nsqlquery#resultset()   検索結果のresultsetを取得する                                              \nsqlquery#first()       検索結果の１件目を取得する。取得できない場合はruntimeexceptionがスローされる                   \nsqlquery#findfirst()   検索結果の１件目を取得する。戻り値はoptional                                       \nsqlquery#one()         検索結果の１件目を取得する。取得できない場合、もしくは２件以上取得出来た場合はruntimeexceptionがスローされる   \nsqlquery#findone()     検索結果の１件目を取得する。戻り値はoptional。２件以上取得出来た場合はruntimeexceptionがスローされる   \n\n以下のように呼び出します。\n\n// no parameter : バインドパラメータ指定なしで検索\nlist<map<string, object>> deps1 = agent.query("department/select_department")\n    .collect();\n\n// add bind parameter : バインドパラメータを設定して検索\nlist<map<string, object>> deps2 = agent.query("department/select_department")\n    .param("deptno", 1)\n    .collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nここで実行されるsqlは以下のようになっています。\n\n * department/select_department.sql\n\nselect /* _sql_id_ */\n    dept.dept_no        as    dept_no\n,   dept.dept_name      as    dept_name\n,   dept.lock_version   as    lock_version\nfrom\n    department    dept\n/*begin*/\nwhere\n/*if sf.isnotempty(deptno)*/\nand dept.dept_no    = /*deptno*/1\n/*end*/\n/*if sf.isnotempty(deptname)*/\nand dept.dept_name  = /*deptname*/\'sample\'\n/*end*/\n/*end*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n * /* _sql_id_ */ はsqlを特定するid(sql_idといいます)を付与するための予約語で、実行時にsqlファイルを特定するための文字列に変換されます。\n * /*if*/ ... /*end*/は条件分岐で、ifの後ろの評価式がtrueとなる場合に/*if*/と/*end*/で囲まれた部分が出力されます。\n * /*deptno*/はバインドパラメータで、実行時に?に変換され、sqlqueryに設定したパラメータがsqlへバインドされます。\n * /*deptno*/の後ろの1はテスト用データです。このようにテスト用データをsql文に記述しておくことで、このsqlを sqlクライアントツールで実行する際にエラーにならずに文法の確認を行うことができます。\n\nsqlで使用できる構文については2waysqlを参照してください。\nまた、検索のより詳しい説明はsqlによる検索を参照してください。\n\n# sqlファイルを使用した行挿入\nテーブルに対して行挿入を行うことも出来ます。 行挿入を行う際は、sqlagent#update("[sql名]")メソッドを使用してsqlupdateを取得し、続けてバインドパラメータの設定やsqlの実行を行います。\n\nagent.update("department/insert_department")\n    .param("deptname", "production")\n    .count();\n\n\n1\n2\n3\nここで実行されるsqlは以下のようになっています。\n\n * department/insert_department.sql\n\ninsert /* _sql_id_ */\ninto\n    department\n(\n    dept_name\n,   lock_version\n) values (\n    /*deptname*/\'sample\'\n,   0\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nsqlagent#update("[sql名]")では実行するsqlの内容によって行挿入の他に行更新や行削除を行うことが出来ます。より詳しい説明はsqlによる更新を参照してください。',charsets:{cjk:!0}},{title:"License",frontmatter:{meta:[{name:"og:title",content:"License"},{name:"og:url",content:"/uroborosql-doc/license/"}]},regularPath:"/license/",relativePath:"license/README.md",key:"v-7f98fc0c",path:"/license/",lastUpdated:"2019-9-4 23:08:33",headersStr:null,content:'# License\nMIT License\n\nCopyright (c) 2018\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.',contentLowercase:'# license\nmit license\n\ncopyright (c) 2018\n\npermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "software"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:\n\nthe above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.\n\nthe software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.',charsets:{}},{title:"SQL-REPL",frontmatter:{meta:[{name:"og:title",content:"SQL-REPL"},{name:"og:url",content:"/uroborosql-doc/getting_started/sql-repl.html"}]},regularPath:"/getting_started/sql-repl.html",relativePath:"getting_started/sql-repl.md",key:"v-9fe9d8ae",path:"/getting_started/sql-repl.html",headers:[{level:2,title:"REPLの利用",slug:"replの利用",charIndex:164},{level:2,title:"REPLの設定",slug:"replの設定",charIndex:16336}],lastUpdated:"2020-3-8 21:44:34",headersStr:"REPLの利用 REPLの設定",content:"# SQL-REPL\nここまではJavaアプリケーションからuroboroSQLを利用する場合の説明でした。uroboroSQLにはもう一つ特徴的な機能として、SQLを対話しながら実行するための REPL(Read-Eval-Print Loop) 機能を提供しています。\n\n今度はこのREPL機能を利用してみましょう。\n\n# REPLの利用\nREPLを起動するためにはjp.co.future.uroborosql.client.SqlREPLクラスを実行する必要があります。 サンプルアプリケーションでSqlREPLクラスを実行するためには以下のコマンドを実行します。\n\nmvn -PREPL\n\n\n1\n実行すると以下のようにタイトル表示とコマンド説明、設定値の情報が表示され、そのあとコマンド入力状態になります。\n\n===========================================================\n                 _                    ____   ___  _\n _   _ _ __ ___ | |__   ___  _ __ ___/ ___| / _ \\| |\n| | | | '__/ _ \\| '_ \\ / _ \\| '__/ _ \\___ \\| | | | |\n| |_| | | | (_) | |_) | (_) | | | (_) |__) | |_| | |___\n \\__,_|_|  \\___/|_.__/ \\___/|_|  \\___/____/ \\__\\_\\_____|\n\nuroboroSQL SQL REPL ver.0.20.2\n===========================================================\n\nCommands :\n        query   : execute query from loaded sql file.\n                ex1) query [sql file name]<Enter> : Execute SQL without parameter.\n                ex2) query [sql file name] param1=val1 param2=val2 ...<Enter> : Execute SQL with the specified parameters.\n        update  : execute update from loaded sql file.\n                ex1) update [sql file name]<Enter> : Execute SQL without parameter.\n                ex2) update [sql file name] param1=val1 param2=val2 ...<Enter> : Execute SQL with the specified parameters.\n        view    : view sql file.\n                ex) view [sql file name]<Enter> : Show sql file contents.\n        list    : list loaded sql files.\n                ex1) list<Enter> : Show all loaded sql file(s).\n                ex2) list keyword<Enter> : Show loaded sql file(s) filter by keyword.\n        history : list command history.\n                ex1) history<Enter> : Show all command history.\n                ex2) history keyword<Enter> : Show command history filter by keyword.\n        driver  : list loaded drivers.\n        desc    : describe table.\n                ex) desc [table name]<Enter> : Show table description.\n        generate: generate sql to access the table.\n                ex) generate [select/insert/update/delete] [table name]<Enter> : Show sql to access tables according to keywords.\n        parse   : parse sql file.\n                ex) parse [sql file name]<Enter> : Parse sql file.\n        cls     : clear screen.\n        exit    : exit SQL REPL. `CTRL+C` is an alias.\nProperties file path:REPL\\repl.properties\n[Properties]\ndb.password=\nsql.additionalClassPath=src/test/resources;target/test-classes;${user.home}/.m2/repository/com/h2database/h2/1.4.199/h2-1.4.199.jar\nsql.encoding=UTF-8\ndb.user=sa\nsql.versionColumnName=lock_no\nsql.optimisticLockSupplier=jp.co.future.uroborosql.mapping.FieldIncrementOptimisticLockSupplier\ndb.url=jdbc:h2:mem:repldb;DB_CLOSE_DELAY=-1;\nsqlContextFactory.enumConstantPackageNames=jp.co.future.uroborosql.context.test\nsqlContextFactory.constantClassNames=jp.co.future.uroborosql.context.test.TestConsts\ninitialize.\n\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nREPLを立ち上げた状態では接続したDB（H2DB メモリDB）には何もない状態なので、まずはテーブルを作成します。 サンプルアプリケーションで利用できるSQLファイルを確認しましょう。\n\nuroborosql > list[Enter]\n\n\n1\nと入力してください。\n\nuroborosql > list\nLIST:\nddl/create_tables\ndepartment/insert_department\ndepartment/select_department\nemployee/insert_employee\nemployee/select_employee\nemployee/update_employee\nrelation/insert_dept_emp\nrelation/select_dept_emp\nsetup/insert_data\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nロード済みのSQLファイルのSQL名がわかります。 テーブルを作成するためにddl/create_tablesを実行します。ddl/create_tablesはDDLなので実行するためにはupdateコマンドを使用します。\n\nuroborosql > u[Tab]\n\n\n1\nと入力してください。\n\nuroborosql > update\n\n\n1\nという風にuに一致するコマンドがコード補完されます。\n\nTIP\n\nREPLでは[Tab]を押下することでコマンドやSQL名、バインドパラメータなどが必要に応じでコード補完されます。\n\n続いて\n\nuroborosql > update d[Tab]\n\n\n1\nと入力してください。\n今度はddlに一致するSQL名の候補が表示されます。\n\nuroborosql > update d\nddl/create_tables   department/insert_department   department/select_department\n\n\n1\n2\nこの状態で[Tab]を入力することで候補を選択することが出来ます。\nddl/create_tablesを選択して[Enter]を入力すると以下のようになります。\n\nuroborosql > update ddl/create_tables\n\n\n1\nもう一度[Enter]を入力するとSQLが実行されます。\n\nuroborosql > update ddl/create_tables\n[DEBUG] Executed SQL[\n-- employee\ndrop table if exists employee cascade;\ncreate table employee (\n  emp_no number(6) auto_increment\n  , first_name varchar(20) not null\n  , last_name varchar(20) not null\n  , birth_date date not null\n  , gender char(1) not null\n  , lock_version number(10) not null default 0\n  , constraint employee_PKC primary key (emp_no)\n) ;\n-- dept_emp\ndrop table if exists dept_emp cascade;\ncreate table dept_emp (\n  emp_no number(6) not null\n  , dept_no number(4) not null\n  , constraint dept_emp_PKC primary key (emp_no,dept_no)\n) ;\n-- department\ndrop table if exists department cascade;\ncreate table department (\n  dept_no number(4) auto_increment\n  , dept_name varchar(100) not null\n  , lock_version number(10) not null default 0\n  , constraint department_PKC primary key (dept_no)\n) ;\ncomment on table employee is 'employee';\ncomment on column employee.emp_no is 'emp_no';\ncomment on column employee.first_name is 'first_name';\ncomment on column employee.last_name is 'last_name';\ncomment on column employee.birth_date is 'birth_date';\ncomment on column employee.gender is 'gender     ''F''emale/''M''ale/''O''ther';\ncomment on column employee.lock_version is 'lock_version';\ncomment on table dept_emp is 'dept_emp';\ncomment on column dept_emp.emp_no is 'emp_no';\ncomment on column dept_emp.dept_no is 'dept_no';\ncomment on table department is 'department';\ncomment on column department.dept_no is 'dept_no';\ncomment on column department.dept_name is 'dept_name';\ncomment on column department.lock_version is 'lock_version'\n]\n[DEBUG] Execute update SQL.\n[DEBUG] SQL execution time [ddl/create_tables] : [00:00:00.030]\nupdate sql[ddl/create_tables] end. row count=0\nuroborosql >\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nddl/create_tablesが実行され、DBにテーブルが作成されました。\n\nでは次に作成されたテーブルの定義情報を確認します。\nテーブル定義情報の確認にはdescコマンドを使用します。 ここではEMPLOYEEテーブルの定義情報を確認してみましょう。\n\nuroborosql > desc EMPLOYEE[Enter]\n\n\n1\nuroborosql > desc EMPLOYEE\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|TABLE_NAME|COLUMN_NAME |TYPE_NAME|COLUMN_SIZE|DECIMAL_DIGITS|IS_NULLABLE|COLUMN_DEF                                                                      |REMARKS                        |\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|EMPLOYEE  |EMP_NO      |DECIMAL  |          6|             0|NO         |(NEXT VALUE FOR \"PUBLIC\".\"SYSTEM_SEQUENCE_D06A5524_EC18_4835_A536_1F5A372BFC73\")|emp_no                         |\n|EMPLOYEE  |FIRST_NAME  |VARCHAR  |         20|             0|NO         |                                                                                |first_name                     |\n|EMPLOYEE  |LAST_NAME   |VARCHAR  |         20|             0|NO         |                                                                                |last_name                      |\n|EMPLOYEE  |BIRTH_DATE  |DATE     |         10|             0|NO         |                                                                                |birth_date                     |\n|EMPLOYEE  |GENDER      |CHAR     |          1|             0|NO         |                                                                                |gender        'F'emale/'M'ale/'O'ther|\n|EMPLOYEE  |LOCK_VERSION|DECIMAL  |         10|             0|NO         |                                                                               0|lock_version                   |\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nEMPLOYEEテーブルの定義情報が表形式で表示されました。\n\n続いて初期データを投入しましょう。\n\nsetup/insert_dataを実行します。\n\nuroborosql > update setup/insert_data[Enter]\n\n\n1\nuroborosql > update setup/insert_data\n[DEBUG] Executed SQL[\ninsert into department (dept_name) values ('sales');\ninsert into department (dept_name) values ('export');\ninsert into department (dept_name) values ('accounting');\ninsert into department (dept_name) values ('personnel');\ninsert into employee (first_name, last_name, birth_date, gender) values ('Bob', 'Smith', '1970-01-02', 'M');\ninsert into employee (first_name, last_name, birth_date, gender) values ('Susan', 'Davis', '1969-02-10', 'F');\ninsert into employee (first_name, last_name, birth_date, gender) values ('John', 'Wilson', '1982-05-08', 'M');\ninsert into employee (first_name, last_name, birth_date, gender) values ('Sharon', 'Johnson', '1990-01-20', 'F');\ninsert into employee (first_name, last_name, birth_date, gender) values ('Stephen', 'Taylor', '2003-12-31', 'M');\ninsert into dept_emp (emp_no, dept_no) values (1, 1);\ninsert into dept_emp (emp_no, dept_no) values (2, 1);\ninsert into dept_emp (emp_no, dept_no) values (3, 2);\ninsert into dept_emp (emp_no, dept_no) values (4, 3);\ninsert into dept_emp (emp_no, dept_no) values (5, 4)\n]\n[DEBUG] Execute update SQL.\n[DEBUG] SQL execution time [setup/insert_data] : [00:00:00.017]\nupdate sql[setup/insert_data] end. row count=1\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nこれでテーブルに初期データが挿入されました。 では、挿入したデータを検索してみましょう。\n\n検索を行う前に、検索を行うSQLの内容を確認してみましょう。\nSQLの内容を確認するにはviewコマンドを使用します。\n\nuroborosql > view department/select_department[Enter]\n\n\n1\nuroborosql > view department/select_department\nselect /* _SQL_ID_ */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\n/*BEGIN*/\nwhere\n/*IF SF.isNotEmpty(deptNo)*/\nand     dept.dept_no    =       /*deptNo*/1\n/*END*/\n/*IF SF.isNotEmpty(deptName)*/\nand     dept.dept_name  =       /*deptName*/'sample'\n/*END*/\n/*END*/\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n検索を行う場合はqueryコマンドを使用します。queryの後に実行するSQL名を指定します。\n\nuroborosql > query department/select_department[Enter]\n\n\n1\nuroborosql > query department/select_department\n[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptNo)], Result:[false], Parameter:[deptNo:[null]]\n[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptName)], Result:[false], Parameter:[deptName:[null]]\n[DEBUG] Executed SQL[\nselect /* department/select_department */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\n\n]\n[DEBUG] Execute search SQL.\n[INFO ]\n+-------+----------+------------+\n|DEPT_NO|DEPT_NAME |LOCK_VERSION|\n+-------+----------+------------+\n|      1|sales     |           0|\n|      2|export    |           0|\n|      3|accounting|           0|\n|      4|personnel |           0|\n+-------+----------+------------+\n[DEBUG] SQL execution time [department/select_department] : [00:00:00.078]\nquery sql[department/select_department] end.\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nここではバインドパラメータを指定しなかったため、絞込み条件のないSQLが実行され検索結果として4件のデータが取得できました。\n\nREPLでは上の結果のように、\n\n * 実行するSQL\n * バインドパラメータ\n * SQL文の中の評価式とその評価結果\n * 検索結果\n * 実行時間\n\nが表示されるので、SQLがどういう風に実行され、どういう値が取得できるのかが良く分かるようになっています。\n\n次にバインドパラメータを指定して検索してみましょう。\n\n検索するSQLにどのようなバインドパラメータや条件分岐があるかを確認するにはparseコマンドを使用します。\n\nuroborosql > parse department/select_department[Enter]\n\n\n1\nuroborosql > parse department/select_department\nPARSE:\n\nSQL :\nselect /* _SQL_ID_ */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\n/*BEGIN*/\nwhere\n/*IF SF.isNotEmpty(deptNo)*/\nand     dept.dept_no    =       /*deptNo*/1\n/*END*/\n/*IF SF.isNotEmpty(deptName)*/\nand     dept.dept_name  =       /*deptName*/'sample'\n/*END*/\n/*END*/\n\nBRANCHES :\n        BEGIN {\n                IF ( SF.isNotEmpty(deptNo) ) {\n                }\n                IF ( SF.isNotEmpty(deptName) ) {\n                }\n        }\n\nBIND_PARAMS :\n        deptName\n        deptNo\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nparseコマンドの結果は以下のようになります。\n\n * SQL : 解析対象のSQL\n * BRANCHES : 条件分岐\n * BIND_PARAMS : バインドパラメータ\n\n条件分岐では BEGINのスコープ（{}で囲まれた中）に２つのIF分岐が並んでいることがわかります。\nまた、バインドパラメータでは deptNoとdeptNameがあることがわかります。\n\nparseコマンドで確認したバインドパラメータを指定して検索を行います。\n\nuroborosql > query department/select_department deptNo=1[Enter]\n\n\n1\nuroborosql > query department/select_department deptNo=1\n[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptNo)], Result:[true], Parameter:[deptNo:[1]]\n[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptName)], Result:[false], Parameter:[deptName:[null]]\n[DEBUG] Executed SQL[\nselect /* department/select_department */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\nwhere\ndept.dept_no    =       ?/*deptNo*/\n\n]\n[DEBUG] Set the parameter.[INDEX[1], Parameter name[deptNo], Value[1], Class[Integer]]\n[DEBUG] Execute search SQL.\n[INFO ]\n+-------+---------+------------+\n|DEPT_NO|DEPT_NAME|LOCK_VERSION|\n+-------+---------+------------+\n|      1|sales    |           0|\n+-------+---------+------------+\n[DEBUG] SQL execution time [department/select_department] : [00:00:00.005]\nquery sql[department/select_department] end.\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\ndeptNoに1を指定して検索しています。 この時、SQL文の評価式である/*IF SF.isNotEmpty(deptNo)*/がtrueとなりSQLのwhere句にdept_noの条件が追加されバインドパラメータがバインドされます。\nその結果、検索結果は1件になっています。\n\nこのようにSQL名の後ろにバインドパラメータ名=値という形でバインドパラメータを記述することでバインドパラメータを指定してSQLを実行することができます。\n\nバインドパラメータが複数ある場合はバインドパラメータ名1=値1 バインドパラメータ名2=値2 ... という風に各パラメータの間を空白で区切って指定してください。\n\n * バインドパラメータを複数指定する例\n\nuroborosql > query department/select_department deptNo=1 deptName=sales[Enter]\n\n\n1\nuroborosql > query department/select_department deptNo=1 deptName=sales\n[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptNo)], Result:[true], Parameter:[deptNo:[1]]\n[DEBUG] Evaluation Expression:[SF.isNotEmpty(deptName)], Result:[true], Parameter:[deptName:[{115,97,108,101,115},0,0]]\n[DEBUG] Executed SQL[\nselect /* department/select_department */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\nwhere\ndept.dept_no    =       ?/*deptNo*/\nand     dept.dept_name  =       ?/*deptName*/\n\n]\n[DEBUG] Set the parameter.[INDEX[1], Parameter name[deptNo], Value[1], Class[Integer]]\n[DEBUG] Set the parameter.[INDEX[2], Parameter name[deptName], Value[sales], Class[String]]\n[DEBUG] Execute search SQL.\n[INFO ]\n+-------+---------+------------+\n|DEPT_NO|DEPT_NAME|LOCK_VERSION|\n+-------+---------+------------+\n|      1|sales    |           0|\n+-------+---------+------------+\n[DEBUG] SQL execution time [department/select_department] : [00:00:00.006]\nquery sql[department/select_department] end.\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nREPLを終了する場合はコマンドquit,もしくはexitを入力してください。\n\nuroborosql > quit[Enter]\nSQL REPL end.\n\n\n1\n2\n終了メッセージが表示されてREPLが終了します。\n\nREPLには他にも以下のコマンドがあります。\n\nコマンド       説明                                                    \nquery      検索SQLを実行します                                           \nupdate     更新SQL（insert/update/delete）やDDLを実行します                 \nview       SQL名で指定したSQLの内容を表示します                                 \nlist       使用可能なSQL名の一覧を表示します                                    \nhistory    実行したコマンドの履歴を表示します                                     \ndriver     使用可能なJDBCドライバーの一覧を表示します                               \ndesc       指定したテーブルの定義情報を表示します                                   \ngenerate   指定したテーブルに対するselect/insert/update/deleteを行うSQLを生成します   \nparse      指定したSQLで使用されているバインドパラメータやIF分岐条件を抽出して表示します             \ncls        コンソール画面のクリア                                           \nexit       REPLを終了します                                            \nhelp       利用できるコマンドの説明を表示します                                    \n\n# REPLの設定\nさて、ここまでREPLの操作を説明してきましたが、DB接続情報やSQLファイルの場所はどこで指定していたのでしょうか。 実はjp.co.future.uroborosql.client.SqlREPLを実行する際、引数としてプロパティファイルを指定します。このプロパティファイルにDB接続情報やSQLファイルの場所などREPLを実行するのに必要な情報が記載されています。\n\npom.xmlのREPL実行部分\n\n<plugin>\n  <groupId>org.codehaus.mojo</groupId>\n  <artifactId>exec-maven-plugin</artifactId>\n  <executions>\n    <execution>\n      <id>repl</id>\n      <goals>\n        <goal>java</goal>\n      </goals>\n      <configuration>\n        <workingDirectory>${basedir}</workingDirectory>\n        <mainClass>jp.co.future.uroborosql.client.SqlREPL</mainClass>\n        <arguments>\n          <argument>REPL/repl.properties</argument>\n        </arguments>\n      </configuration>\n      <phase>process-test-classes</phase>\n    </execution>\n  </executions>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n初期設定ではプロパティファイルの場所はREPL/repl.propertiesになっています。\n\n * REPL/repl.properties\n\ndb.url=jdbc:h2:file:./target/db/repldb;\ndb.user=sa\ndb.password=\n\nsql.additionalClassPath=${user.home}/.m2/repository/com/h2database/h2/1.4.192/h2-1.4.192.jar\n\n\n1\n2\n3\n4\n5\nプロパティ名                                       説明                                                                                                                                                                \ndb.url                                       DB接続URL                                                                                                                                                           \ndb.schema                                    DB接続スキーマ                                                                                                                                                          \ndb.user                                      DB接続ユーザ                                                                                                                                                           \ndb.password                                  DB接続パスワード                                                                                                                                                         \nsql.loadPath                                 SQLをロードするパス。初期値はsql                                                                                                                                               \nsql.encoding                                 SQLファイルのエンコーディング。初期値はUTF-8                                                                                                                                        \nsql.fileExtension                            ロードするSQLファイルの拡張子。初期値は.sql                                                                                                                                         \nsql.detectChanges                            SQLファイルの変更検知を行うかどうか。初期値はtrue                                                                                                                                      \nsql.additionalClassPath                      REPL起動時に起動時クラスパス以外でクラスパスに追加する場所。;で区切ることで複数指定可。SQLファイルのルート（sqlフォルダの親フォルダ）をクラスパスに追加することで、自動的にSQLファイルがロードされます。合わせて接続するDBのJDBCドライバを含むJarを指定することで動的にJDBCドライバを読み込みます。   \nsqlContextFactory.constantClassNames         SqlContextFactoryに登録する定数クラスを指定。,で区切ることで複数指定可。 ex) jp.co.future.uroborosql.context.test.TestConsts                                                                 \nsqlContextFactory.enumConstantPackageNames   SqlContextFactoryに登録するEnum定数パッケージ名を指定。,で区切ることで複数指定可。ex) jp.co.future.uroborosql.context.test                                                                      \n\nこのプロパティファイルを変更することでいろいろなDBに接続することができるようになります。\n\nこれまで見てきたようにREPLを利用することで簡単にSQL実行や動作確認ができるので、SQL開発には欠かせないツールになります。 色々なSQLを記述してREPLで試してみてください。\n\nこれで Getting Started は終了です。\n\nuroboroSQLで使用するSQLの文法や基本的な操作については基本操作を参照してください。",contentLowercase:"# sql-repl\nここまではjavaアプリケーションからuroborosqlを利用する場合の説明でした。uroborosqlにはもう一つ特徴的な機能として、sqlを対話しながら実行するための repl(read-eval-print loop) 機能を提供しています。\n\n今度はこのrepl機能を利用してみましょう。\n\n# replの利用\nreplを起動するためにはjp.co.future.uroborosql.client.sqlreplクラスを実行する必要があります。 サンプルアプリケーションでsqlreplクラスを実行するためには以下のコマンドを実行します。\n\nmvn -prepl\n\n\n1\n実行すると以下のようにタイトル表示とコマンド説明、設定値の情報が表示され、そのあとコマンド入力状態になります。\n\n===========================================================\n                 _                    ____   ___  _\n _   _ _ __ ___ | |__   ___  _ __ ___/ ___| / _ \\| |\n| | | | '__/ _ \\| '_ \\ / _ \\| '__/ _ \\___ \\| | | | |\n| |_| | | | (_) | |_) | (_) | | | (_) |__) | |_| | |___\n \\__,_|_|  \\___/|_.__/ \\___/|_|  \\___/____/ \\__\\_\\_____|\n\nuroborosql sql repl ver.0.20.2\n===========================================================\n\ncommands :\n        query   : execute query from loaded sql file.\n                ex1) query [sql file name]<enter> : execute sql without parameter.\n                ex2) query [sql file name] param1=val1 param2=val2 ...<enter> : execute sql with the specified parameters.\n        update  : execute update from loaded sql file.\n                ex1) update [sql file name]<enter> : execute sql without parameter.\n                ex2) update [sql file name] param1=val1 param2=val2 ...<enter> : execute sql with the specified parameters.\n        view    : view sql file.\n                ex) view [sql file name]<enter> : show sql file contents.\n        list    : list loaded sql files.\n                ex1) list<enter> : show all loaded sql file(s).\n                ex2) list keyword<enter> : show loaded sql file(s) filter by keyword.\n        history : list command history.\n                ex1) history<enter> : show all command history.\n                ex2) history keyword<enter> : show command history filter by keyword.\n        driver  : list loaded drivers.\n        desc    : describe table.\n                ex) desc [table name]<enter> : show table description.\n        generate: generate sql to access the table.\n                ex) generate [select/insert/update/delete] [table name]<enter> : show sql to access tables according to keywords.\n        parse   : parse sql file.\n                ex) parse [sql file name]<enter> : parse sql file.\n        cls     : clear screen.\n        exit    : exit sql repl. `ctrl+c` is an alias.\nproperties file path:repl\\repl.properties\n[properties]\ndb.password=\nsql.additionalclasspath=src/test/resources;target/test-classes;${user.home}/.m2/repository/com/h2database/h2/1.4.199/h2-1.4.199.jar\nsql.encoding=utf-8\ndb.user=sa\nsql.versioncolumnname=lock_no\nsql.optimisticlocksupplier=jp.co.future.uroborosql.mapping.fieldincrementoptimisticlocksupplier\ndb.url=jdbc:h2:mem:repldb;db_close_delay=-1;\nsqlcontextfactory.enumconstantpackagenames=jp.co.future.uroborosql.context.test\nsqlcontextfactory.constantclassnames=jp.co.future.uroborosql.context.test.testconsts\ninitialize.\n\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nreplを立ち上げた状態では接続したdb（h2db メモリdb）には何もない状態なので、まずはテーブルを作成します。 サンプルアプリケーションで利用できるsqlファイルを確認しましょう。\n\nuroborosql > list[enter]\n\n\n1\nと入力してください。\n\nuroborosql > list\nlist:\nddl/create_tables\ndepartment/insert_department\ndepartment/select_department\nemployee/insert_employee\nemployee/select_employee\nemployee/update_employee\nrelation/insert_dept_emp\nrelation/select_dept_emp\nsetup/insert_data\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nロード済みのsqlファイルのsql名がわかります。 テーブルを作成するためにddl/create_tablesを実行します。ddl/create_tablesはddlなので実行するためにはupdateコマンドを使用します。\n\nuroborosql > u[tab]\n\n\n1\nと入力してください。\n\nuroborosql > update\n\n\n1\nという風にuに一致するコマンドがコード補完されます。\n\ntip\n\nreplでは[tab]を押下することでコマンドやsql名、バインドパラメータなどが必要に応じでコード補完されます。\n\n続いて\n\nuroborosql > update d[tab]\n\n\n1\nと入力してください。\n今度はddlに一致するsql名の候補が表示されます。\n\nuroborosql > update d\nddl/create_tables   department/insert_department   department/select_department\n\n\n1\n2\nこの状態で[tab]を入力することで候補を選択することが出来ます。\nddl/create_tablesを選択して[enter]を入力すると以下のようになります。\n\nuroborosql > update ddl/create_tables\n\n\n1\nもう一度[enter]を入力するとsqlが実行されます。\n\nuroborosql > update ddl/create_tables\n[debug] executed sql[\n-- employee\ndrop table if exists employee cascade;\ncreate table employee (\n  emp_no number(6) auto_increment\n  , first_name varchar(20) not null\n  , last_name varchar(20) not null\n  , birth_date date not null\n  , gender char(1) not null\n  , lock_version number(10) not null default 0\n  , constraint employee_pkc primary key (emp_no)\n) ;\n-- dept_emp\ndrop table if exists dept_emp cascade;\ncreate table dept_emp (\n  emp_no number(6) not null\n  , dept_no number(4) not null\n  , constraint dept_emp_pkc primary key (emp_no,dept_no)\n) ;\n-- department\ndrop table if exists department cascade;\ncreate table department (\n  dept_no number(4) auto_increment\n  , dept_name varchar(100) not null\n  , lock_version number(10) not null default 0\n  , constraint department_pkc primary key (dept_no)\n) ;\ncomment on table employee is 'employee';\ncomment on column employee.emp_no is 'emp_no';\ncomment on column employee.first_name is 'first_name';\ncomment on column employee.last_name is 'last_name';\ncomment on column employee.birth_date is 'birth_date';\ncomment on column employee.gender is 'gender     ''f''emale/''m''ale/''o''ther';\ncomment on column employee.lock_version is 'lock_version';\ncomment on table dept_emp is 'dept_emp';\ncomment on column dept_emp.emp_no is 'emp_no';\ncomment on column dept_emp.dept_no is 'dept_no';\ncomment on table department is 'department';\ncomment on column department.dept_no is 'dept_no';\ncomment on column department.dept_name is 'dept_name';\ncomment on column department.lock_version is 'lock_version'\n]\n[debug] execute update sql.\n[debug] sql execution time [ddl/create_tables] : [00:00:00.030]\nupdate sql[ddl/create_tables] end. row count=0\nuroborosql >\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nddl/create_tablesが実行され、dbにテーブルが作成されました。\n\nでは次に作成されたテーブルの定義情報を確認します。\nテーブル定義情報の確認にはdescコマンドを使用します。 ここではemployeeテーブルの定義情報を確認してみましょう。\n\nuroborosql > desc employee[enter]\n\n\n1\nuroborosql > desc employee\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|table_name|column_name |type_name|column_size|decimal_digits|is_nullable|column_def                                                                      |remarks                        |\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|employee  |emp_no      |decimal  |          6|             0|no         |(next value for \"public\".\"system_sequence_d06a5524_ec18_4835_a536_1f5a372bfc73\")|emp_no                         |\n|employee  |first_name  |varchar  |         20|             0|no         |                                                                                |first_name                     |\n|employee  |last_name   |varchar  |         20|             0|no         |                                                                                |last_name                      |\n|employee  |birth_date  |date     |         10|             0|no         |                                                                                |birth_date                     |\n|employee  |gender      |char     |          1|             0|no         |                                                                                |gender        'f'emale/'m'ale/'o'ther|\n|employee  |lock_version|decimal  |         10|             0|no         |                                                                               0|lock_version                   |\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nemployeeテーブルの定義情報が表形式で表示されました。\n\n続いて初期データを投入しましょう。\n\nsetup/insert_dataを実行します。\n\nuroborosql > update setup/insert_data[enter]\n\n\n1\nuroborosql > update setup/insert_data\n[debug] executed sql[\ninsert into department (dept_name) values ('sales');\ninsert into department (dept_name) values ('export');\ninsert into department (dept_name) values ('accounting');\ninsert into department (dept_name) values ('personnel');\ninsert into employee (first_name, last_name, birth_date, gender) values ('bob', 'smith', '1970-01-02', 'm');\ninsert into employee (first_name, last_name, birth_date, gender) values ('susan', 'davis', '1969-02-10', 'f');\ninsert into employee (first_name, last_name, birth_date, gender) values ('john', 'wilson', '1982-05-08', 'm');\ninsert into employee (first_name, last_name, birth_date, gender) values ('sharon', 'johnson', '1990-01-20', 'f');\ninsert into employee (first_name, last_name, birth_date, gender) values ('stephen', 'taylor', '2003-12-31', 'm');\ninsert into dept_emp (emp_no, dept_no) values (1, 1);\ninsert into dept_emp (emp_no, dept_no) values (2, 1);\ninsert into dept_emp (emp_no, dept_no) values (3, 2);\ninsert into dept_emp (emp_no, dept_no) values (4, 3);\ninsert into dept_emp (emp_no, dept_no) values (5, 4)\n]\n[debug] execute update sql.\n[debug] sql execution time [setup/insert_data] : [00:00:00.017]\nupdate sql[setup/insert_data] end. row count=1\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nこれでテーブルに初期データが挿入されました。 では、挿入したデータを検索してみましょう。\n\n検索を行う前に、検索を行うsqlの内容を確認してみましょう。\nsqlの内容を確認するにはviewコマンドを使用します。\n\nuroborosql > view department/select_department[enter]\n\n\n1\nuroborosql > view department/select_department\nselect /* _sql_id_ */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\n/*begin*/\nwhere\n/*if sf.isnotempty(deptno)*/\nand     dept.dept_no    =       /*deptno*/1\n/*end*/\n/*if sf.isnotempty(deptname)*/\nand     dept.dept_name  =       /*deptname*/'sample'\n/*end*/\n/*end*/\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n検索を行う場合はqueryコマンドを使用します。queryの後に実行するsql名を指定します。\n\nuroborosql > query department/select_department[enter]\n\n\n1\nuroborosql > query department/select_department\n[debug] evaluation expression:[sf.isnotempty(deptno)], result:[false], parameter:[deptno:[null]]\n[debug] evaluation expression:[sf.isnotempty(deptname)], result:[false], parameter:[deptname:[null]]\n[debug] executed sql[\nselect /* department/select_department */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\n\n]\n[debug] execute search sql.\n[info ]\n+-------+----------+------------+\n|dept_no|dept_name |lock_version|\n+-------+----------+------------+\n|      1|sales     |           0|\n|      2|export    |           0|\n|      3|accounting|           0|\n|      4|personnel |           0|\n+-------+----------+------------+\n[debug] sql execution time [department/select_department] : [00:00:00.078]\nquery sql[department/select_department] end.\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nここではバインドパラメータを指定しなかったため、絞込み条件のないsqlが実行され検索結果として4件のデータが取得できました。\n\nreplでは上の結果のように、\n\n * 実行するsql\n * バインドパラメータ\n * sql文の中の評価式とその評価結果\n * 検索結果\n * 実行時間\n\nが表示されるので、sqlがどういう風に実行され、どういう値が取得できるのかが良く分かるようになっています。\n\n次にバインドパラメータを指定して検索してみましょう。\n\n検索するsqlにどのようなバインドパラメータや条件分岐があるかを確認するにはparseコマンドを使用します。\n\nuroborosql > parse department/select_department[enter]\n\n\n1\nuroborosql > parse department/select_department\nparse:\n\nsql :\nselect /* _sql_id_ */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\n/*begin*/\nwhere\n/*if sf.isnotempty(deptno)*/\nand     dept.dept_no    =       /*deptno*/1\n/*end*/\n/*if sf.isnotempty(deptname)*/\nand     dept.dept_name  =       /*deptname*/'sample'\n/*end*/\n/*end*/\n\nbranches :\n        begin {\n                if ( sf.isnotempty(deptno) ) {\n                }\n                if ( sf.isnotempty(deptname) ) {\n                }\n        }\n\nbind_params :\n        deptname\n        deptno\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nparseコマンドの結果は以下のようになります。\n\n * sql : 解析対象のsql\n * branches : 条件分岐\n * bind_params : バインドパラメータ\n\n条件分岐では beginのスコープ（{}で囲まれた中）に２つのif分岐が並んでいることがわかります。\nまた、バインドパラメータでは deptnoとdeptnameがあることがわかります。\n\nparseコマンドで確認したバインドパラメータを指定して検索を行います。\n\nuroborosql > query department/select_department deptno=1[enter]\n\n\n1\nuroborosql > query department/select_department deptno=1\n[debug] evaluation expression:[sf.isnotempty(deptno)], result:[true], parameter:[deptno:[1]]\n[debug] evaluation expression:[sf.isnotempty(deptname)], result:[false], parameter:[deptname:[null]]\n[debug] executed sql[\nselect /* department/select_department */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\nwhere\ndept.dept_no    =       ?/*deptno*/\n\n]\n[debug] set the parameter.[index[1], parameter name[deptno], value[1], class[integer]]\n[debug] execute search sql.\n[info ]\n+-------+---------+------------+\n|dept_no|dept_name|lock_version|\n+-------+---------+------------+\n|      1|sales    |           0|\n+-------+---------+------------+\n[debug] sql execution time [department/select_department] : [00:00:00.005]\nquery sql[department/select_department] end.\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\ndeptnoに1を指定して検索しています。 この時、sql文の評価式である/*if sf.isnotempty(deptno)*/がtrueとなりsqlのwhere句にdept_noの条件が追加されバインドパラメータがバインドされます。\nその結果、検索結果は1件になっています。\n\nこのようにsql名の後ろにバインドパラメータ名=値という形でバインドパラメータを記述することでバインドパラメータを指定してsqlを実行することができます。\n\nバインドパラメータが複数ある場合はバインドパラメータ名1=値1 バインドパラメータ名2=値2 ... という風に各パラメータの間を空白で区切って指定してください。\n\n * バインドパラメータを複数指定する例\n\nuroborosql > query department/select_department deptno=1 deptname=sales[enter]\n\n\n1\nuroborosql > query department/select_department deptno=1 deptname=sales\n[debug] evaluation expression:[sf.isnotempty(deptno)], result:[true], parameter:[deptno:[1]]\n[debug] evaluation expression:[sf.isnotempty(deptname)], result:[true], parameter:[deptname:[{115,97,108,101,115},0,0]]\n[debug] executed sql[\nselect /* department/select_department */\n        dept.dept_no            as      dept_no\n,       dept.dept_name          as      dept_name\n,       dept.lock_version       as      lock_version\nfrom\n        department      dept\nwhere\ndept.dept_no    =       ?/*deptno*/\nand     dept.dept_name  =       ?/*deptname*/\n\n]\n[debug] set the parameter.[index[1], parameter name[deptno], value[1], class[integer]]\n[debug] set the parameter.[index[2], parameter name[deptname], value[sales], class[string]]\n[debug] execute search sql.\n[info ]\n+-------+---------+------------+\n|dept_no|dept_name|lock_version|\n+-------+---------+------------+\n|      1|sales    |           0|\n+-------+---------+------------+\n[debug] sql execution time [department/select_department] : [00:00:00.006]\nquery sql[department/select_department] end.\nuroborosql >\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nreplを終了する場合はコマンドquit,もしくはexitを入力してください。\n\nuroborosql > quit[enter]\nsql repl end.\n\n\n1\n2\n終了メッセージが表示されてreplが終了します。\n\nreplには他にも以下のコマンドがあります。\n\nコマンド       説明                                                    \nquery      検索sqlを実行します                                           \nupdate     更新sql（insert/update/delete）やddlを実行します                 \nview       sql名で指定したsqlの内容を表示します                                 \nlist       使用可能なsql名の一覧を表示します                                    \nhistory    実行したコマンドの履歴を表示します                                     \ndriver     使用可能なjdbcドライバーの一覧を表示します                               \ndesc       指定したテーブルの定義情報を表示します                                   \ngenerate   指定したテーブルに対するselect/insert/update/deleteを行うsqlを生成します   \nparse      指定したsqlで使用されているバインドパラメータやif分岐条件を抽出して表示します             \ncls        コンソール画面のクリア                                           \nexit       replを終了します                                            \nhelp       利用できるコマンドの説明を表示します                                    \n\n# replの設定\nさて、ここまでreplの操作を説明してきましたが、db接続情報やsqlファイルの場所はどこで指定していたのでしょうか。 実はjp.co.future.uroborosql.client.sqlreplを実行する際、引数としてプロパティファイルを指定します。このプロパティファイルにdb接続情報やsqlファイルの場所などreplを実行するのに必要な情報が記載されています。\n\npom.xmlのrepl実行部分\n\n<plugin>\n  <groupid>org.codehaus.mojo</groupid>\n  <artifactid>exec-maven-plugin</artifactid>\n  <executions>\n    <execution>\n      <id>repl</id>\n      <goals>\n        <goal>java</goal>\n      </goals>\n      <configuration>\n        <workingdirectory>${basedir}</workingdirectory>\n        <mainclass>jp.co.future.uroborosql.client.sqlrepl</mainclass>\n        <arguments>\n          <argument>repl/repl.properties</argument>\n        </arguments>\n      </configuration>\n      <phase>process-test-classes</phase>\n    </execution>\n  </executions>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n初期設定ではプロパティファイルの場所はrepl/repl.propertiesになっています。\n\n * repl/repl.properties\n\ndb.url=jdbc:h2:file:./target/db/repldb;\ndb.user=sa\ndb.password=\n\nsql.additionalclasspath=${user.home}/.m2/repository/com/h2database/h2/1.4.192/h2-1.4.192.jar\n\n\n1\n2\n3\n4\n5\nプロパティ名                                       説明                                                                                                                                                                \ndb.url                                       db接続url                                                                                                                                                           \ndb.schema                                    db接続スキーマ                                                                                                                                                          \ndb.user                                      db接続ユーザ                                                                                                                                                           \ndb.password                                  db接続パスワード                                                                                                                                                         \nsql.loadpath                                 sqlをロードするパス。初期値はsql                                                                                                                                               \nsql.encoding                                 sqlファイルのエンコーディング。初期値はutf-8                                                                                                                                        \nsql.fileextension                            ロードするsqlファイルの拡張子。初期値は.sql                                                                                                                                         \nsql.detectchanges                            sqlファイルの変更検知を行うかどうか。初期値はtrue                                                                                                                                      \nsql.additionalclasspath                      repl起動時に起動時クラスパス以外でクラスパスに追加する場所。;で区切ることで複数指定可。sqlファイルのルート（sqlフォルダの親フォルダ）をクラスパスに追加することで、自動的にsqlファイルがロードされます。合わせて接続するdbのjdbcドライバを含むjarを指定することで動的にjdbcドライバを読み込みます。   \nsqlcontextfactory.constantclassnames         sqlcontextfactoryに登録する定数クラスを指定。,で区切ることで複数指定可。 ex) jp.co.future.uroborosql.context.test.testconsts                                                                 \nsqlcontextfactory.enumconstantpackagenames   sqlcontextfactoryに登録するenum定数パッケージ名を指定。,で区切ることで複数指定可。ex) jp.co.future.uroborosql.context.test                                                                      \n\nこのプロパティファイルを変更することでいろいろなdbに接続することができるようになります。\n\nこれまで見てきたようにreplを利用することで簡単にsql実行や動作確認ができるので、sql開発には欠かせないツールになります。 色々なsqlを記述してreplで試してみてください。\n\nこれで getting started は終了です。\n\nuroborosqlで使用するsqlの文法や基本的な操作については基本操作を参照してください。",charsets:{cjk:!0}},{title:"エンティティクラスを使用したDBアクセス",frontmatter:{meta:[{name:"og:title",content:"エンティティクラスを使用したDBアクセス"},{name:"og:url",content:"/uroborosql-doc/getting_started/entity-access.html"}]},regularPath:"/getting_started/entity-access.html",relativePath:"getting_started/entity-access.md",key:"v-1dc275ea",path:"/getting_started/entity-access.html",headers:[{level:2,title:"エンティティクラスを使用した検索",slug:"エンティティクラスを使用した検索",charIndex:114},{level:2,title:"エンティティクラスを使用した行挿入",slug:"エンティティクラスを使用した行挿入",charIndex:2726},{level:2,title:"エンティティクラスを使用した行更新",slug:"エンティティクラスを使用した行更新",charIndex:2966},{level:2,title:"エンティティクラスを使用した行削除",slug:"エンティティクラスを使用した行削除",charIndex:3272}],lastUpdated:"2019-10-20 21:14:04",headersStr:"エンティティクラスを使用した検索 エンティティクラスを使用した行挿入 エンティティクラスを使用した行更新 エンティティクラスを使用した行削除",content:'# エンティティクラスを使用したDBアクセス\nuroboroSQLではSQLファイルを使用したDBアクセスの他にエンティティクラスを使用したDBアクセスも提供しています。（EntityApiSample.javaを参照）\n\n# エンティティクラスを使用した検索\nエンティティクラスを使用した検索を行う際は、SqlAgent#query(エンティティクラス)メソッドを使用してSqlEntityQueryを取得し、バインドパラメータの設定や検索の実行を行います。\n\nSqlEntityQueryでは検索結果をいくつかの形式で取得することができます。\n\nメソッド                       説明                                                                      \nSqlEntityQuery#collect()   検索結果をList<エンティティクラス>の形式で取得する                                            \nSqlEntityQuery#stream()    検索結果をjava.util.Streamの形式で取得する                                           \nSqlEntityQuery#first()     検索結果の１件目を取得する。戻り値はOptional                                              \nSqlEntityQuery#one()       検索結果の１件目を取得する。検索結果が複数件になる場合はDataNonUniqueExceptionをスローする。戻り値はOptional   \n\nまずはテーブルに紐づくエンティティクラスを作成します。\n\n * Department.java\n\npackage jp.co.future.uroborosql.sample.entity;\n\nimport jp.co.future.uroborosql.enums.GenerationType;\nimport jp.co.future.uroborosql.mapping.annotations.GeneratedValue;\nimport jp.co.future.uroborosql.mapping.annotations.Id;\nimport jp.co.future.uroborosql.mapping.annotations.Table;\nimport jp.co.future.uroborosql.mapping.annotations.Version;\n\n/**\n * Entity that can be mapped to department table\n */\n@Table(name = "department")\npublic class Department {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long deptNo;\n\n    private String deptName;\n\n    @Version\n    private long lockVersion;\n\n    public long getDeptNo() {\n        return this.deptNo;\n    }\n\n    public void setDeptNo(final long deptNo) {\n        this.deptNo = deptNo;\n    }\n\n    public String getDeptName() {\n        return this.deptName;\n    }\n\n    public void setDeptName(final String deptName) {\n        this.deptName = deptName;\n    }\n\n    public long getLockVersion() {\n        return this.lockVersion;\n    }\n\n    public void setLockVersion(final long lockVersion) {\n        this.lockVersion = lockVersion;\n    }\n\n    @Override\n    public String toString() {\n        return "Department [deptNo=" + this.deptNo + ", deptName=" + this.deptName + ", lockVersion="\n                + this.lockVersion + "]";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n@Tableアノテーションをクラスに指定することでテーブルとの紐づけを行います。上記の場合はdepartmentテーブルと紐づけています。\nエンティティクラスの詳細についてはDAOインタフェースを参照してください。\n\nこのDepartmentクラスを使用した検索は以下のようになります。\n\n// no parameter : バインドパラメータ指定なしで検索\nList<Department> deps1 = agent.query(Department.class)\n    .collect();\n// add bind parameter : バインドパラメータを設定して検索\nList<Department> deps2 = agent.query(Department.class)\n    .equal("deptNo", 1)\n    .collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n検索結果の各行がDepartmentクラスのインスタンスとして取得出来ます。\n\n# エンティティクラスを使用した行挿入\nエンティティクラスを使用してテーブルに行挿入を行うことが出来ます。行挿入を行う場合はSqlAgent#insert(エンティティクラスインスタンス)メソッドを使用します。\n\nDepartment dept = new Department();\ndept.setDeptName("production");\n// insert entity : 行挿入\nint count = agent.insert(dept);\n\n\n1\n2\n3\n4\n# エンティティクラスを使用した行更新\nエンティティクラスを使用してテーブルの行更新を行うことが出来ます。行更新を行う場合はSqlAgent#update(エンティティクラスインスタンス)メソッドを使用します。\n\nDepartment dept = agent.query(Department.class)\n    .first().orElseThrow(UroborosqlRuntimeException::new);\ndept.setDeptName("R&D");\n// update entity : 行更新\nint count = agent.update(dept);\n\n\n1\n2\n3\n4\n5\n# エンティティクラスを使用した行削除\nエンティティクラスを使用してテーブルの行削除を行うことが出来ます。行更新を行う場合はSqlAgent#delete(エンティティクラスインスタンス)メソッドを使用します。\n\nDepartment dept = agent.query(Department.class)\n    .first().orElseThrow(UroborosqlRuntimeException::new);\n// delete entity : 行削除\nint count = agent.delete(dept);\n\n\n1\n2\n3\n4\nエンティティクラスを使用したDBアクセスの詳細についてはDAOインタフェースを参照してください。\n\nuroboroSQLではこれらの基本的な操作のほか、バッチ処理やトランザクション処理なども行うことができます。 詳細については基本操作を参照してください。',contentLowercase:'# エンティティクラスを使用したdbアクセス\nuroborosqlではsqlファイルを使用したdbアクセスの他にエンティティクラスを使用したdbアクセスも提供しています。（entityapisample.javaを参照）\n\n# エンティティクラスを使用した検索\nエンティティクラスを使用した検索を行う際は、sqlagent#query(エンティティクラス)メソッドを使用してsqlentityqueryを取得し、バインドパラメータの設定や検索の実行を行います。\n\nsqlentityqueryでは検索結果をいくつかの形式で取得することができます。\n\nメソッド                       説明                                                                      \nsqlentityquery#collect()   検索結果をlist<エンティティクラス>の形式で取得する                                            \nsqlentityquery#stream()    検索結果をjava.util.streamの形式で取得する                                           \nsqlentityquery#first()     検索結果の１件目を取得する。戻り値はoptional                                              \nsqlentityquery#one()       検索結果の１件目を取得する。検索結果が複数件になる場合はdatanonuniqueexceptionをスローする。戻り値はoptional   \n\nまずはテーブルに紐づくエンティティクラスを作成します。\n\n * department.java\n\npackage jp.co.future.uroborosql.sample.entity;\n\nimport jp.co.future.uroborosql.enums.generationtype;\nimport jp.co.future.uroborosql.mapping.annotations.generatedvalue;\nimport jp.co.future.uroborosql.mapping.annotations.id;\nimport jp.co.future.uroborosql.mapping.annotations.table;\nimport jp.co.future.uroborosql.mapping.annotations.version;\n\n/**\n * entity that can be mapped to department table\n */\n@table(name = "department")\npublic class department {\n    @id\n    @generatedvalue(strategy = generationtype.identity)\n    private long deptno;\n\n    private string deptname;\n\n    @version\n    private long lockversion;\n\n    public long getdeptno() {\n        return this.deptno;\n    }\n\n    public void setdeptno(final long deptno) {\n        this.deptno = deptno;\n    }\n\n    public string getdeptname() {\n        return this.deptname;\n    }\n\n    public void setdeptname(final string deptname) {\n        this.deptname = deptname;\n    }\n\n    public long getlockversion() {\n        return this.lockversion;\n    }\n\n    public void setlockversion(final long lockversion) {\n        this.lockversion = lockversion;\n    }\n\n    @override\n    public string tostring() {\n        return "department [deptno=" + this.deptno + ", deptname=" + this.deptname + ", lockversion="\n                + this.lockversion + "]";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n@tableアノテーションをクラスに指定することでテーブルとの紐づけを行います。上記の場合はdepartmentテーブルと紐づけています。\nエンティティクラスの詳細についてはdaoインタフェースを参照してください。\n\nこのdepartmentクラスを使用した検索は以下のようになります。\n\n// no parameter : バインドパラメータ指定なしで検索\nlist<department> deps1 = agent.query(department.class)\n    .collect();\n// add bind parameter : バインドパラメータを設定して検索\nlist<department> deps2 = agent.query(department.class)\n    .equal("deptno", 1)\n    .collect();\n\n\n1\n2\n3\n4\n5\n6\n7\n検索結果の各行がdepartmentクラスのインスタンスとして取得出来ます。\n\n# エンティティクラスを使用した行挿入\nエンティティクラスを使用してテーブルに行挿入を行うことが出来ます。行挿入を行う場合はsqlagent#insert(エンティティクラスインスタンス)メソッドを使用します。\n\ndepartment dept = new department();\ndept.setdeptname("production");\n// insert entity : 行挿入\nint count = agent.insert(dept);\n\n\n1\n2\n3\n4\n# エンティティクラスを使用した行更新\nエンティティクラスを使用してテーブルの行更新を行うことが出来ます。行更新を行う場合はsqlagent#update(エンティティクラスインスタンス)メソッドを使用します。\n\ndepartment dept = agent.query(department.class)\n    .first().orelsethrow(uroborosqlruntimeexception::new);\ndept.setdeptname("r&d");\n// update entity : 行更新\nint count = agent.update(dept);\n\n\n1\n2\n3\n4\n5\n# エンティティクラスを使用した行削除\nエンティティクラスを使用してテーブルの行削除を行うことが出来ます。行更新を行う場合はsqlagent#delete(エンティティクラスインスタンス)メソッドを使用します。\n\ndepartment dept = agent.query(department.class)\n    .first().orelsethrow(uroborosqlruntimeexception::new);\n// delete entity : 行削除\nint count = agent.delete(dept);\n\n\n1\n2\n3\n4\nエンティティクラスを使用したdbアクセスの詳細についてはdaoインタフェースを参照してください。\n\nuroborosqlではこれらの基本的な操作のほか、バッチ処理やトランザクション処理なども行うことができます。 詳細については基本操作を参照してください。',charsets:{cjk:!0}},{title:"uroboroSQLとは",frontmatter:{meta:[{name:"og:title",content:"uroboroSQLとは"},{name:"og:url",content:"/uroborosql-doc/why_uroborosql/"}]},regularPath:"/why_uroborosql/",relativePath:"why_uroborosql/README.md",key:"v-39db5ec0",path:"/why_uroborosql/",headers:[{level:2,title:"uroboroSQLを使う理由",slug:"uroborosqlを使う理由",charIndex:303},{level:2,title:"Further Reading",slug:"further-reading",charIndex:1077}],lastUpdated:"2019-9-4 23:08:33",headersStr:"uroboroSQLを使う理由 Further Reading",content:"# uroboroSQLとは\nuroboroSQLは2Way-SQLが利用可能なJava製のシンプルなSQL実行ライブラリです。\n\nフューチャーアーキテクト社内にて、2006-2007年頃にS2Daoを参考に開発され、プロジェクトで実際に利用されて現在まで改善が続けられてきました。社内ではWebアプリケーションフレームワークや各種設計開発支援ツールと連携・統合される形で利用されています。\n\nとはいえ、社内で秘伝のタレ化していることは否めず、開発フェーズでは開発パートナーさんからも「ググれない」から使い方がわからないいう声もちらほら。だったらOSS化してしまえということのが公開のきっかけです。\n\n# uroboroSQLを使う理由\nJavaからRDBにアクセスするとき、Java標準のJPA(Java Persistence API)の実装であるEclipseLink、OpenJPAはもとより、歴史のあるORMとしてHibernate、MyBatis、Spring Data JDBCといったグローバルで使われているものもありますし、日本でよく使われてきたS2Dao、S2JDBC、DBflute、Domaといったものもあります。\n\nこういった数多のDB系ライブラリ・フレームワークの中で解決したい領域もそれぞれですが、uroboroSQLは主にSQL中心の設計コンセプトを採用しています。Javaを中心に考えてSQLを組み立てるという思想ではなく、SQLに足りないところをJavaで補うという思想です。\n\nこれはエンタープライズシステムにおいて、ORマッパーやクエリビルダでは実装しきれない、hint句による実行計画の指定や分析関数の利用など複雑かつDBプロダクト依存のSQLを使う場合に有効と考えています。\n\nそのため、uroboroSQLはSQLは2Way-SQL方式で記述ができるものの、ORMでよくあるエンティティクラスとリレーションをたどって遅延ロードして子エンティティを取得するなどの機能は有していません。（単純なエンティティクラスへのマッピングは提供しています）\n\nその分、エンタープライズで培われたノウハウとして、区分値サポート、リトライ、フィルターによるカスタマイズなどの機能を充実させています。また、2Way-SQLのIF分岐に対してカバレッジを取れるようにするという、品質視点での機能があるのも特徴です。\n\nSQLの能力を最大限活かしつつ、生産性と品質を高めたい\nそれがuroboroSQLの最大の関心事なのです。\n\n# Further Reading\nuroboroSQLの紹介 (OSC2017 Tokyo/Spring) from Kenichi Hoshi",contentLowercase:"# uroborosqlとは\nuroborosqlは2way-sqlが利用可能なjava製のシンプルなsql実行ライブラリです。\n\nフューチャーアーキテクト社内にて、2006-2007年頃にs2daoを参考に開発され、プロジェクトで実際に利用されて現在まで改善が続けられてきました。社内ではwebアプリケーションフレームワークや各種設計開発支援ツールと連携・統合される形で利用されています。\n\nとはいえ、社内で秘伝のタレ化していることは否めず、開発フェーズでは開発パートナーさんからも「ググれない」から使い方がわからないいう声もちらほら。だったらoss化してしまえということのが公開のきっかけです。\n\n# uroborosqlを使う理由\njavaからrdbにアクセスするとき、java標準のjpa(java persistence api)の実装であるeclipselink、openjpaはもとより、歴史のあるormとしてhibernate、mybatis、spring data jdbcといったグローバルで使われているものもありますし、日本でよく使われてきたs2dao、s2jdbc、dbflute、domaといったものもあります。\n\nこういった数多のdb系ライブラリ・フレームワークの中で解決したい領域もそれぞれですが、uroborosqlは主にsql中心の設計コンセプトを採用しています。javaを中心に考えてsqlを組み立てるという思想ではなく、sqlに足りないところをjavaで補うという思想です。\n\nこれはエンタープライズシステムにおいて、orマッパーやクエリビルダでは実装しきれない、hint句による実行計画の指定や分析関数の利用など複雑かつdbプロダクト依存のsqlを使う場合に有効と考えています。\n\nそのため、uroborosqlはsqlは2way-sql方式で記述ができるものの、ormでよくあるエンティティクラスとリレーションをたどって遅延ロードして子エンティティを取得するなどの機能は有していません。（単純なエンティティクラスへのマッピングは提供しています）\n\nその分、エンタープライズで培われたノウハウとして、区分値サポート、リトライ、フィルターによるカスタマイズなどの機能を充実させています。また、2way-sqlのif分岐に対してカバレッジを取れるようにするという、品質視点での機能があるのも特徴です。\n\nsqlの能力を最大限活かしつつ、生産性と品質を高めたい\nそれがuroborosqlの最大の関心事なのです。\n\n# further reading\nuroborosqlの紹介 (osc2017 tokyo/spring) from kenichi hoshi",charsets:{cjk:!0}},{title:"高度な操作",frontmatter:{meta:[{name:"og:title",content:"高度な操作"},{name:"og:url",content:"/uroborosql-doc/advanced/"}]},regularPath:"/advanced/",relativePath:"advanced/README.md",key:"v-068e54e0",path:"/advanced/",headers:[{level:2,title:"SQLファイルの解決ルール",slug:"sqlファイルの解決ルール",charIndex:10},{level:3,title:"複数フォルダの指定",slug:"複数フォルダの指定",charIndex:26},{level:3,title:"jarファイルの指定",slug:"jarファイルの指定",charIndex:1080},{level:3,title:"Dialectによるファイルパスの切り替え",slug:"dialectによるファイルパスの切り替え",charIndex:1263},{level:2,title:"PostgreSQLのトランザクション内SQLエラー対応",slug:"postgresqlのトランザクション内sqlエラー対応",charIndex:1391},{level:2,title:"SQLカバレッジ ( uroborosql.sql.coverage )",slug:"sqlカバレッジ-uroborosql-sql-coverage",charIndex:2491},{level:3,title:"サマリーページ",slug:"サマリーページ",charIndex:3465},{level:3,title:"詳細ページ",slug:"詳細ページ",charIndex:3477},{level:2,title:"ログ出力",slug:"ログ出力",charIndex:3495},{level:2,title:"システムプロパティ",slug:"システムプロパティ",charIndex:6041}],lastUpdated:"2020-3-8 21:44:34",headersStr:"SQLファイルの解決ルール 複数フォルダの指定 jarファイルの指定 Dialectによるファイルパスの切り替え PostgreSQLのトランザクション内SQLエラー対応 SQLカバレッジ ( uroborosql.sql.coverage ) サマリーページ 詳細ページ ログ出力 システムプロパティ",content:'# 高度な操作\n# SQLファイルの解決ルール\n# 複数フォルダの指定\nsqlフォルダはクラスパスから参照することが出来れば複数指定することが出来ます。\n\n * src/test/resources, src/main/resources の順にクラスパスに指定されている場合\n\nsrc\n    ├─main\n    │   └─resources\n    │       └─sql\n    │           ├─department\n    │           │    ├─insert_department.sql\n    │           │    └─select_department.sql\n    │           └─employee\n    │                ├─insert_employee.sql\n    │                └─select_employee.sql\n    └─test\n        └─resources\n            └─sql\n                ├─department\n                │    ├─update_department.sql\n                │    └─delete_department.sql\n                └─employee\n                     ├─update_employee.sql\n                     └─select_employee.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nWARNING\n\nSQLファイルのパスが重複している場合、クラスパス上で先にあるフォルダのSQLファイルが使用されます。\n\n上記のフォルダ構成の場合、src/main/resources/sql/employee/select_employee.sql と src/test/resources/sql/employee/select_employee.sql がともに employee/select_employee として解決されますが、クラスパスとしてsrc/test/resourcesが先に指定されているため、src/test/resources/sql/employee/select_employee.sqlが使用されます。\n\n# jarファイルの指定\nSQLファイルはjarの中にリソースとして含めることもできます。\nその場合、リソースのルート直下のsqlフォルダをルートフォルダとした相対パスでSQLファイルを指定することができます。 SQLファイルのルートフォルダ（初期値：sql)は変更することができます。\n変更方法の詳細は SQLファイルルートフォルダの設定 を参照してください。\n\n# Dialectによるファイルパスの切り替え\nNioSqlManagerImplをSqlManagerとして指定した場合、Dialectによるファイルパスの切り替えが出来るようになります。 詳しくはDB種類毎のファイルパス切り替えを参照してください。\n\n# PostgreSQLのトランザクション内SQLエラー対応\nPostgreSQLでは、１つのトランザクション内でSQLエラーが発生した場合、後続するSQL文はすべて無条件でエラーとなります。 この状態はトランザクションに対してcommitもしくはrollbackを実行するまで続きます。\n\nWARNING\n\nエラーが発生している状態でcommitを実行しても実際にはrollbackされます\n\nこれはPostgreSQL固有の動作であり、通常は問題ない動作なのですが、テーブルロックエラーなどリトライ処理を行うケースで問題になります。 （SQLのリトライについてはSQL実行のリトライを参照）\nuroboroSQLではリトライ指定のあるSQL実行、かつ、PostgreSQL（より正確にはDialect#isRollbackToSavepointBeforeRetry()がtrueの場合）の場合にsavepointを使った部分ロールバックを行うことで この問題に対応しています。\n具体的にはリトライ指定のあるSQL実行、かつ、PostgreSQLの場合はSQL実行の直前にリトライ用のsavepointを設定し、SQL実行が成功すればsavepointの解放、SQL実行が失敗した場合はリトライ用のsavepointまでロールバックを行います。\n\nWARNING\n\nリトライ指定のないSQL実行の場合はsavepointの設定は行われません。\n\nリトライ指定のないSQLで上記と同様の動作を行う場合は以下のように実装してください。\n\nagent.required(() -> { // トランザクション開始\n  agent.savepointScope(() -> {\n    // savepointScopeの開始\n    agent.update("example/insert_product")\n      .param("product_id", 1)\n      .count();\n  });\n  agent.savepointScope(() -> {\n    // 後続処理\n    int count = agent.update("department/insert_department")\n      .param("dept_no", 1)\n      .param("dept_name", "Sales")\n      .count();\n      ・・・\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# SQLカバレッジ ( uroborosql.sql.coverage )\nこれまでアプリケーション上の条件分岐はカバレッジツールを利用して網羅率を確認することができました。\nしかし、SQL文の条件分岐は実際にその分岐が通っているかどうかを確認する手段がなく、リリース後に初めて通った条件で不具合を発生させることがありました。\nこの問題を解決するためにuroboroSQLでは、SQL文の条件分岐を集計してカバレッジレポートを行う機能を提供します。\n\nSQLカバレッジはuroboroSQLを利用するアプリケーションの起動時オプションに\n\n-Duroborosql.sql.coverage=true\n\n\n1\nを追加することで有効になります。\nSQLカバレッジを有効にするとアプリケーションが実行している間に実行されるSQLについて、カバレッジ情報が収集されます。\nカバレッジ情報の収集結果は標準ではtarget/coverage/sql-cover.xmlに出力されます。\nこのファイルの場所や名前を変更したい場合は、起動時オプションに\n\n-Duroborosql.sql.coverage.file=[出力ファイルパス]\n\n\n1\nを指定してください。\n\n出力されたsql-cover.xmlをJenkinsのCobertura pluginなどのXMLレポートとして読み込むとSQLファイルのカバレッジレポートが参照できるようになります。\n\n\n\nまたより、uroboroSQLのみでHTMLレポートを出力することができるようになりました。\n起動時オプションに\n\n-Duroborosql.sql.coverage=jp.co.future.uroborosql.coverage.reports.html.HtmlReportCoverageHandler\n\n\n1\nを指定することで本機能を利用することができます。\n\nカバレッジ情報はデフォルトではtarget/coverage/sqlフォルダ配下に出力されます。\n出力先フォルダを変更した場合は、起動時オプションに\n\n-Duroborosql.sql.coverage.dir=[出力フォルダパス]\n\n\n1\nを指定してください。\n\n出力されたレポートのサンプルは下記を参照してください。\n\n# サマリーページ\n\n\n# 詳細ページ\n\n\n出力サンプル\n\n# ログ出力\nuroboroSQLではログ出力ライブラリとしてSLF4Jを使用しています。SLF4Jの詳細は公式のドキュメントを参照して下さい。\nuroboroSQLで出力されるログ内容は以下表の通りです。\n\nクラス名                    TRACE              DEBUG                    INFO   WARN                ERROR             FATAL   \nAbstractAgent           変換前SQL             実行時SQL                   -      -                   -                 -       \nDebugSqlFilter          -                  パラメーター/                  -      -                   -                 -       \n                                           対象データ数/                                                                       \n                                           実行結果                                                                          \nIfNode                  -                  評価式/                     -      -                   -                 -       \n                                           判定結果/                                                                         \n                                           パラメーター                                                                        \nParameter               -                  パラメーターの設定                -      サブパラメーター値にNULLを設定   -                 -       \nSecretColumnSqlFilter   -                  バッチ処理追加件数/               -      -                   -                 -       \n                                           ストアドプロシージャ出力パラメーター                                                            \nSqlAgent                ステートメントのクローズ       処理実行アナウンス/               -      -                   エラーメッセージ          -       \n                                           リトライ実行アナウンス/                                                                  \n                                           SQL実行時間                                                                       \nSqlContext              -                  バッチ処理追加件数/               -      -                   -                 -       \n                                           ストアドプロシージャ出力パラメーター                                                            \nSqlContextFactory       -                  定数パラメーター                 -      定数名の重複              エラーメッセージ          -       \nSqlLoader               SQL定義ファイルの読み込み完了   SQL定義ファイルの読み込み開始/読み込み中   -      -                   デフォルトファイルパスの設定/   -       \n                                                                                               デフォルト拡張子/                 \n                                                                                               空のSQLキャッシュの返却             \n\n# システムプロパティ\nuroboroSQLではシステムプロパティを指定することで動作を変更することができます。\n\nプロパティ名                         説明                                                               初期値                               \nuroborosql.sql.coverage        SQLカバレッジを出力するかどうかのフラグ。trueの場合はSQLカバレッジを出力します。                    なし                                \n                               文字列としてjp.co.future.uroborosql.coverage.CoverageHandlerインタフェースの                                     \n                               実装クラスが設定された場合はそのクラスを利用してカバレッジの収集を行います。                                                             \nuroborosql.sql.coverage.file   指定されたPATH(ファイル)に SQLカバレッジのCobertura形式のxmlレポートを出力します。             ./target/coverage/sql-cover.xml   \nuroborosql.sql.coverage.dir    指定されたPATH(フォルダ)にSQLカバレッジのHTMLレポートを出力します。                         ./target/coverage/sql             \nuroborosql.entity.cache.size   Entityクラス情報のキャッシュサイズを指定します。                                      30                                \n                               キャッシュサイズを超えるEntityクラスの読み込みがあった場合は古い情報から破棄されます。',contentLowercase:'# 高度な操作\n# sqlファイルの解決ルール\n# 複数フォルダの指定\nsqlフォルダはクラスパスから参照することが出来れば複数指定することが出来ます。\n\n * src/test/resources, src/main/resources の順にクラスパスに指定されている場合\n\nsrc\n    ├─main\n    │   └─resources\n    │       └─sql\n    │           ├─department\n    │           │    ├─insert_department.sql\n    │           │    └─select_department.sql\n    │           └─employee\n    │                ├─insert_employee.sql\n    │                └─select_employee.sql\n    └─test\n        └─resources\n            └─sql\n                ├─department\n                │    ├─update_department.sql\n                │    └─delete_department.sql\n                └─employee\n                     ├─update_employee.sql\n                     └─select_employee.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nwarning\n\nsqlファイルのパスが重複している場合、クラスパス上で先にあるフォルダのsqlファイルが使用されます。\n\n上記のフォルダ構成の場合、src/main/resources/sql/employee/select_employee.sql と src/test/resources/sql/employee/select_employee.sql がともに employee/select_employee として解決されますが、クラスパスとしてsrc/test/resourcesが先に指定されているため、src/test/resources/sql/employee/select_employee.sqlが使用されます。\n\n# jarファイルの指定\nsqlファイルはjarの中にリソースとして含めることもできます。\nその場合、リソースのルート直下のsqlフォルダをルートフォルダとした相対パスでsqlファイルを指定することができます。 sqlファイルのルートフォルダ（初期値：sql)は変更することができます。\n変更方法の詳細は sqlファイルルートフォルダの設定 を参照してください。\n\n# dialectによるファイルパスの切り替え\nniosqlmanagerimplをsqlmanagerとして指定した場合、dialectによるファイルパスの切り替えが出来るようになります。 詳しくはdb種類毎のファイルパス切り替えを参照してください。\n\n# postgresqlのトランザクション内sqlエラー対応\npostgresqlでは、１つのトランザクション内でsqlエラーが発生した場合、後続するsql文はすべて無条件でエラーとなります。 この状態はトランザクションに対してcommitもしくはrollbackを実行するまで続きます。\n\nwarning\n\nエラーが発生している状態でcommitを実行しても実際にはrollbackされます\n\nこれはpostgresql固有の動作であり、通常は問題ない動作なのですが、テーブルロックエラーなどリトライ処理を行うケースで問題になります。 （sqlのリトライについてはsql実行のリトライを参照）\nuroborosqlではリトライ指定のあるsql実行、かつ、postgresql（より正確にはdialect#isrollbacktosavepointbeforeretry()がtrueの場合）の場合にsavepointを使った部分ロールバックを行うことで この問題に対応しています。\n具体的にはリトライ指定のあるsql実行、かつ、postgresqlの場合はsql実行の直前にリトライ用のsavepointを設定し、sql実行が成功すればsavepointの解放、sql実行が失敗した場合はリトライ用のsavepointまでロールバックを行います。\n\nwarning\n\nリトライ指定のないsql実行の場合はsavepointの設定は行われません。\n\nリトライ指定のないsqlで上記と同様の動作を行う場合は以下のように実装してください。\n\nagent.required(() -> { // トランザクション開始\n  agent.savepointscope(() -> {\n    // savepointscopeの開始\n    agent.update("example/insert_product")\n      .param("product_id", 1)\n      .count();\n  });\n  agent.savepointscope(() -> {\n    // 後続処理\n    int count = agent.update("department/insert_department")\n      .param("dept_no", 1)\n      .param("dept_name", "sales")\n      .count();\n      ・・・\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# sqlカバレッジ ( uroborosql.sql.coverage )\nこれまでアプリケーション上の条件分岐はカバレッジツールを利用して網羅率を確認することができました。\nしかし、sql文の条件分岐は実際にその分岐が通っているかどうかを確認する手段がなく、リリース後に初めて通った条件で不具合を発生させることがありました。\nこの問題を解決するためにuroborosqlでは、sql文の条件分岐を集計してカバレッジレポートを行う機能を提供します。\n\nsqlカバレッジはuroborosqlを利用するアプリケーションの起動時オプションに\n\n-duroborosql.sql.coverage=true\n\n\n1\nを追加することで有効になります。\nsqlカバレッジを有効にするとアプリケーションが実行している間に実行されるsqlについて、カバレッジ情報が収集されます。\nカバレッジ情報の収集結果は標準ではtarget/coverage/sql-cover.xmlに出力されます。\nこのファイルの場所や名前を変更したい場合は、起動時オプションに\n\n-duroborosql.sql.coverage.file=[出力ファイルパス]\n\n\n1\nを指定してください。\n\n出力されたsql-cover.xmlをjenkinsのcobertura pluginなどのxmlレポートとして読み込むとsqlファイルのカバレッジレポートが参照できるようになります。\n\n\n\nまたより、uroborosqlのみでhtmlレポートを出力することができるようになりました。\n起動時オプションに\n\n-duroborosql.sql.coverage=jp.co.future.uroborosql.coverage.reports.html.htmlreportcoveragehandler\n\n\n1\nを指定することで本機能を利用することができます。\n\nカバレッジ情報はデフォルトではtarget/coverage/sqlフォルダ配下に出力されます。\n出力先フォルダを変更した場合は、起動時オプションに\n\n-duroborosql.sql.coverage.dir=[出力フォルダパス]\n\n\n1\nを指定してください。\n\n出力されたレポートのサンプルは下記を参照してください。\n\n# サマリーページ\n\n\n# 詳細ページ\n\n\n出力サンプル\n\n# ログ出力\nuroborosqlではログ出力ライブラリとしてslf4jを使用しています。slf4jの詳細は公式のドキュメントを参照して下さい。\nuroborosqlで出力されるログ内容は以下表の通りです。\n\nクラス名                    trace              debug                    info   warn                error             fatal   \nabstractagent           変換前sql             実行時sql                   -      -                   -                 -       \ndebugsqlfilter          -                  パラメーター/                  -      -                   -                 -       \n                                           対象データ数/                                                                       \n                                           実行結果                                                                          \nifnode                  -                  評価式/                     -      -                   -                 -       \n                                           判定結果/                                                                         \n                                           パラメーター                                                                        \nparameter               -                  パラメーターの設定                -      サブパラメーター値にnullを設定   -                 -       \nsecretcolumnsqlfilter   -                  バッチ処理追加件数/               -      -                   -                 -       \n                                           ストアドプロシージャ出力パラメーター                                                            \nsqlagent                ステートメントのクローズ       処理実行アナウンス/               -      -                   エラーメッセージ          -       \n                                           リトライ実行アナウンス/                                                                  \n                                           sql実行時間                                                                       \nsqlcontext              -                  バッチ処理追加件数/               -      -                   -                 -       \n                                           ストアドプロシージャ出力パラメーター                                                            \nsqlcontextfactory       -                  定数パラメーター                 -      定数名の重複              エラーメッセージ          -       \nsqlloader               sql定義ファイルの読み込み完了   sql定義ファイルの読み込み開始/読み込み中   -      -                   デフォルトファイルパスの設定/   -       \n                                                                                               デフォルト拡張子/                 \n                                                                                               空のsqlキャッシュの返却             \n\n# システムプロパティ\nuroborosqlではシステムプロパティを指定することで動作を変更することができます。\n\nプロパティ名                         説明                                                               初期値                               \nuroborosql.sql.coverage        sqlカバレッジを出力するかどうかのフラグ。trueの場合はsqlカバレッジを出力します。                    なし                                \n                               文字列としてjp.co.future.uroborosql.coverage.coveragehandlerインタフェースの                                     \n                               実装クラスが設定された場合はそのクラスを利用してカバレッジの収集を行います。                                                             \nuroborosql.sql.coverage.file   指定されたpath(ファイル)に sqlカバレッジのcobertura形式のxmlレポートを出力します。             ./target/coverage/sql-cover.xml   \nuroborosql.sql.coverage.dir    指定されたpath(フォルダ)にsqlカバレッジのhtmlレポートを出力します。                         ./target/coverage/sql             \nuroborosql.entity.cache.size   entityクラス情報のキャッシュサイズを指定します。                                      30                                \n                               キャッシュサイズを超えるentityクラスの読み込みがあった場合は古い情報から破棄されます。',charsets:{cjk:!0}}],themeConfig:{logo:"/images/logo.png",repo:"https://github.com/future-architect/uroborosql",docsRepo:"https://github.com/future-architect/uroborosql-doc",docsDir:"src",editLinks:!0,lastUpdated:!0,searchMaxSuggestions:15,sidebarDepth:2,nav:[{text:"Home",link:"/"},{text:"Getting Started",link:"/getting_started/"},{text:"基本操作",link:"/basics/"},{text:"設定",link:"/configuration/"},{text:"高度な操作",link:"/advanced/"},{text:"Developer Tools",link:"/developer_tools/"}],sidebar:[{title:"Why uroboroSQL",collapsable:!0,children:["/why_uroborosql/"]},{title:"Getting Started",collapsable:!0,children:["/getting_started/","/getting_started/sql-file-access","/getting_started/entity-access","/getting_started/sql-repl"]},{title:"前提知識",collapsable:!0,children:["/background/","/background/el"]},{title:"基本操作",collapsable:!0,children:["/basics/","/basics/sql-file-api","/basics/entity-api","/basics/transaction"]},{title:"設定",collapsable:!0,children:["/configuration/","/configuration/connection-supplier","/configuration/sql-context-factory","/configuration/sql-agent-factory","/configuration/sql-manager","/configuration/sql-filter-manager","/configuration/entity-handler","/configuration/dialect"]},{title:"高度な操作",collapsable:!0,children:["/advanced/"]},"/developer_tools/","/developer_guide/","/license/","/about/"]},locales:{"/":{lang:"ja",path:"/"}}};t(144);Na.component("mermaid",()=>t.e(10).then(t.bind(null,200))),Na.component("Badge",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,225))),Na.component("CodeBlock",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,198))),Na.component("CodeGroup",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,197)));t(145);var ii={props:{color:{required:!1,default:"rgb(66, 185, 131)"}}},li=(t(146),Object(ri.a)(ii,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"spinner",style:{background:this.color}})}),[],!1,null,"1bbcb91a",null).exports);const ci={name:"Mermaid",props:{id:{type:String,required:!0},graph:{type:String,required:!0}},data:()=>({svg:void 0}),render(n){return void 0===this.svg?n("Loading"):n("div",{domProps:{innerHTML:this.svg,style:"width: 100%"}})},mounted(){t.e(34).then(t.t.bind(null,194,7)).then(n=>{n.initialize({startOnLoad:!0});let e=document.createElement("div");document.body.appendChild(e),n.render(this.id,this.graph,n=>{this.svg=n,document.body.removeChild(e)},e)})},components:{Loading:li}};var pi=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{var e,t,r,a,o,s;"undefined"!=typeof window&&(e=window,t=document,r="script",a="ga",e.GoogleAnalyticsObject=a,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,o=t.createElement(r),s=t.getElementsByTagName(r)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s),ga("create","UA-93486523-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),n.afterEach((function(n){ga("set","page",n.fullPath),ga("send","pageview")})))},({Vue:n})=>{n.component("Mermaid",ci)}],ui=[];class di extends class{constructor(){this.store=new Na({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Na.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(di.prototype,{getPageAsyncComponent:Fs,getLayoutAsyncComponent:Rs,getAsyncComponent:Ms,getVueComponent:$s});var mi={install(n){const e=new di;n.$vuepress=e,n.prototype.$vuepress=e}};function fi(n,e){return n.options.routes.filter(n=>n.path.toLowerCase()===e.toLowerCase()).length>0}var gi={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Bs("pageKey",e),Na.component(e)||Na.component(e,Fs(e)),Na.component(e)?n(e):n("")}},hi={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},yi={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},vi=(t(147),t(148),Object(ri.a)(yi,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),qi={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Na.config.productionTip=!1,Na.use(Es),Na.use(mi),Na.mixin(function(n,e,t=Na){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},si)),Na.component("Content",gi),Na.component("ContentSlotsDistributor",hi),Na.component("OutboundLink",vi),Na.component("ClientOnly",qi),Na.component("Layout",Rs("Layout")),Na.component("NotFound",Rs("NotFound")),Na.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.7.1",hash:"9c7bb6d"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:si.routerBase||si.base,t=new Es({base:e,mode:"history",fallback:!1,routes:oi,scrollBehavior:(n,e,t)=>t||(n.hash?!Na.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(fi(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";fi(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";fi(n,a)?r(a):fi(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(pi.filter(n=>"function"==typeof n).map(e=>e({Vue:Na,options:r,router:t,siteData:si,isServer:n})))}catch(n){console.error(n)}return{app:new Na(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ui.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);